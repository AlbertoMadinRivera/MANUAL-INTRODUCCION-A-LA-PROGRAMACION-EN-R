---
title: "**MANUAL: INTRODUCCIÒN A LA PROGRAMACIÓN Y AL DATA SCIENCE EN ```R```**"
author:
- Madin Rivera, Alberto.
date: "`r format(Sys.time(), '%b %d, %Y')`"
header-includes:
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhf{}
- \fancyhead[RE,LO]{Introducción a la Programación en R}
- \fancyfoot[CE,CO]{\leftmark}
- \fancyfoot[LE,RO]{}
- \fancyfoot[LE,RO]{\thepage}
- \usepackage{titling}
- \pretitle{\begin{center}
- \includegraphics[]{Título.png}\LARGE\\}
- \posttitle{\end{center}}
output:
  pdf_document
fontsize: 12pt
lang: es-MX
documentclass: article
classoptions: 4paper
csl: acm-sig-proceedings-long-author-list-csl
geometry: margin = 2.5cm
urlcolor: #3498DB
linkcolor: #3498DB
link-citations: yes
---

\thispagestyle{empty}

\newpage

\begin{flushright}
\textit{Dedicado para Itzel L.} \\
N.R. \\
\textit{Para mi Familia} \\
M.R \\
\textit{Para mis compañeros y amigos de Universidad} \\
\textit{Para mis compañeros de trabajo} \\
\textit{Para todos los colegas que se \\ encuentran aprendiendo \\ ciencia de datos} \\
\end{flushright}

\newpage

\thispagestyle{empty}
\tableofcontents
\thispagestyle{empty}

\newpage

# INTRODUCCIÓN

\newpage

```R``` es un entorno y lenguaje de programación con un enfoque de análisis estadístico. R nacio como una reimplementación de software libre del lenguaje S, adicionando con el soporte para ámbito estático. Se trata de uno de los lenguajes de programación más utilizados en investigación científica, siendo además muy popular en los campos de aprendizaje automático (machine learning), minería de datos, investigación biomédica, bioinformática y matemáticas financieras. A esto contribuye la posibilidad de cargar diferentes bibliotecas o paquetes con funcionalidades de cálculo y graficación.[^kwest]

[^kwest]: Wikipedia (2022), *"r (lenguaje de programación)"*. Disponible en: https://es.wikipedia.org/wiki/R_(lenguaje_de_programaci%C3%B3n)

El manual se divide en 24 capítulos con los que se encuentran fundamentos de uso e introducción a la programación, uso de estadística, graficación de datos y leer archivos.

La primera parte comprende desde el capítulo 1 hasta el capítulo 6; que va desde la instalación de R en Windows, Mac, comprobar la ruta de instalación del software, operadores aritméticos, booleanos, relacionales, aprender a usar los pipe, el uso de los vectores en R, cómo generarlos y su implementación básica en la programación, el uso y creacion de matrices en R, cómo generar y su especificación para los data frames, instalación de paquetes en R para tener una mayor optimización en cuanto a los gráficos, uso de matemáticas, datos, lectores de archivos, entre muchos otros más.

La segunda parte comprende desde el capítulo 7 hasta el capítulo 14; comprendiendo temas de estadística básica como lo son: las medidas de tendencia central (cálculo de la media, mediana y moda), y medidas de dispersión (desviación típica o estándar y varianza de unos datos). También el uso y creación de una tabla de contingencia en R para una muestra de datos, el uso de distribuciones estadísticas como lo son: la distribución uniforme continua, distribución de poisson, distribución binomial, distribución exponencial, distribución gaussiana o normal (siendo esta la más importante en el uso de la estadística descriptiva e inferencial de datos).

La tercera parte comprende desde el capítulo 15 hasta el capítulo 21; que van desde temas de cómo usar funciones de gráficos normales en R base, usar la función ```plot()``` y conocer cuáles son sus componentes principales, mejorar el gráfico base y su implementación en los datos estadísticos. Generar gráficos de dispersión desde la base R y con el uso del paquete  ```ggplot2```. Crear gráfico de barras y conocer su uso principal en la estadística y en la programación. Histogramas y gráficos de densidad y su implementación en la inferencia estadística, los boxplot y su implementación para la descripción estadística general junto con su importancia en el uso de datos. Por último, el conocer cómo exportar los gráficos de diferentes maneras, a través de códigos o de documentos pdf o jpg a través de los comandos que ofrece RStudio.

Por último, la cuarta parte comprende desde el capítulo 22 hasta el capítulo 24; teniendo ya en mente la implementación de las grande bases de datos para leer a través de documentos en formato EXCEL, CSV y TXT. Esto ayudará para terminar la forma de aprendizaje básico como un analista de datos, en un lenguaje de programación popular.[^alienpopa]

[^alienpopa]: Este manual no incluye una sección de bibliografía. Esto debido a que cada uno de los temas fueron obtenidos a través de la página oficial [**R CODER**](https://r-coder.com/inicio/), la cual se encontrará disponible el link o enlace de cada uno de los temas proporcionados a través de dar ***click*** a cada uno de los títulos de los capítulos que se han incluido. También, se incluye bibliografía oficial de la página [**Economipedia**](https://economipedia.com/), la cual se encuentra disponible al dar click a las palabras que se encuentren en negrita de datos o definiciones estadísticas. Siendo algo práctico para conocer con mayor profundidad los conocimientos adquiridos de manera resumida que ofrece este manual. **Los agradecimientos principales se reconocen a ambas páginas mencionadas anteriormente**.

\newpage
\pagenumbering{gobble}
# CAPÍTULO 1
\pagenumbering{arabic}
\newpage


## [**¿CÓMO INSTALAR R**](https://r-coder.com/instalar-r/)

![](installing-r.png)

El lenguaje de programación R es un **proyecto de código abierto gratuito para computación estadística**. Compila paraplataformas tipo UNIX y varias versiones de macOS y Windows. Para ejecutar la última versión se necesitará **Windows 7 o posterior** o **Mac OS X 10.6 y superior**. En este caapítulo se aprenderá a descargar y usar R CRAN project desde cero.

\newpage

## INSTALANDO R

El primer paso para convertirse en un analista o científico de datos es tener R instalado en el ordenador. R se puede descargar libremente de su página oficial. Hay que tener en cuenta que la instalación requiere hasta **150 MB de espacio** de almacenamiento en disco disponible. La página web oficial del proyecto R es la siguiente:

[www.r-project.org](www.r-project.org)

En el enlace anterior puedes encontrar información interesante sobre el proyecto R, la Fundación R, los lanzamientos de nuevas versiones, documentación y otros enlaces interesantes.

## INSTALAR R EN WINDOWS

Para instalar R en Windows, se puede acceder al siguiente enlace y hacer clic en *“Download R x.x.x for Windows”* para comenzar a descargar la última versión de R disponible.

[https://cran.r-project.org/bin/windows/base/](https://cran.r-project.org/bin/windows/base/)

Una vez descargado, se abre, selecciona el idioma preferido y se da clic en *“Siguiente”* a todos los cuadros de diálogo.

![](Instalar-r2.png)

Se selecciona la ruta donde se quiere instalar R:

![](Instalar-r-3.png)

Hay que tener en cuenta que se puede demarcar los archivos de bits que no corresponden a la PC:

![](instalar-r-4.png)

También se puede especificar y personalizar algunas opciones de inicio, aunque podrás modificarlas una vez instalado R si se prefiere:

![](instalar-r-5.png)

Cuando finalice la instalación, se podrá comenzar a utilizar R base en Windows:

![](instalar-r-6.png)

## INSTALAR R EN MAC OS

El proceso de instalación de R en una Mac es análogo a la instalación en Windows. Se puede descargar el paquete binario (para Mac OS X 10.6 y superior) desde la siguiente URL y luego instalarlo:

[https://cran.r-project.org/bin/macosx/](https://cran.r-project.org/bin/macosx/)

Si por alguna razón se está utilizando versiones de Mac OS 8.6 A 9.2 (y Mac OS X 10.1) se puede encontrar aquí los paquetes binarios antiguos: [https://cran.r-project.org/bin/macos/](https://cran.r-project.org/bin/macos/). Para sistemas Mac OS X y PowerPC Macs anteriores, se debe usar el siguiente repositorio para descargar R: [https://cran.r-project.org/bin/macosx/old/](https://cran.r-project.org/bin/macosx/old/).

## INSTALAR R CON HOMEBREW

Una alternativa para instalar R en macOS es usar el administrador de paquetes Homebrew. Para ese propósito solo se necesita escribir lo siguiente en la terminal correspondiente:

```{r eval=FALSE}
$ brew install r
```

## INSTALAR RSTUDIO

RStudio es el **IDE más popular para R**, proporcionando una interfaz gráfica limpia y útil para desarrollar código R. Las principales ventajas de este IDE son el panel para obtener ayuda y mostrar gráficos (incluso interactivos), crear documentos RMarkdown y Sweave, entre otros. Puedes descargar RStudio desde el siguiente enlace, seleccionando el archivo correspondiente a tu sistema operativo:

[https://rstudio.com/products/rstudio/download/#download](https://rstudio.com/products/rstudio/download/#download)

Una vez descargado, se abre el asistente de configuración y se siguen los sencillos pasos de instalación.

## COMANDOS BÁSICOS DE R

Después de descargar R y RStudio, abre uno y verás el IDE (siglas en inglés de entorno de desarrollo integrado) correspondiente. Primero, se intentará escribir comandos directos en la ventana de comandos, (donde se encuentra el símbolo **>**) para comenzar a escribir. **Intentemos escribir lo siguiente y se presiona Enter**:

```{r, eval=FALSE}
(5 + 6) * (4 - 2)^2
```
```{r, eval=FALSE}
# Salida de la ecuación
[1] 44
```


También se puede **escribir en una ventana llamada script** y ejecutar el código cuando quieras. Si esta ventana no aparece a primera vista, ve a **Archivo** → **Nuevo archivo** → **R Script** o si se está utilizando RStudio presiona **Ctr + Shift + n** o **Cmd + Shift + n** en Mac.

Una vez abierto, se copia y pega el código en el script, seleccionando y se presiona **Ctr + r o Cmd + r** en R base o **Ctr + Enter o Cmd + Enter** en RStudio (se puede personalizar el atajo de teclado). En el siguiente bloque de código hay **varios ejemplos que puedes probar**.

```{r eval=FALSE}
log(12) # Logaritmo de 6
exp(8) # Exponencial de 8
sqrt(36) # Raíz cuadrada de 36
pi # Reconoce el número pi
```

```{r, eval=FALSE}
# Salida de las ecuaciones anteriores
[1] 2.484907
[1] 2980.958
[1] 6
[1] 3.141593
```


![](script-consola.png)

Cabe señalar que se puede usar el símbolo **#** para escribir cometarios que no se ejecutarán.

```{r eval=FALSE}
sin(3 * pi) # Seno de 3 pi
```

```{r eval=FALSE}
# Salida
[1] 3.673819e-16
```


También es posible escribir varias instrucciones dentro de la misma línea, utilizando un punto y coma (**;**) como separador, aunque esta práctica no es recomendable.

```{r eval=FALSE}
# Ejecutando dos comandos en una misma línea
1 + 4; 2 * 3 - 8
```

```{r, eval=FALSE}
# Salida
[1] 5
[1] -2
```

Si se quiere **almacenar los valores en variables**, se puede usar el signo **=** o **<-**. Si se desea imprimir las variables almacenadas en la consola, se llama al nombre o ejecuta la línea de asignación entre paréntesis.


```{r eval=FALSE}
a = 8 + 2
a # Devuelve la variable 'a'

b <- 1:15
b

a + b # Imprime el resultado de la suma

A <- "coche"
A

(A <- "coche") # Imprime 'coche' en la consola
```

```{r, eval=FALSE}
# Salida
[1] 10
[1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
[1] 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[1] "coche"
[1] "coche"
```

## EJEMPLO MÁS DETALLADO

Un ejemplo más avanzado. Vamos a simular una variable aleatoria normal de tamaño 200 con media de 105 y desviación típica de 2. Luego, haremos un resumen, un histograma y el diagrama de caja correspondiente.

```{r, eval=FALSE}
# Semilla para reproductibilidad
set.seed(1)

# Generando los datos
x = rnorm(n = 200, mean = 105, sd = 2)

# Primeros elementos de los datos
head(x)

# Resumen estadístico de los datos
summary(x)
```

```{r, eval=FALSE}
# Salida
[1] 103.7471 105.3673 103.3287 108.1906 105.6590 103.3591
    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    100.6   103.8   104.9   105.1   106.2   109.8 
```

Generamos los gráficos correspondientes para visualizar el resumne estadístico anterior generado.

```{r include=FALSE}
# Semilla para reproductibilidad
set.seed(1)

# Generando los datos
x = rnorm(n = 200, mean = 105, sd = 2)

# Primeros elementos de los datos
head(x)

# Resumen estadístico de los datos
summary(x)
```

```{r}
# Se divide la pantalla gráfica en dos columnas
par(mfcol = c(1, 2))

# Se dibuja un histograma
hist(x, col = 8)

# Se dibuja un gráfico de cajas
boxplot(x, horizontal = TRUE, col = 8)

# Se regresa la pantalla gráfica a una columna
par(mfcol = c(1, 1))
```

## COMPROBAR DÓNDE ESTÁ INSTALADO R

LA función **R.home()** generará la ruta donde se tiene instalado R en el ordenador. Se escribe lo siguiente en la consola de R si se desea verificar cuál es la ruta de instalación:

```{r eval=FALSE}
R.home()
```

## COMPROBAR LA VERSIÓN DE R

También se puede verificar que se ha descargado e instalado la versión correcta escribiendo:

```{r eval=FALSE}
R.Version()$version.string
```

```{r, eval=FALSE}
# Salida
[1] "R version 4.1.2 (2021-11-01)"
```

En este caso, el resultado muestra que hemos instalado la versión 4.1.2 de R. Se puede obtener información adicional sobre la versión simplemente escribiendo **R.Version()**.

\newpage

# CAPÍTULO 2
\newpage

## [**OPERADORES EN R**](https://r-coder.com/operadores-r/)

![](operators-r.png)

Hay varios operadores en R. Esto incluye operadores aritméticos para cálculos matemáticos, operadores lógicos, relacionales o de asignación o incluso el popular operador pipe. En este capítulo se aprenderá y se conocerán algunos de los operadores básicos que ofrece R.

\newpage

## OPERADORES ARITMÉTICOS

Los operadores aritméticos de R nos permiten realizar **operaciones matemáticas**, como sumas, divisiones o multiplicaciones, entre otras. La siguiente es una tabla que resume todos los operadores aritméticos de R base:

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Operador = c("+",
             "-",
             "*",
             "/",
             "^",
             "**",
             "%%",
             "%/%",
             "%*%",
             "%o%",
             "%x%")
Descripción = c("Suma",
                "Resta",
                "Multiplicación",
                "División",
                "Exponencial",
                "Exponencial",
                "Módulo",
                "División entera",
                "Multiplicación matricial",
                "Producto exterior",
                "Producto Kronecker")
df = data.frame(Operador, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Operadores aritméticos en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```


En el siguiente bloque de código muestra ejemplos de operaciones aritméticas básicas con números enteros.

```{r eval=FALSE}
#---------------------#
# Operaciones básicas #
#---------------------#

3 + 5   
8 - 3   
7 * 5   
1/2     
4 ^ 4   
4 ** 4  
5 %% 3  
5 %/% 3 
```

```{r, eval=FALSE}
[1] 8
[1] 5
[1] 35
[1] 0.5
[1] 256
[1] 256
[1] 2
[1] 1
```


También se puede usar los operadores aritméticos con **vectores de R de la misma longitud**. La salida de estas operaciones será un vector con el resultado de la operación elemento a elemento.

```{r eval=FALSE}
#----------#
# Vectores #
#----------#

x = c(1, 7, 3)
y = c(9, 4, 5)

x + y   
x - y   
x * y   
x / 2   

# Cada elemento del primer vector elevado
# al elemento correspondiente del segundo
x ** y  # 1 2401  243 
x ^ y   # 1 2401  243

x %% y  
x %/% y 
```

```{r, eval=FALSE}
# Salida
[1] 10 11  8
[1] -8  3 -2
[1] 9 28 15
[1] 0.5 3.5 1.5
[1] 1 2401  243
[1] 1 2401  243
[1] 1 3 3
[1] 0 1 0
```

Asimismo, se puede usar los operadores aritméticos con matrices, además de los diseñados para este tipo de objeto (multiplicaciones matriciales).

```{r eval=FALSE}
#----------#
# Matrices #
#----------#

s = matrix(1:6, nrow = 2, ncol = 3)
t = matrix(8:13, nrow = 2, ncol = 3)

s
#      [, 1] [, 2] [, 3]
# [1, ]   1     3     5
# [2, ]   2     4     6

t
#      [, 1] [, 2] [, 3]
# [1, ]   8    10    12
# [2, ]   9    11    13


# Suma de matrices elemento a elemento

s + t

#      [, 1] [, 2] [, 3]
# [1, ]   9    13    17
# [2, ]  11    15    19


# Multiplicación de matrices elemento a elemento
s * t

#       [, 1] [, 2] [, 3]
# [1, ]    8   30   60
# [2, ]   18   44   78

# Ten en cuenta que se necesitan las dimensiones
# correctas para la multiplicación de matrices
w <- matrix(8:13, nrow = 2, ncol = 3)
z <- matrix(1:6, nrow = 3, ncol = 2)

w %*% z

#       [, 1] [, 2]
# [1, ]   64   154
# [2, ]   70   169

# Producto exterior
w %o% z # (Salida omitida)

# Producto Kronecker
w %x% z

#        [, 1] [, 2] [, 3] [, 4] [, 5] [, 6]
# [1, ]     8    32    10    40    12    48
# [2, ]    16    40    20    50    24    60
# [3, ]    24    48    30    60    36    72
# [4, ]     9    36    11    44    13    52
# [5, ]    18    45    22    55    26    65
# [6, ]    27    54    33    66    39    78
```

## OPERADORES BOOLEANOS EN R

Los operadores booleanos o lógicos en R se utilizan para especificar múltiples condiciones entre objetos. Estas comparaciones devuelven valores **TRUE** o **FALSE**.

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Operador = c("&",
             "&&",
             "$|$",
             "!",
             "xor()")
Descripción = c("Comparación lógica 'AND' (Y) elemento a elemento",
                "Comparación lógica 'AND' de vectores",
                "Comparación lógica 'OR' (O) elemento a elemento",
                "Negación lógica 'NOT' (NO)",
                "Exclusión 'OR' elemento a elemento equivalente a !(x|y)")

df = data.frame(Operador, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Operadores lógicos en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

```{r eval=FALSE}
40 & 5 > 30 # FALSE
40 | 5 > 30 # TRUE
!TRUE  # FALSE
!FALSE # TRUE

#----------#
# Vectores #
#----------#

x = c(3, 4, 5)
y = c(3, 5, 1)

x & y   # TRUE TRUE TRUE
x && y  # TRUE

x | y   # TRUE TRUE TRUE
x || y  # TRUE

!x # FALSE FALSE FALSE

xor(x, y) # FALSE FALSE FALSE
```


## OPERADORES RELACIONALES EN R

Los operadores de comparación o relacionales están diseñados para comparar objetos. El resultado de estas comparaciones son de tipo booleano. La siguiente tabla resume los operadores relacionales de R:

```{r}
Operador = c(">",
             "<",
             ">=",
             "<=",
             "==",
             "!=")
Descripción = c("Mayor que",
                "Menor que",
                "Mayor o igual que",
                "Menor o igual que",
                "Igual a",
                "Distinto a")

df = data.frame(Operador, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Operadores de relaciones en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

Se pueden comparar valores enteros con estos operadores de la siguiente maanera:

```{r eval=FALSE}
#---------------------#
# Operaciones básicas #
#---------------------#

3 > 5  # TRUE
3 < 5  # FALSE
3 >= 5 # FALSE
3 <= 5 # TRUE
3 == 5 # FALSE
3 != 5 # TRUE
```

Si comparas vectores, la salida será otro vector de la misma longitud y cada elemento contendrá el valor booleano correspondiente a la comparación de los elementos correspondientes (primer elemento del primer vector con el primer elemento del segundo vector, etc.). También se puede comparar cada elemento de una matriz con cada elemento de otra.

```{r eval=FALSE}
#----------#
# Vectores #
#----------#

x = c(12, 4 , 14)
y = c(3, 4, 15)

x >= y # TRUE TRUE FALSE
x <= y # FALSE TRUE TRUE
x == y # FALSE TRUE FALSE
x != y # TRUE FALSE  TRUE

#----------#
# Matrices #
#----------#

# La matriz debe tener la misma dimensión
# La comparación es elemento por elemento

s = matrix(1:6, nrow = 2, ncol = 3)
t = matrix(8:13, nrow = 2, ncol = 3)


s > t

#        [, 1]  [, 2]  [, 3]
# [1, ]  FALSE  FALSE  FALSE
# [2, ]  FALSE  FALSE  FALSE

s < t
s >= t
s <= t
s == t
```

Los operadores lógicos y los relacionales se utilizan por ejemplo para crear condicionales con la función **if()**. Se considera el simple ejemplo en el que se desea imprimir en pantalla el mensaje *"Correcto"* si dos valores (**x** e **y**) suman más de 20 o *"Incorrecto"* en caso contrario.

```{r eval=FALSE}
x = 11
y = 10

if(x + y > 30) {
    print("Correcto")
} else {
    print("Incorrecto")
}
```

Ya que **x + y > 20** devuelve un **FALSE**, el resultado es el código que se ejecuta en el **else**.

## OPERADORES DE ASIGNACIÓN

Los operadores de asignación en R **permiten asignar datos a un objeto** para almacenar los datos.[^ñ]

[^ñ]: Nótese que la mayoría de lenguajes de programación de comandos que puede usar el operador igual (**=**). Sin embargo, en R se recomienda usar la asignación de flecha (**<-**) y usar el signo ifual para establecer parámetros en los argumentos. En este manual, se usará constantemente el operador igual para lograr salir de la rutina de flecha.

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Operador = c("<-",
             "=",
             "->")
Descripción = c("Asignación izquierda",
                "Asignación izquierda y asignación de argumentos",
                "Asignación derecha")

df = data.frame(Operador, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Operadores de asignación en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

La flecha de asignación se puede usar como asignación izquierda o derecha, pero la asignación derecha no se usa generalmente.

En el siguiente bloque de código se encnotrará algunos ejemplos de estos operadores:[^ññ]

```{r eval=FALSE}
x <- 3
x = 26
rnorm(n = 10)

3 -> y
```

[^ññ]: Si se necesita utilizar la asignación derecha, hay que recordar que el objeto que se quiera almacenar debe estar a la izquierda o se producirá un error.

Debe tenerse en cuenta que **hay algunas reglas a la hora de nombrar variables**. Se pueden usar letras, números, puntos y guiones bajos en el nombre de la variable, pero los guiones bajos no pueden ser el primer caracter del nombre de la variable.

También hay palabras reservadas que no se pueden usar, como **TRUE**, **FALSE**, **NULL**, entre otras. Se Pueden ver en la lista completa de palabras reservadas escribiendo **help(Reserved)** o **?Reserved** en la consola de comandos.

Sin embargo, si por alguna razón necesitas nombrar una variable con una palabra reservada o comenzar con un guión bajo, tendrás que usar acentos graves (backticks):

```{r eval=FALSE}
_variable <- 3    # Error
`_variable` <- 3  # Funciona

TRUE <- 3   # Error
`TRUE` <- 3 # Funciona
```

## OPERADORES MISCELÁNEAS

Los operadores misceláneos en R son operadores **utilizados para propósitos específicos**, como acceder a datos, funciones, crear secuencias o especificar la fórmula de un modelo. La siguiente tabla contiene todos los operadores misceláneos disponibles en R.

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Operador = c("$",
             ":",
             "::",
             ":::",
             "~",
             "@")
Descripción = c("Subconjunto de un data frame o lista con nombres",
                "Generador de secuencias",
                "Acceso a funciones de paquetes (No suele ser necesario utilizarlo)",
                "Acceso a funciones internas de paquetes",
                "Formulación de modelo",
                "Acceso a slots en clase S4 (Avanzado)")
df = data.frame(Operador, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Operadores misceláneos en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

En el siguiente bloque de código mostramos varios ejemplos de estos operadores:

```{r eval=FALSE}
# Conjunto de datos
df = data.frame(x = c(7, 9, 2), y = c(5, 9, 5))

# Accedemos a la variable x
df$x

# Secuencia de 1 a 5
1:5

# Función rnorm del paquete stats
stats::rnorm(10)

# Fórmula modelo lineal
lm(df$x ~ df$y)
```

## OPERADOR INFIX

**Se puede llamar a un operador como una función**. Esto se conoce como operadores infix. El siguiente bloque de código se muestran algunos ejemplos de cómo usarlo. Hay que tener en cuenta que este tipo de operador es solo para fines educativos, ya que generalmente no se usa ni se necesita.

```{r eval=FALSE}
`+`(3, 2) # Equivalente a 3 + 2
`*`(5, 9) # Equivalente a 5 * 9
`>`(6, 1) # Equivalente a 6 > 1
```

```{r, eval=FALSE}
# Salida
`+`(3, 2) # Equivalente a 3 + 2
`*`(5, 9) # Equivalente a 5 * 9
`>`(6, 1) # Equivalente a 6 > 1
```

## OPERADOR PIPE EN R

El operador pipe o tubería es un operador que se puede encontrar en varias bibliotecas, como el paquete **dplyr**. El operador se puede leer como *“Y LUEGO”* y su propósito es simplificar la sintaxis al escribir código R. Como ejemplo, puedes crear un subconjunto de los datos **cars** y luego crear un resumen del subconjunto con el siguiente código:

```{r echo=TRUE, message=FALSE, warning=FALSE}
# install.packages("dplyr")
library(dplyr)

cars %>% 
   subset(speed > 20) %>% 
   summary()
```

\newpage

# CAPÍTULO 3

\newpage

## [**VECTORES EN R**](https://r-coder.com/vectores-r/)

![](vector-r.png)

¿Qué es un vector en R? Los vectores (también llamados vectores atómicos) **son la estructura de datos más básica en R**. Estas estructuras permiten **concatenar datos del mismo tipo**. Cabe destacar que existen varias formas de crear un vector en R, como utilizando secuencias, mediante generadores de datos aleatorios o uniendo dos o más vectores.

\newpage

## ¿QUÉ ES UN VECTOR EN R?

Un vector en R es un **conjunto de objetos del mismo tipo** concatenados con la función **c()**. Puedes crear vectores con componentes lógicos, de caracteres, numéricos o complejos, entre otros. Los diferentes términos del vector se denominan componentes. Es importante destacar que puedes verificar la clase de un vector con la función **class** y el tipo de elementos del mismo con la función **typeof**.

## ¿CÓMO CREAR UN VECTOR?

La forma más sencilla de crear un vector en R es usando la función **c**, que se utiliza para la **concatenación de objetos**. Puedes guardar en memoria el vector asignándole un nombre con el operador **=**.

```{r eval=FALSE}
# Creando vectores en R con la función 'c'
x = c(12, 6, 67)
y = c(2, 13)
y
```

```{r, eval=FALSE}
# Salida
[1]  2 13
```

Los vectores también pueden ser no numéricos. Por lo tanto, puedes crear vectores con caracteres, objetos lógicos u otros tipos de objetos de datos, como ya se comentó en la introducción.

```{r eval=FALSE}
caracteres = c("Guanajuato", "Sinaloa",
               "Tamaulipas", "Oaxaca")
class(caracteres)

logico = c(TRUE, TRUE, FALSE, TRUE)
class(logico)
```

```{r eval=FALSE}
# Salida
[1] "character"
[1] "logical"
```

Sin embargo, si se **mezclan distintos tipos de datos** dentro de un vector **los componentes se transformarán** en elementos del mismo tipo. A esto se le llama coerción de tipos de datos.

```{r eval=FALSE}
mezcla = c(TRUE, "Correcto", 8, 2.2)
mezcla # "TRUE" "Correcto"  "8"  "2.2"

class(mezcla)  # "character"
typeof(mezcla) # "character"
```

## NOMBRAR VECTORES EN R

También se pueden nombrar los elementos de los vectores. Para ese propósito, simplemente elige un nombre para cada componente o solo para algunos de ellos.

```{r eval=FALSE}
mi_vector = c(naranja = 4, manzana = 6)
mi_vector
```

Si ya se ha creado el vector, se puede usar la función **setNames()** de la siguiente manera para poner nombre a los componentes:

```{r eval=FALSE}
setNames(y, c("naranja", "manzana"))
y
```

## ORDENANDO VECTORES

### LA FUNCIÓN **sort()**

Para **ordenar un vector**, se puede llamar a la función **sort()** pasando como argumento el vector. Por defecto, la función ordena de forma ascendente.

```{r eval=FALSE}
z = c(13, 18, 4, 27)
sort(z)
```
También se pueden ordenar los datos en orden decreciente estableciendo el argumento **decreasing** como **TURE**:

```{r eval=FALSE}
sort(z, decreasing = TRUE)
```

### LA FUNCIÓN **order()**

Alternativamente, se puede usar corchetes y ordenar los componentes del vector como un índice haciendo uso de la función **order()** como sigue:

```{r eval=FALSE}
# Orden creciente
z[order(z)]  # Equivalente a sort(z)

# Orden decreciente
z[order(-z)] # Equivalente a sort(z, decreasing = TRUE)
```

### INVERTIR EL ORDEN DE UN VECTOR

Además, se puede invertir el orden de un vector utilizando la función **rev()**.[^i]

[^i]: Si solo se necesita cambiar el orden de un vector es más eficiente usar la función **sort()**.

```{r eval=FALSE}
# Invirtiendo el orden de un vector
rev(z)
```

## CONCATENAR VECTORES

Unir dos o más vectores es tan fácil como crear uno. De hecho, solo se necesita llamar a la función **c()** y pasar los vectores como argumentos para concatenar un vector a otro.

```{r}
x = c(1, 2, 3)
y = c(4, 5, 6)
c(x, y)
```

Es necesario destacar que el orden de los elementos es relevante. Los vectores se concatenarán según el orden de entrada:

```{r}
c(y, x)
```

## CREAR UN VECTOR VACÍO EN R

En ocasiones es necesario inicializar un vector vacío en R y llenarlo dentro de un bucle **for()**. Con tal objetivo puedes utilizar la función **c()** sin especificar ningún argumento para crear la estructura vacía. Si es de preferencia también se puede usar la función **vector()**:[^loll]

[^loll]: Si se quiere llenar un vector vacío, es más eficiente **preasignar memoria** creando un vector (por ejemplo con valores ***NA***) de la logitud del vector final, o usando la función **vector()**.

```{r eval=FALSE}
# Vector vacío
mi_vector = c()

# Llenando el vector con un bucle
for(i in 1:10) {
  mi_vector[i] = i
}

mi_vector
```

```{r eval=FALSE}
# Salida
[1]  1  2  3  4  5  6  7  8  9 10
```

```{r}
# Preasignamos memoria
my_vector <- rep(NA, 5)
my_vector <- vector(length = 5)

# Llenamos el vector mediante un bucle for
for(i in 1:5) {
  my_vector[i] <- i
}
```

## COMPARANDO DOS VECTORES

Existen varias formas de comparar vectores en R. Por una parte podemos comparar los elementos uno a uno con algún operador lógico. Ten en cuenta que si un vector es mayor que otro el número de elementos tienen que ser múltiplos entre ellos o surgirá un error.

```{r eval=FALSE}
x <- c(1, 5)
y <- c(4, 0)
x > y # FALSE TRUE

x <- c(1, 5)
y <- c(4, 0, 1, 3)

# Esto compara 1 > 4, 5 > 0, 1 > 1 y 5 > 3
x > y # FALSE TRUE FALSE TRUE

x <- c(1, 5, 1)
y <- c(4, 0, 1, 3)
x > y # Error
```

También se puede comprobar si los elementos del primer vector están contenidos en el segundo von **%in%**.

```{r eval=FALSE}
x %in% y # TRUE FALSE TRUE
```

Otra opción es devolver los elementos comunes entre el primer vector y el segundo:

```{r eval=FALSE}
# Devolvemos los elementos comunes
x[x %in% y] # 1 1
```

Por último podríamos comparar si todos los elementos del primer vector están en el segundo con la función **all()** de la siguiente manera:

```{r eval=FALSE}
x = c(1, 5)
y = c(4, 5, 1, 3)

all(x %in% y) # TRUE
```

## SECUENCIA DE NÚMEROS EN R

En R se pueden crear secuencias de números de distintas maneras. Entre ellas, puede utilizarse el operador **:** o las funciones **seq()** o **rep()**.

```{r eval=FALSE}
# Secuencia de 1 a 4 con números enteros
1:4
# 1 2 3 4

# Sequencia de 1 a 4 con pasos de 0.5
seq(1, 4, 0.5)
# 1.0 1.5 2.0 2.5 3.0 3.5 4.0

# Sequencia de tamaño 9 desde 1 hasta 5
seq(from = 1, to = 5, length.out = 9)
# 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0

# Repite el numero uno cinco veces
rep(1, 5)
# 1 1 1 1 1
```

## VECTOR ALEATORIO

En R hay varias funciones para lidiar con la generación de números aleatorios. La función **sample()** permite crear secuencias aleatorias.[^kas]

[^kas]: El **argumento replace** indica si el lanzamiento es con o sin reemplazo. Esto significa que si establecemos **replace = FALSE** y obtenemos un 5 en el primer lanzamiento, en el siguiente lanzamiento solo podemos obtener un 1, 2, 3, 4 o un 6.

```{r eval=FALSE}
# Vector con secuencias aleatorias
sample(1:6, size = 5, replace = TRUE) 
```

También se puede utilizar las funciones **runif()** o **rnorm()**, que generan secuencias aleatorias de números a través de las distribuciones Uniforme y Normal, respectivamente.[^poook]

[^poook]^: **Nota sobre la generación de números aleatorios**. Al generar números aleatorios, **se obtendrán valores diferentes cada vez** que se ejecute el comando, por lo que sus resultados anteriores serán diferentes a los nuestros. Para configurar la semilla del generador de números aleatorios de R para hacer un ejemplo reproducible, primero se debe llamar a la función **set.seed** y establecer la semilla inicial.

```{r eval=FALSE}
# Valores uniformes
runif(55, min = 2, max = 10)

# Valores normales
rnorm(55, mean = 0, sd = 1)
```

Al generar números aleatorios, **se obtendrán diferentes valores cada vez** que se ejecute el comando, por lo que los resultados anteriores serán diferentes a los nuestros. Para configurar la semilla del generador de números aleatorios de R para hacer un ejemplo reproducible, primero se debe de llamar a la función **set.seed()** y establecer la semilla inicial.

```{r eval=FALSE}
set.seed(1) # Se puede elegir cualquier otro número entero como semilla

# Valores normales
rnorm(5, mean = 0, sd = 1)

# Valores uniformes
runif(5, min = 2, max = 10)
```

## CONTAR ELEMENTOS DE UN VECTOR EN R

Se puede obtener la longitud de determinado vector con la función **length()**. La longitud de un vector es el número de componentes o la cantidad de datos dentro del mismo.

```{r}
mis_datos = c("vector", "secuencia", "rnorm", "runif")

n = length(mis_datos)

# Longitud del vector
n # 4
```

## ACCEDER A ELEMENTOS DE UN VECTOR

El acceder a elementos de un vector permite acceder a **elementos únicos**, como el primero o último valor, obtener un subconjunto del vector, así como reemplazar, cambiar o eliminar algunos elementos. Esto se puede realizar mediante índices numéricos o lógicos.

### ÍNDICE NUMÉRICO PARA ACCEDER A ELEMENTOS

Para acceder a los elementos de un vector, se puede **indicar entre corchetes el subíndice del elemento o elementos del vector correspondiente** (entero positivo).[^123]

[^123]: Cuando se acceda a posiciones "negativas", se entiende que se desea acceder a todas las posiciones excepto las indicadas con el signo menos.

Se considera las letras dadas por la función **letters** dentro de R.

```{r eval=FALSE}
letras = letters
letras
```

```{r include=FALSE}
letras = letters
letras
```

```{r eval=FALSE}
# Salida
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m"
[14] "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z"
```

En el siguiente bloque de código se dan algunos ejemplos para acceder a diferentes datos.

```{r eval=FALSE}
# Primer elemento
letras[1]

# Primer elemento, simplificando la clase de salida
letras[[1]]

# Tercer y cuarto elemento
letras[c(3, 4)]

# Letras 'pares'
letras[seq(2, n, 2)]

# Letras 'impares'
letras[seq(1, n, 2)]
letras[-seq(2, n, 2)] # Equivalente
```

```{r include=FALSE}
# Primer elemento
letras[1]

# Primer elemento, simplificando la clase de salida
letras[[1]]

# Tercer y cuarto elemento
letras[c(3, 4)]

# Letras 'pares'
letras[seq(2, n, 2)]

# Letras 'impares'
letras[seq(1, n, 2)]
letras[-seq(2, n, 2)] # Equivalente
```

## AGREGAR VALORES A VECTORES EN R

Ahora se agregará la letra* *"ñ"* al vector de letras que se creó anteriormente. En primer lugar, necesitamos encontrar la letra anterior (o la siguiente) en el alfabeto. En este caso buscaremos la letra ‘n’ y colocaremos la *"ñ"* justo después. Podemos hacer uso de la función **which()** para buscar el índice del elemento correspondiente a la letra *"n"*.

```{r eval=FALSE}
# Buscando el índice
n1 = which(letras == "n")
n1 # 14
```
```{r include=FALSE}
# Buscando el índice
n1 = which(letras == "n")
n1 # 14
```

Con una sola línea de código se puede concatenar los carácteres.

```{r eval=FALSE}
c(letras[1:n1], "ñ", letras[-(1:n1)])
```

```{r include=FALSE}
c(letras[1:n1], "ñ", letras[-(1:n1)])
```

En caso de que se desee agregar el elemento al principio o al final del vector, simplemente se usa la función **c()** en el orden correspondiente.

```{r}
# Añadiendo la letra "ñ" al principio del vector
c("ñ", letras)

# Añadiendo la letra "ñ" al final del vector
c(letras, "ñ")
```

## ¿CÓMO BORRAR UN VECTOR EN R?

Se puede eliminar un vector en R con la función **rm()** o **remove()**, o simplemente agregándole otro valor, como **NULL**.

```{r}
mi_vector <- c(1, 2, 5, 6, 7)

# Con la función rm
rm(mi_vector)

# Sobrescribiendo el vector con otro valor
mi_vector = 0

# Asignando NULL
mi_vector = NULL
```

## BORRAR ELEMENTO DE UN VECTOR

Si se desea eliminar sólo algunos valores específicos de un vector, puedes usar el signo **-** e indicar los índices del vector que no quieres conservar. Veamos algunos ejemplos:

```{r eval=FALSE}
vector = c("The Office", "Broklyn 99", "Modern Family")

# Eliminando "The Office"
vector[-1] # "Broklyn 99" "Modern Family"
vector[which(vector != "The Office")]  # Equivalente
vector[-which(vector == "The Office")] # Equivalente
```

```{r eval=FALSE}
# Salida
[1] "Broklyn 99"    "Modern Family"
```

\newpage

# CAPÍTULO 4

\newpage

## [**MATRICES EN R**](https://r-coder.com/matrices-r/)

![](matrix-r.png)

Una matriz en R es una estructura de datos para **almacenar objetos del mismo tipo**. Si se desea almacenar diferentes objetos dentr de una estructura de datos en R, se usa un data frame en su lugar.[^poiu]

[^poiu]: La matrices parten del **Álgebra lineal**, siendo la rama de las matemáticas que se dedica al estudio de elementos como matrices, vectores, espacios vectoriales y sistemas de ecuaciones lineales. El álgebra lineal es una de las áreas de mayor complejidad del álgebra y suele ser del ámbito de estudio y aplicación principalmente de la ingeniería y la informática.

\newpage

## ¿CÓMO CREAR UNA MATRÍZ EN R?

La función **matrix()** permite una matriz en RStudio o R base, pasando como input un vector numérico, de carácteres o lógico.

```{r}
datos = 1:6

# Creando la matriz
matrix(datos)
```

Como se puede apreciar en la salida, por defecto se creará una matriz de una columna y tantas filas como la longitud del vector. Sin embargo, es posible **establecer el número de columnas o el número de filas** con los argumentos **ncol** y **nrow**, respectivamente. También puedes especificar si la matriz está ordenada por filas o por columnas con el argumento **byrow**. **Por defecto**, la función ordenará la entrada **por columnas** (**byrow = FALSE**).

```{r eval=FALSE}
# Por columnas
matrix(datos, ncol = 2, byrow = FALSE) # byrow = FALSE por defecto
matrix(datos, ncol = 2, nrow = 3) # Equivalente
matrix(datos, nrow = 3) # Equivalente
```

```{r eval=FALSE}
# Salida
     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6
```

```{r eval=FALSE}
# Por filas
matrix(datos, ncol = 2, byrow = TRUE)
```

```{r eval=FALSE}
# Salida
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
```

Ahora, bien, si se tienen datos almacenados en vectores o en las columnas de un data frame, se puede usar **cbind()** para concatenar columnas o **rbind()** para concatenar filas, siendo el output una matriz. La clase de la salida se puede comprobar con la función **class()** y la clase de los elementos con la función **typeof()**.

```{r}
x = c(2, 7, 3, 6, 1)
y = c(3, 7, 3, 5, 9)

# Por columnas
cbind(x, y)

# Por filas
rbind(x, y)

# Clase de la salida
class(cbind(x, y))  # "matrix"

# Tipo de dato de los elementos
typeof(cbind(x, y)) # "double"
```

Debe de tenerse en cuenta que se puede usar **cualquier tipo de datos dentro de una matriz**, siempre que sean **homogéneos**.

```{r}
matrix(c(TRUE, TRUE, FALSE, TRUE), ncol = 2)
matrix(c("verde", "rojo", "azul", "amarillo"), ncol = 2)
```

Además, se puede conocer las dimensiones de la matriz con la función **dim()**.

```{r eval=FALSE}
matriz = matrix(1:12, ncol = 2, byrow = FALSE)

# Dimensiones de la matriz
dim(matriz) # 6 2
```

El primer número de la salida de la función **dim()** indica el número de filas (6) y el segundo el número de columnas (2). Hay que tener en cuenta que la función **dim()** también se puede utilizar para crear una matriz en R.

```{r}
A = c(3, 1, 6, 1, 3, 9)
dim(A) = c(3, 2)
```

A modo esquemático, la siguiente tabla muestra las **funciones más comunes relacionadas con matrices**:

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Operador = c("dim(), nrow(), ncol()",
             "diag()",
             "*",
             "%*%",
             "%o%",
             "%x%",
             "cbind(), rbind()",
             "t()",
             "solve(A)",
             "solve(A, b)",
             "eigen()",
             "qr()",
             "chol()",
             "svd()")
Descripción = c("Número de filas/ columnas",
                "Diagonal de una matriz",
                "Multiplicación elemento a elemento",
                "Producto matricial",
                "Producto exterior",
                "Producto de Kronecker",
                "Agregar filas/ columnas",
                "Matriz transpuesta",
                "Inversa de la matriz A",
                "Solución a Ax = b",
                "Autovalores y autovectores",
                "Descomposición QR",
                "Descomposición de Cholesky",
                "Descomposición singular")
df = data.frame(Operador, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Operadores de matrices en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

## AÑADIR Y ELIMINAR COLUMNAS DE MATRICES EN R

Como mostramos antes, la función **cbind()** puede usarse para crear una matriz. Sin embargo, el uso principal de la función es **agregar columnas a las estructuras de datos**. Para eliminar columnas, se utiliza el operador **-** **indicando el índice de la columna en el segundo argumento** entre corchetes, como en el ejemplo que se muestra a continuación:

```{r}
# Añadir columna
A = cbind(A, c(6, 1, 7))
A

# Añadir dos columnas
A = cbind(A, c(6, 1, 7), c(1, 6, 1))
A

# Eliminar la primera columna
A = A[, -1]
A

# Borrar la primera y la tercera columna
A = A[, -c(1, 3)]
A
```

## AÑADIR Y ELIMINAR FILAS A UNA MATRIZ EN R

Equivalentemente a la función anterior, la función **rbind()** se puede usar para **agregar filas** a objetos. También se puede eliminar filas de la misma manera que antes, pero indicando el índice en el primer argumento entre corchetes.

```{r}
# Agregar fila
A = rbind(A, c(6, 1))

# Agregar fila de sietes
A = rbind(A, 7)

# Eliminar la segunda fila
A = A[-2, ]
```

## APILAR MATRICES EN R

La función **rbind()** también se puede utilizar para apilar o combinar matrices:

```{r}
x = matrix(c(2, 7, 1, 3, 6, 1), ncol = 2, byrow = TRUE)
y = matrix(c(3, 7, 6, 3, 5, 9), ncol = 2, byrow = TRUE)

# Apilando las matrices
rbind(x, y)
```

Además, si crear una lista de matrices en R y no conoces de antemano la longitud final que tendrá la lista, se puede usar la función **do.call()** de la siguiente manera para unir las matrices:

```{r}
lista_matriz = list(x, y)
lista_matriz
```

```{r eval=FALSE}
# Equivalencia
do.call(rbind, lista_matriz)
rbind(lista_matriz[[1]], lista_matriz[[2]])
```

```{r eval=FALSE}
# Salida
     [,1] [,2] [,3] [,4] [,5]
[1,]    2    7    3    6    1
[2,]    3    7    3    5    9
```

El código anterior devolverá la misma salida que **rbind(x, y)**, la diferencia es que con **do.call()** no necesitamos saber el número de matrices que se apilarán. Si la lista contiene más matrices en su interior, la función seguirá funcionando.

## AÑADIR NOMBRES A LAS FILAS Y A LAS COLUMNAS

Se puede **cambiar los nombres de las filas y columnas de una matriz** con las funciones **rownames()** y **colnames()**:

```{r}
B = matrix(c(7, 5, 6, 10, 8, 3),
             nrow = 2, ncol = 3, byrow = TRUE)

# Agregar nombres a las filas
rownames(B) = c("Fila 1", "Fila 2")
rownames(B) = paste0("Fila ", 1:nrow(B)) # Equivalente

# Agregar nombres a las columnas
colnames(B) = c("Columna 1", "Columna 2", "Columna 3")
colnames(B) = paste0("Columna ", 1:ncol(B)) # Equivalente
B
```

Nótese que se puede **renombrar las columnas y filas** de la matriz de la misma manera. Además, con la función **atributees()** se puede **acceder a la dimensión y los nombres de columna y fila** de una matriz.

```{r eval=FALSE}
attributes(B)
```

```{r eval=FALSE}
$dim
[1] 2 3

$dimnames
$dimnames[[1]]
[1] "Fila 1" "Fila 2"

$dimnames[[2]]
[1] "Columna 1" "Columna 2" "Columna 3"
```

Si solo se desea devolver los **nombres de columna y fila**, se puede utilizar la función **dimnames()** y acceder a los elementos de la lista para tener los nombres de las filas o de las columnas.

```{r eval=FALSE}
dimnames(B)
```

```{r eval=FALSE}
[[1]]
[1] "Fila 1" "Fila 2"

[[2]]
[1] "Columna 1" "Columna 2" "Columna 3"
```

## ELIMINAR NOMBRES DE LAS FILAS Y LAS COLUMNAS DE LAS MATRICES

En caso de que se esté trabajando con una matriz con nombres y se desee deshacer de ellos, simplemente se puede **eliminar los nombres de las filas o columnas** asignándoles el valor **NUL** o usando la función **unname()** para borrar todos los nombres.

```{r}
# Borrar nombres de las columnas
colnames(B) = NULL

# Borrar nombres de las filas
rownames(B) = NULL

# Eliminar nombres de 
# filas y columnas a la vez
unname(B)
```

## ACCEDER A LOS ELEMENTOS DE UNA MATRIZ EN R

Acceder a los elementos de una matriz es similar a acceder a los elementos de un data frame en R. La principal manera para acceder a los datos es usar **matriz[filas, columnas]**. Sin embargo, existen ciertas diferencias entre las estructuras de datos.

```{r}
matriz = matrix(c(2, 5, 8, 1, 3, 5), ncol = 3)
matriz
```

```{r eval=FALSE}
# Primer elemento de la primera columna
matriz[1]    # 2
matriz[[1]]  # Equivalente
matriz[1, 1] # Equivalente
```

```{r eval=FALSE}
# Salida
[1] 2
```

```{r}
# Segunda fila, tercera columna
matriz[2, 3] # 5

# Primera fila
matriz[1, ] # 2 8 3

# Segunda columna
matriz[, 2] # 8 1

# Primera y segunda columna, primera fila
matriz[1, 1:2] # 2 8
```


```{r eval=FALSE}
# Primera y tercera columna, segunda fila
matriz[2, c(1, 3)] # 5 5
matriz[2, c(TRUE, FALSE, TRUE)] # Equivalente
```

```{r eval=FALSE}
[1] 5 5
```

```{r}
# Todas las columnas excepto la segunda
matriz[, -2]

# Última fila de la matriz
matriz[nrow(matriz), ] # 5 1 5

# Última columna de la matriz
matriz[, ncol(matriz)] # 3 5
```

Hay que tener en cuenta **al devolver filas o columnas individuales, la soalida será un vector**. Si se desea evitar eso, se establece **drop = FALSE**.[^ñoñ]

```{r}
matriz[1, , drop = FALSE]
```

[^ñoñ]: Dejamos en blanco el segundo argumento porque estamos seleccionando todas las columnas.

Se deja en blanco el segundo argumento porque se está seleccionando todas las columnas. Además, si la matriz tiene nombres, se puede **acceder a los elementos indexándolos con los nombres**.

```{r}
C = matrix(c(5, 3, 2, 52, 34, 12), 
            nrow = 2, ncol = 3, byrow = TRUE)

rownames(C) = c("Fila 1", "Fila 2")
colnames(C) = c("Columna 1", "Columna 2", "Columna 3")

# Primera fila, columnas 1 y 3
C["Fila 1", c("Columna 1", "Columna 3")]
```

## ELIMINAR VALORES NA, NaN E Inf DE UNA MATRIZ

En ocasiones se tendrá que lidiar con valores perdidos u omitidos. Existen diferentes tipos como los valores **NA** (no disponible), **NaN** (no es número) e **Inf** (infinito). Hay que tener en cuenta que se puede eliminar las filas o columnas que contienen estos valores o reemplazarlos con otros valores. Se considera la siguiente matriz:

```{r eval=FALSE}
# Matriz con valores omitidos
C = matrix(c(14, NaN, 3, Inf, -5, 4, 1, NA), ncol = 4)
C
```

```{r eval=FALSE}
     [,1] [,2] [,3] [,4]
[1,]   14    3   -5    1
[2,]  NaN  Inf    4   NA
```

Se pueden eliminar las filas o las columnas con valores no finitos con las funciones **rowSums()** o **colSums()** e **is.finite()**.

```{r}
# Borrar todas las filas con valores no finitos
C[!rowSums(!is.finite(C)), ] # 14  3 -5  1

# Borrar todas las columnas con valores no finitos
C[, !colSums(!is.finite(C)), drop = FALSE] # -5, 4
```

En caso de que se desee reemplazar los valores, se puede detectar los valores no finitos usando la función **!is.finite()** y los valores **NA** con la función **is.na()** y luego asignar los valores que se deseen eliminar. En este caso se va a eliminar y se reemplazarán con 0.

```{r}
# Reemplazar los NA y NaN con 0
C[is.na(C)] = 0
C

# Reemplazar los valores no finitos con 0
C[!is.finite(C)] = 0
C
```

\newpage

# CAPÍTULO 5

\newpage

## [**DATA FRAME EN R**](https://r-coder.com/data-frame-en-r/)

![](data-frame-r.png)

En esta sección se aprenderá la estructura de datos de R. Al final, se comprenderán los conceptos básicos para trabajar con un data frame en R, tales como acceder a los datos, añadir nuevas filas o columnas, así como filtrar o crear subconjuntos de los datos.

\newpage

## ¿QUÉ ES UN DATA FRAME EN R?

Los  data frame (marco de  datos o conjunto de datos) son **el objeto más habitual para almacenar datos en R**. En este tipo de objeto,  cada individuo o fecha corresponde a una fila y cada columna corresponde a una variable. Dentro de este tipo de estructura puedes almacenar diferentes tipos de datos.

### ¿DATA FRAME O MATRIZ?

Una cuestión habitual es preguntarse en qué casos se deben usar un data frame o una matriz en R. Los data frames son estructuras de datos muy similares a las matrices, pero en el caso de los data frames puedes tener diferentes tipos de datos dentro de las columnas. En consecuencia, la diferencia es que **las matrices almacenan tipos de datos homogéneos** mientras que los **data frames almacenan tipos de datos heterogéneos**. Como ejemplo, se supone que se tienen los siguientes datos:

```{r}
Producto = c("Zumo", "Queso", "Yogurt")
Seccion = c("Bebidas", "Productos lácteos", "Productos lácteos")
Unidades = c(2, 1, 10)
```

Se pueden almacenar esas variables como matriz utilizando la función **cbind()**:

```{r}
x = cbind(Producto, Seccion, Unidades)

# Imprimir la variable x
print(x)
```

Sin embargo, se puede notar que el resultado no es satisfactorio, ya que todas las variables se han transformado a la clase de **carácter**. En cambio, si se usa la función **data.frame()**, se mantendrá el tipo original de las variables. Los data frames, a diferencia de las matrices, pueden almacenar diferentes tipos de objetos.[top]

[^top]: Los data frames, a diferencia de las matrices, pueden almacenar diferentes tipos de objetos.

## ¿CÓMO CREAR UN DATA FRAME EN R?

En R **es muy sencillo crear un nuevo data frame**. Se pueden unir las variables haciendo uso de la función **data.frame()** para convertir los datos a la estructura de datos de tipo data frame. Primero, se necesita tener algunas variables almacenadas para crear el marco de datos en R. Hay que tener en cuenta que todos los vectores deben de tener la misma longitud:

```{r}
Temperatura = c(20.37, 18.56, 18.4, 21.96, 29.53, 28.16,
          36.38, 36.62, 40.03, 27.59, 22.15, 19.85)
Humedad = c(88, 86, 81, 79, 80, 78,
             71, 69, 78, 82, 85, 83)
Precipitaciones = c(72, 33.9, 37.5, 36.6, 31.0, 16.6,
                     1.2, 6.8, 36.8, 30.8, 38.5, 22.7)
Mes = c("enero", "febrero", "marzo", "abril", "mayo", "junio",
         "julio", "agosto", "septiembre", "octubre", "noviembre",
        "diciembre")
```

Para unir los datos se puede usar la función **data.frame()**. En este ejemplo, se va a almacenar el data frame en una variable llamada **datos**:

```{r}
datos = data.frame(Mes, Temperatura,
                   Humedad, Precipitaciones)

names(datos) # Nombres de las variables (columnas)
```

Primero, es habitual **mostrar los primeros valores** para hacer algunas comprobaciones. Para ello, se puede hacer uso de la función **head()** en R, que por defecto motrará las primeras 6 filas del data frame.

```{r}
# Primeras filas de nuestro conjunto de datos
head(datos)
```

En segundo lugar, se puede utilizar la función **summary()** que devolverá un **resumen estadístico de las variables** (columnas) del conjunto de datos.

```{r}
summary(datos)
```

También se puede hacer uso de los **data frames de ejemplo que R proporciona**. Para buscarlos, se puede llamar a la función **data()**:

```{r eval=FALSE}
data()
```

Una vez ejecutado, se abrirá una ventana con una lista de conjunto de datos disponibles. Ahora solamente queda cargar el que se dese con:

```{r eval=FALSE}
data(nombre_del_conjunto_de_datos)
```

Como ejemplo, si se desea cargar el conjunto de datos **AirPassengers** en el espacio de trabajo, se puede escribir lo siguiente:

```{r}
data("AirPassengers")
```

### CREAR UN DATA FRAME VACÍO EN R

En ocasiones puede resultar interesante **inicializar un data frame vacío** y rellenarlo dentro de un buble o añadir las filas mediante algún procedimiento. En este caso, la forma más recomendada de crear una estructura de datos vacía es utilizando la función **data.frame()** y creando variables vacías. Sin embargo, en el siguiente bloque de código, se mostrará esta manera y varias alternativas más:

```{r}
# Variables vacías
dataset = data.frame(mes = character(),
                      temperatura = numeric(),
                      precipitaciones = numeric(),
                      humedad = numeric())

# Copiando la estructura de otro conjunto de datos
dataset = datos[FALSE, ] # Recuerda que creamos el objeto "datos" antes

# Convirtiendo una matriz en data.frame y asignándole nombres a las columnas
dataset = data.frame(matrix(ncol = 4, nrow = 0))
nombres_columnas = c("mes", "temperatura", "precipitaciones", "humedad")
colnames(dataset) = nombres_columnas

# Equivalente a la última opción
dataset = data.frame(matrix(ncol = 4, nrow = 0,
                      dimnames = list(NULL, c("mes", "temperatura",
                                              "precipitaciones", "humedad"))))
```

## ACCEDIENDO A LOS DATOS DEL DATA FRAME

Hay varias formas de acceder a las columnas almacenadas en los data frames:

1. Usando el **signo de dólar** ($) y el nombre de la columna.
2. Usando **corchetes con el índice** de la columna después de una coma.

Como ejemplo, si se quiere seleccionar la columna **mes** del data frame que se ha creado antes, se ejecuta lo siguiente:

```{r eval=FALSE}
datos$Mes
datos[, 1] # Equivalencia
```

También se puede **seleccionar varias variables a la vez**. Para ello se puede:

1. Crear una secuencia de índices.
2. Crear un vector con la función **c()** con los nombres de las variables o índices que se quieran seleccionar.

```{r eval=FALSE}
# Seleccionando las columnas 1 a 3 con una secuencia
datos[, 1:3]

# Seleccionando columnas con la función 'c'
datos[, c("Temperatura", "Precipitaciones")]
datos[, c(2, 4)] # Equivalente
```

Del mismo modo, se puede acceder a las filas del data frame con **datos[1, ]** o **datos[1:2, ]** para seleccionar la primera fila o la primera y la segunda, correspondientemente, o seleccionar sólo algunos puntos de datos seleccionando filas y columnas a la vez:

```{r}
# Observación de la primera
# fila y segunda columna
datos[1, 2]

# Primera y segunda fila
# de la segunda columna
datos[1:2, 2]
```

### ACCESO DIRECTO UTILIZANDO LA FUNCIÓN **attach()**

**Si no se desea escribir el nombre del data frame una y otra vez**, simplemente se puede hacer uso directo de las variables si se pasa el nombre del data frame a la función **attach()**:

```{r eval=FALSE}
attach(datos)
Temperatura # Se tiene acceso directo a todas las variables
```

Si se desea **deshabilitar el acceso directo**, solamente se usa la función **detach()**:

```{r eval=FALSE}
detach(datos)
```

## AÑADIR COLUMNAS Y FILAS A UN DATA FRAME

A veces se necesita modificar los datos para **agregar nuevas filas o columnas, o eliminarlas**. Para los siguientes ejemplos, se utilizará el conjunto de datos **cars**, registrado en la década de 1920, que forma parte de los conjuntos de datos de ejemplo de R. Puede cargarse ejecutando **data(cars)**. La base de datos contiene 50 filas y 2 variables:

* speed: velocidad (mph)
* dist: distancia de frenando (ft)

Si se ejecuta **head(cars)** se obtendrá el siguiente resultado:

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
head(cars)
```

Supongamos que se desea aregar una nueva variable para transformar la velocidad en kilómetros por hora (hk/h) y la distancia en metros. Hay que recordar que la equivalencia sería:

$$kilómetro = milla/0.62137$$ y $$metro = pie/3.2808$$

Entonces, ahora se podría **agregar dos nuevas columnas** llamadas **kph** (kilómetros por hora) y **meters** (metros) con el siguiente código:

```{r}
# Meter las variables directamente al data frame
cars$kph = cars$speed / 0.62137
cars$meters = cars$dist / 3.2808

# Se visualiza el data frame
head(cars)
```

También se puede hacer uso de la función **cbind()**. En caso de que se desee agregar una nueva fila, se puede usar la función **rbind()**.[^topp]

```{r}
# Se crean las variables
kph = cars$speed / 0.62137
meters = cars$dist / 3.2808

# Se meten las variables dentro del data frame
cars = cbind(cars[, c(1, 2)], kph, meters)

# Se visualiza el data frame
head(cars)
```

[^topp]: Agregar nuevas filas con la función **rbind()** y nuevas columnas con la función **cbind()**.

## ELIMINAR COLUMNAS Y FILAS DE UN DATA FRAME

Ahora, si lo que se quiere es **borrar variables o filas** de un data frame, se tienen varias opciones:

1. Usar el signo menos (-) e indicar las columnas o filas que se quiera borrar.
2. Crear un subconjunto de los datos que se quieran conservar.


Como ejemplo, se borrará las variables **speed** y **disty** para **evitar sobrescribir el conjunto de datos original** guardaremos nuestros resultados en un nuevo data frame llamado **cars2**.

```{r}
# Borrando la primera y segunda columna con el signo -
cars2 = cars[, -c(1, 2)]

# Seleccionar solo las columnas que queremos conservar
cars2 = cars[, c("kph", "meters")] 
```

Si se vuelve a utilizar la función **head()**, se podrá ver el nuevo data frame.

```{r}
head(cars2)
```

## ORDENADO Y FILTRADO DE UN DATA FRAME EN R

Es habitual **ordenar o filtrar los datos** dentro de los data frame por los valores de alguna variable.

### ORDENAR DATA FRAMES

Se considera, como ilustración, el conjjunto de datos **mtcars** y cargarlos ejecutándolo como **data(mtcars)**. Podemos acceder al índice de ordenación en cualquier variable con la función **order()**.

```{r}
ii  = order(mtcars$hp)  # índice de orientación en base a la
                        # vaariable "hp"
                        # (caballos de fuerza)
```

El vector de índices de ordenación establece el orde en que tiene que ser elegidas las filas del data frame para obtener la ordenación deseada.

```{r}
# Ordenando por "hp" (del más bajo al más alto)
# Sólo observaremos las primeras 4 columnas
head(mtcars[ii, 1:4])
```

También se puede  ordenar de mayor a menor haciendo el uso del signo menos.

```{r}
ii = order(-mtcars$hp)
head(mtcars[11, 1:4])
```

Además, se pueden **establecer diferentes condiciones para ordenar los datos**. Se pueden ordenar por alguna variable y, en caso de empate, ordenar por otra. En el siguiente ejemplo ordenaremos el data frame por la variable llamada **cyl** y luego por la variable **hp**.

```{r}
ii = order(mtcars$cyl, mtcars$hp)
head(mtcars[ii, 1:4])
```

### FILTRAR DATA FRAMES

Filtrar un data frame consiste en **obtener una submuestra que cumpla con algunas condiciones**. Para este propósito, se puede usar la función **subset()** para crear subconjuntos según los valores de alguna columna. Proporcionaando algunos ejemplos basados en el conjunto de datos **mtcars**:

Subconjunto donde el número de cilindros del automóvil es **exáctameente 6** y la potencia de caballos es **mayor que 115**.

```{r}
subset(mtcars, cyl == 6 & hp > 115)
```

Lo mismo que en el ejemplo anterior, pero **solo mostramos las variables** **mpg**, **cyl** y **disp** utilizando el argumento **select**.

```{r}
subset(mtcars, cyl == 6 & hp > 115, select = c(mpg, cyl, disp))
```

Ahora, en lugar de utilizar la condición AND, usaremos la condición OR. En este caso se seleccionarán los coches donde la variable **wt** es menor que 2 o la variable **hp** es mayor que 115.

```{r}
subset(mtcars, wt < 2 | hp > 115)
```

\newpage

# CAPÍTULO 6

\newpage

## [**INSTALAR PAQUETES EN R**](https://r-coder.com/instalar-paquetes-r/)

![](install_r_packages.png)

**Un paquete de R es una biblioteca de funciones** que se han desarrollado para cubrir algunas necesidades o métodos científicos que no están implementados en las funciones de R base. Las funciones que R proporciona de manera predeterminada son limitadas, por lo que es posible que una pregunta sea cómo instalar nuevos paquetes en R. **Existen varias fuentes** para installar paquetes en R.

\newpage

## INSTALANDO PAQUETES DESDE **CRAN**

[**CRAN**](https://cran.r-project.org/web/packages/available_packages_by_name.html) es el **repositorio oficial de paquetes de R**, que cuenta con miles de paquetes de R gratuitos. La mayoría de ellos han sido desarrollados por científicos de datos, estadísticos, profesores universitarios e investigadores. Hay **todo tipo de paquetes**, desde paquetes de gráficos como el conocido **ggplot2** hasta temas específicos como el paquete **DTDA.cif**, que implementa estimadores para funciones de incidencia acumuladas de riesgos competitivos bajo truncamiento doble.[^lop]

[^lop]: **CRAN** es el repositorio oficial de R. **Todos los paquetes han sido probados** de manera automática y cumplen con la política de código CRAN.

En primer lugar, se debe **buscar el nombre del paquete que se desea instalar**. Es posible que se quiera buscar sobre un tema buscando en Google, como: *"paquete de gráficos R"* o *"paquete" de R para series de tiempo y econometría*. También se puede usar las [**CRAN Task Views**](https://cran.r-project.org/web/views/), donde se puede encontrar los **paquetes de R más relevantes por tema**.

Que el paquete esté en CRAN no implica que los métodos estén siempre bien implementados, ya que no hay comprobaciones de terceros sobre esto. Además **puede haber errores** que no se hayan comprobado. En caso de que se encuentre algún tipo de error o problema, se debe de contactar con el responsable del mantenimiento del paquete.[^opo]

[^opo]: **¡Precaución!** Que un paquete esté en CRAN no implica que los métodos estén siempre bien implementados, ya que no hay comprobaciones de terceros sobre esto. Además, **puede haber errores** que no se hayan comprobado. En caso de que se encuentre algún tipo de error o problema, se debe de contactar con el responsable del mantenimiento del paquete.

### FUNCIÓN PARA INSTALAR PAQUETES DE R

Una vez que se haya decidido qué paquete instalar, simplemente se ejecuta la función **install.packages()** con el nombre del paquete dentro de los paréntesis **con comillas**. Como ejemplo, se va a instalar el paquete **calendR**, que permite crear calendarios mensuales y anuales, pero se puede instalar el paquete que sea de agrado propio.

```{r eval=FALSE}
install.packages("calendR")
```

Después de la instalación, es necesario cargar el paquete si se quiere acceder a sus funciones. Para ello se puede utilizar la función **library()** especificando el nombre del paquete **con o sin comillas**.

```{r eval=FALSE}
library(calendR)
library("calendR") # Equivalente
```

Una vez cargado, se usa la función **help()** o **?** con el nombre del paquete o el nombre de cualquier función para ver la documentación. También se encontrará con ejemplos útiles para comprender cómo funciona el paquete.

```{r eval=FALSE}
help("calendR")
help(calendR) # Equivalente
?calendR # Equivalente

# Ayuda de la función principal del paquete
help("calendR")
```

Además, en caso de que resulte de interés, se puede saber dónde se instalan los paquetes ejecutando la función **.libPaths()**

```{r eval=FALSE}
.libPaths() # Devuelve el directorio de instalación
```

### INSTALANDO PAQUETES DE CRAN DESDE EL MENÚ

Alternativamente, se pueden instalar paquetes de R desde el menú del entorno de desarrollo:

* En RStudio, se va a **Tools** → **Install packages...** y en la opción **Install from**, seleccionar **Repository (CRAN)** y luego especificar los paquetes que se quiera instalar.
* En R GUI se va a **Paquetes** → **Instalar paquete(s)...**, seleccionar un *"mirror"* e instalar el paquete.

### INSTALANDO PAQUETES EN R DESDE UN ZIP

Es posible que se haya descargado un paquete en formato **.zip** o **tar.gz**. Para instalar el paquete desde un archivo zip local solo se necesita llamar a la función **install.packages()** con los argumentos **repos = NULL** y **type = "source"**. Hay que tener en cuenta que **la ruta del archivo no debe de contener espacios**:

```{r eval=FALSE}
install.packages("C:\\ruta\\nombre_del_paquete.extensión",
                 repos = NULL, type = "source")
```

También se puede configurar primero el entorno de trabajo con la función **setwd()** en la carpeta donde se descargó el archivo del paquete y luego instalar el paquete especificando el nombre del archivo zip o tar.gz.

```{r eval=FALSE}
setwd("C:\\ruta_del_archivo")
install.packages("nombre_del_paquete.extensión",
                 repos = NULL, type = "source")
```

La última opción es usar el menú. En RStudio se va a **Tools** → **Install packages** y en la opción **Install from** elegir **Package Archive File (.zip; .tar.gz)** y seleccionar el archivo. En R GUI se va a **Paquetes** → **Install package(s) from local files**.

En caso de que se tenga el zip alojado en algún URL, se puede usar la función **install.packages.zip()** del paquete **installr**. Hay que tener en cuenta que también se puede instalar paquetes desde CRAN (incluso versiones anteriores) de esta manera.

```{r eval=FALSE}
# install.packages("installr")

library(installr)
install.packages.zip("https://cran.r-project.org/bin/windows/
                     contrib/r-release/calendR_1.0.zip")
```

## INSTALAR VARIOS PAQUETES LA VEZ

Si se necesita instalar varios paquetes a la vez sin escribir la misma función una y otra vez, se puede utilizar la función **c()** dentro de la función **install.packages()**. Hay que tener en cuenta que ahora sí se necesita usar comillas para especificar el nombre de los paquetes.

```{r eval=FALSE}
install.packages(c("ggplot2", "dplyr"))
```

Ahora ya sabemos cómo instalar paquetes de R desde CRAN, pero se debe saber que **no todos los paquetes de R están en CRAN** por muchas razones. La razón  principal es que CRAN tiene una política de requisitos y comprobaciones de código y algunos desarrolladores no quieren pasar tiempo solucionando pequeños detalles para cumplirlos. Otras veces existe una versión de **desarrollo en GitHub** de un paquete de CRAN con funciones en pruebas. En las siguientes secciones se aprenderá cómo **instalar paquetes de otras fuentes** disponibles.[^oop]

[^oop]: En las siguientes secciones se mostrará cómo instalar **paquetes de fuentes no oficiales**. Hay que tener en cuenta que ciertos paquetes pueden estar en un proceso de desarrollo y podrían llegar a dar **errores inesperados en algunas ocasiones**.

Hay que tener en cuenta que ciertos paquetes pueden estar en un proceso de desarrollo o podrían a dar **errores inesperados en algunas ocasiones**.

## INSTALAR PAQUETES DE R DESDE GITHUB O GITLAB

GitHub es una conocida plataforma de intercambio de código. Si se accede a la página **se puede buscar paquetes de R** utilizando la barra de búsqueda y escribiendo algo como: *“plot package language: R”* en caso de que se desee buscar paquetes para gráficos. La parte *“language:R”* es un comando del buscador de la web para restringir los resultados a repositorios de código R. Supongamos que se quiere descargar la versión de desarrollo del paquete **ggplot2** de GitHub. La dirección URL será como sigue:

[https://github.com/tidyverse/ggplot2](https://github.com/tidyverse/ggplot2)

El primer paso es instalar y cargar el paquete **devtools**, disponible en CRAN. Si se encuentra algún error significa que también se necesita instalar las **RTools**.

```{r eval=FALSE}
install.packages("devtools")
library(devtools)
```

A continuación se puede llamar a la función **install_github()** con **"nombre_de_la_cuenta/nombre_del_repositorio"** como argumento para instalar el paquete desde GitHub:

```{r eval=FALSE}
 # Instalando el paquete ggplot2 desde GitHub
install_github("tidyverse/ggplot2")
```

Cabe mencionar que si no se quiere cargar **devtools** cada vez que se quiera instalar un paquete de GitHub, se puede usar **devtools::install_github("nombre_de_la_cuenta/nombre_del_repositorio")**, ya que el operador **::** permite llamar funciones desde un paquete sin la necesidad de cargarlo.

## INSTALAR PAQUETES DESDE R-FORGE

El proyecto R Forge es una web con herramientas de desarrollo de paquetes y repositorios. Como ejemplo, si se quisiese instalar el paquete **MPAgenomics**, **se debe especificar** en el argumento **repos** de la función **install.packages()** la **URL del proyecto de R Forge**. El argumento **dependencies** se usa cuando **repos** no es **NULL** para especificar si las dependencias del paquete que se está instalando deben ser instaladas también o no.

```{r eval=FALSE}
install.packages("MPAgenomics", repos = "http://R-Forge.R-project.org",
                 dependencies = TRUE)
```

## INSTALAR PAQUETES EN R DESDE BIOCONDUCTOR

Bio conductor es otro proyecto que aloja herramientas y [**paquetes de R para analizar datos biológicos**](https://www.bioconductor.org/packages/release/bioc/). Primero que nada, se tiene que instalar el paquete **BiocManager**.

```{r eval=FALSE}
install.packages("BiocManager")
```

Una vez instalado se usa la función **install()** del paquete.

```{r eval=FALSE}
# Instalando el paquete nanotatoR
BiocManager::install("nanotatoR")
```

Al igual que sucedía con los paquetes de CRAN, se puede instalar varios paquetes a la vez:

```{r eval=FALSE}
# Instalando los paquetes ncffFlow y NBSplice
BiocManafer::install("ncdfFlow", "NBSplice")
```

Se puede ver la **lista completa de paquetes de Bioconductor** escribiendo la función **BiocManager::available()**. Para más información sobre el proceso de instalación de Bioconductor se puede ver la referencia oficial sobre [**paquetes de Bioconductor**](https://www.bioconductor.org/install/#install-bioconductor-packages).

## INSTALAR PAQUETES DE R EN LA NOTEBOOK DE JUPYTER

En caso de que se use R bajo el entorno *"conda"* con el Notebook Jupyter y se necesite más paquetes de R que los incluidos como *"Essentials"*, se puede usar la función base para instalar paquetes pero especificando el argumento **repos** como el siguiente ejemplo:

```{r eval=FALSE}
install.packages("ggplot2", repos = "http://cran.es.r-project.org")
```

## ACTUALIZAR PAQUETES DE R

**Actualizar paquetes en R** puede ser tedioso si se tiene que reinstalar los paquetes una y otra vez cuando algunos tienen una versión más nueva disponible. Se puede ver la lista completa de los paquetes de R que no están actualizados con la función **old.packages()**:

```{r eval=FALSE}
old.packages()
```

Se pueden actualizar algunos de ellos manualmente con la función **install.packages()** o llamando a la función **update.packages()**. Si se establece el argumento **ask** como **FALSE**, se evitará que R muestre mensajes emergentes.[^poor]

```{r eval=FALSE}
update.packages()
update.packages(ask = FALSE) # No mostrar mensajes
```

[^poor]: Solamente se podrán actualizar los paquetes si no están cargados en memoria. Si ya se ha cargado un paquete y se desea actualizar, se usa la función **detach()** de la siguiente manera: **detach(package::nombre_del_paquete, unload = TRUE)**

## LISTAR LAS FUNCIONES DE UN PAQUETE

Una vez instalado, se puede obtener una **lista de todas las funciones del paquete**. Si el paquete está en CRAN, se encontrará la documentación en formato PDF de todas las funciones dentro de una página comn la siguiente estructura:

* https://cran.r-project.org/web/packages/nombre_del_paquete.

Hay que recordar que se puede acceder a esta documentación en formato HTML con la función **help()** o **?**.

```{r}
help(package = "ggplot2")
```

También se puede usar los comandos **lsf-str()** o **ls()** para enumerar todas las funciones dentro de un paquete ya cargado.

```{r eval=FALSE}
library(ggplot2)
ls("package:ggplot2")      # Nombres de las funciones
lsf.str("package:ggplot2") # Nombres con descripción de los argumentos
```

Otra opción es escribir: **nombre_del_paquete::** y se mostrará una lista en RStudio en forma de desplegable. En R GUI se deberá presionar el boton tabular para que se muestren las funciones en pantalla, aunque es necesario destacar que si el paquete contiene muchas funciones no se mostrarán todas, como sucede con el paquete **ggplot2**:

```{r eval=FALSE}
> ggplot2::

ggplot2::scale_fill_brewer         ggplot2::scale_size
ggplot2::GeomLine                  ggplot2::ScaleContinuousIdentity
ggplot2::geom_boxplot              ggplot2::guide_legend
ggplot2::ScaleDiscreteIdentity     ggplot2::Layout
ggplot2::scale_colour_ordinal      ggplot2::geom_hex
ggplot2::GeomRasterAnn             ggplot2::panel_cols
ggplot2::scale_colour_date         ggplot2::StatYdensity
ggplot2::stat_bin_2d               ggplot2::scale_y_sqrt
ggplot2::aes_all                   ggplot2::alpha
ggplot2::scale_shape               ggplot2::position_dodge2
[...truncated]
```

## VER EL CÓDIGO FUENTE DE LAS FUNCIONES DE UN PAQUETE

Puede que se esté interesado en inspeccionar el código fuente de algunas funciones. Para ello se tiene varias opciones:[^ñoño]

* Llamar el nombre de la función de la consola.
* Presionar **Ctrl + Click Izquierdo** o **Cmd + Click Izquierdo** en el nombre de la función (escrita en un script) cuando se use RStudio.
* En la página de CRAN del paquete (o GitHub, R-forge,$...$), se puede descargar el archivo e inspeccionar manualmente el código.

[^ñoño]: Hay que tener en cuenta que si la función está escrita en Fortran, C o en un lenguaje diferente de R, **no podrá verse el código** con el primer y el segundo método.

## COMPROBAR SI UN PAQUETE ESTÁ INSTALADO

Es habitual que no se recuerde si se tiene un paquete instalado y no se quiere perder el tiempo en volverlo a instalar. Para evitar esto, se puede usar la función **require()**. La **principal diferencia** entre **require()** y **library()** es que la primera devuelve un **TRUE** o **FALSE** y la segunda devuelve un error si el paquete no está instalado. La función **require()** está diseñada para usarse dentro de otras funciones.

```{r eval=FALSE}
# So FALSE, instalada el paquete
if (require("ggplot2")) install.packages("ggplot2")
```

La siguiente línea de cóodigo tambbién devolverá un **TRUE** si el paquete está instalado o **FALSE** en caso contrario.

```{r eval=FALSE}
"ggplot2" %in% rownames(install.packages())
```
## ERROR EN **install.packages()**: NO SE PUEDE ELIMINAR LA INSTALACIÓN PREVIA DEL PAQUETE

Si se encuentra con este error significa que se podría estar utilizando diferentes versiones de R en el mismo ordenador. Las soluciones son:

* Cerrar todas las sesiones abiertas de R, abrirlo de nuevo e instalar el paquete.
* Si lo anterior no funciona, se revisa el error y se va a la dirección que se indica donde está el archivo **00LOCK** y eliminarlo.
* Otra opción es usar la función **.libPaths()**, que devuelve la ruta donde están instaladas las librerías y borra el paquete que da problemas para realizar una instalación limpia.

## ¿NO SE CONSIGUE INSTALAR UN PAQUETE?

Para finalizar esta parte del capítulo, cabe destacar que si no se consigue instalar paquetes en R puede ser debido a diversas razones:

* Está **desconectado de internet**.
* El paquete **ya no está disponible** Puede encontrarse versiones antiguas con: [https://cran.r-project.org/src/contrib/Archive/Nombre_del_paquete](https://cran.r-project.org/src/contrib/Archive/Nombre_del_paquete)
* **Se ha escrito mal el nombre** del paquete. Hayq eu recordar que R distingue entre mayúsculas y minúsculas.
* Si **se necesitan las Rtools** para compilar el paquete, se tendrá que instalar primero.

Si nada funciona, se intenta cerrar y abrir R de nuevo, o intentarlo en otro ordenador para verificar si el problema persiste o se debe a la configuración local.

\newpage

# CAPÍTULO 7

\newpage

## [**MEDIDAS DE TENDENCIA CENTRAL**](https://www.medwave.cl/link.cgi/Medwave/Series/MBE04/4934#:~:text=Las%20medidas%20de%20tendencia%20central,%3A%20media%2C%20mediana%20y%20moda.)

Las medidas de tendencia central suelen ser medidas estadísticas que pretender resumir en un solo valor a un conjunto de valores. Representan un centro en torno al cual se encuentra ubicado el conjunto de los datos. Las medidas de tendencia central más utilizadas son:

* Media
* Mediana
* Moda

## [**CÁLCULO DE LA MEDIA EN R**](https://r-coder.com/media-r/)

![](mean-r.png)

La media, también llamada valor esperado en Estadística, es una medida de tendencia central. Generalmente, representa la suma de todas las observaciones divididas entre el número de observaciones de los dator (media aritmética). 

### MEDIA ARITMÉTICA CON LA FUNCIÓN **mean()**

Para calcular la media aritmética de un vector, se puede utilizar la función **mean()**. Consideremos el siguiente ejemplo que representa las notas de un examen de un estudiante en el año en curso:

```{r}
# Vector de muestra
x = c(7, 10, 6, 6, 8, 9, 8, 6)
```

Usando la función **mean()** se puede calcular la media aritmética de las calificaciones del estudiante:

```{r}
mean(x) # 7.5

# O su equivalencia a programar:
sum(x)/length(x) # 7.5
```

Hay que tener en cuenta que, si por alguna razón **se encuentran elementos del vector que están ausentes** (el vector contiene algún valor **NA**) se deberá establecer el argumento **na.rm** de la función como **TRUE**. En otro caso, la salida será **NA**.

```{r}
# Vector con NA
x = c(4, NA, 6, 5, 6, 3)

# Si el vector coniene algún valor NA,
# el resultado será NA
mean(x) # NA

# Eliminar los valores NA
mean(x, na.rm = TRUE) # 4.8
```

### MEDIA ARITMÉTICA TRUNCADA EN R

La media aritmética truncada **elimina una fracción de las observaciones de cada lado del vector antes de que se calcule la media**. Esto es especialmente interesante cuando el vector contiene datos atípicos que no queremos que sean usados cuando se calcula la media.

```{r}
# Vector de datos de  muestra
y = c(2, rep(12, 8), 60)
y

# Media aritmética
mean(y) # 15.8

# Media aritmética truncada al 10%
# elimina el primer y último elemento de este ejemplo
mean(y, trim = 0.1) # 12
```

### MEDIA PONDERADA CON LA FUNCIÓN **weighted.mean()**

La media aritmética considera que cada observación tiene la misma relevancia que las otras. Si queremos asignar una relevancia diferente para cada observación podemos **asignar un peso o ponderación diferente a cada observación** (la media aritmética considera el mismo peso para todos los elementos del vector).

Para asignar ponderaciones o pesos, se puede utilizar la función **weighted.mean()** de la siguiente manera:

```{r}
# Vector de muestra
z = c(5, 7, 3)

# Pesos (deberían sumar 1)
wts = c(0.1, 0.3, 0.6)

# Media ponderada
sum(z * wts) # 4.4
```

Si los datos contienen algún **NA**, se puede utilizar el argumento de la función.

## [**CÁLCULO DE LA MEDIANA EN R**](https://r-coder.com/mediana-r/)

![](median-r.png)

La mediana es una medida de tendencia central que se define como aquel valor que divide un conjunto de observaciones, ordenafas de menor a mayor, en dos partes con el mismo número de observaciones o como aquel valor que divide los datos en dos partes de igual probabilidad.

### MEDIANA DE UNA VARIABLE DISCRETA

Para calcular la mediana de un conjunto de observaciones se puede utilizar la función **mean()**. Considera el siguiente vector:

```{r}
# Vector de ejemplo con un número impar de datos observados
datos = c(123, 117, 46, 178, 193, 45, 12, 765, 145, 34, 100)

# Mediana de los datos
median(datos) # 117
```

En este caso, se observa que la mediana de los datos es 117. Puede variar dependiendo el orden y los datos que se hayan observado. Podemos comprobarlo ordenando los datos y viendo que hay el mismo número de datos a los lados de la mediana. En este caso **quedan cinco datos a la izquierda y cinco datos a la derecha**.

```{r}
# Visualizamos lo anterior estructurado
plot(1, 1, type = "n", axes = FALSE, ann = FALSE,
     xlim = c(0, 11), ylim = c(0, 1))
text(c(1:11), rep(0.5, 10), as.character(sort(datos)))
rect(xleft = 5.6, ybottom = 0.45, xright = 6.4, ytop = 0.55, border = 2)
arrows(x0 = 0.7, y0 = 0.4, x1 = 5, code = 3, length = 0.15)
arrows(x0 = 7, y0 = 0.4, x1 = 11, code = 3, length = 0.15)
text(c(3, 9), 0.35, "5")
```

Hay que tener en cuenta que **si el número de observaciones es impar, la mediana se calculará como la media de los valores centrales**. Considera los mismos datos de antes menos la primera observación:

```{r}
# Vertor de ejemplo con un número par de observaciones
datos2 = c(111, 46, 178, 193, 45, 12, 765, 145, 34, 100)

# Mediana de los datos
median(datos2) # 105.5
```

En este caso, la mediana es de 105.5. La mediana corresponde con la media de los valores 100  y 111, dejando 4 observaciones de cada lado, tal y como se ilustra a continuación:[^asd]

[^asd]: Si la variable contiene valores **NA** se puede establecer el argumento **na.rm()** como **TRUE** para borrarlos.

```{r}
# Visualizamos lo anterior estructurado
plot(1, 1, type = "n", axes = T, ann = FALSE,
     xlim = c(0, 11), ylim = c(0, 1))
text(c(1:10), rep(0.5, 10), as.character(sort(datos2)))
rect(xleft = 4.5, ybottom = 0.45, xright = 6.5, ytop = 0.55, border = 2)
arrows(x0 = 0.7, y0 = 0.4, x1 = 4.25, code = 3, length = 0.15)
arrows(x0 = 6.75, y0 = 0.4, x1 = 10.5, code = 3, length = 0.15)
text(c(2.5, 8.5), 0.35, "4")
text(5.5, 0.6, "mean(c(100, 111)) = 105.5")
```

### MEDIANA DE UNA VARIABLE CONTINUA

Si en lugar de una variable discreta tenemos una continua también podemos utilizar la función **median()**, pero en este caso, la mediana es aque valor que deja un 50% de probabilidad a ambos lados. Para esto, consideremos la distribución normal de media 0 y desviación típica de 1:

```{r}
set.seed(1)
datos3 = rnorm(1000, mean = 0, sd = 1)
```

En este caso vemos que la mediana está muy cerca de su valor teórico (como la distribucón es simétrica, la media y la mediana son iguales, por lo que la mediana teórica es 0).

```{r}
# Mediana de los datos
median(datos3) # 0.00421211
```

### MEDIANA POR GRUPO EN R

Por último, si tenemos un conjunto de datos clasificados por grupos, podemos utilizar la función **tapply()** para calcular la mediana por grupo. Se toma como ejempli los siguientes datos:

```{r}
# Datos por grupo
set.seed(1)
x = sample(1:1000, 100)

grupo = sample(c("A", "B", "C"), 100, replace = TRUE)
datos4 = data.frame(x, grupo)

head(datos4)
```

Se logra aplicar la función **taply()** al conjunto de datos creado de la siguiente manera:

```{r}
# Mediana por grupo
tapply(datos4$x, datos4$grupo, median)
```

La salida nos devolverá la mediana de cada grupo.

## [**ESTIMAR LA MODA EN R**](https://r-coder.com/moda-r/)

![](mode-r.png)

La moda es una medida de tendencia central que se define como el valor más probable de una variable aleatoria o como el valor más frecuente de un conjunto de observaciones. Es una medida robusta que coincide con la **media** y la **mediana** en distribuciones simétricas. 

### ESTIMACIÓN UNIMODAL DISCRETA

Se considera que se tiene el siguiente vector:

```{r}
# Datos unimodales discretos
x = c(1, 4, 1, 3, 1, 4, 1, 8, 6)
```

La moda se calcula como el valor más repetido dentro de la variable, qu en este caso es el 1. Una manera sencilla de **calcular la moda en R** es usando la siguiente función:

```{r}
# Función creada para calcular la moda
mode = function(x) {
  return(as.numeric(names(which.max(table(x)))))
}

# Moda del vector x
mode(x) # 1
```

En este caso, podemos comprobar que la moda es 1 pasando el vector a la función. Si queremos visualizar el número de veces que se repite cada dato también se puede crear un gráfico de barras:

```{r}
barplot(table(x), col = c(5, rep("gray", 5)))
legend("topright", "moda", fill = 5)
```

### ESTIMACIÓN UNIMODAL CONTINUA

**Si nuestra variable de interés es continua** en lugar de discreta no podemos utilizar el procedimiento anterior, sino que debemos recurrir a otro método. El procedimiento más habitual en la literatura es **calcular el máximo de la estimación de la función de densidad de los datos mediante algún algoritmo**.

Consideremos los siguientes datos normales (unimodales) con media 0 y desviación típica 1. Como la distribución normal es simétrica, sabemos que la media, la mediana y la moda son iguales (0).

```{r}
# Datos unimodales continuos
set.seed(1234)
x2 = rnorm(1000, mean = 0, sd = 1)
```

Para lograr visualizar las modas podemos generar el histograma y la estimación de la función de densidad de los datos. Hay que tener en cuenta que la selección del parámetro ventana determinará la forma de la densidad estimada.

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
# Histograma
hist(x2, freq = FALSE)

# Densidad
dx = density(x2)
lines(dx$x, dx$y, col = 2, lwd = 2)

# Moda teórica
abline(v = 0, col = 4, lty = 2, lwd = 3)
```

Para realizar el cálculo se recomienda recurrir a la función **mlv()** de la librería **modeest**, que nos permite seleccionar entre diferentes algoritmos. Se aconseja utilizar el algoritmo *"mean-shift"* como se indica a continuación.

```{r}
# install.packages("modeest")
library(modeest)

# Moda
mlv(x2, method = "meanshift") # -0.03912067
```

Podemos observar que la moda estimada (-0.039) es muy próxima a la moda teórica (0). Otros métodos disponibles para calcular la moda dentro de la función **mlv()** son: *"lientz"*, *"naive"*, *"venter"*, *"grenander"*, *"hsm"*, *"parzen"*, *"tsybakov"* y *"asselin"*.

### ESTIMACIÓN MULTIMODAL DISCRETA

A diferencia de la mediana o la media, **la moda puede tomar varios valores a la vez**. Como ejemlpo, se considera el vector **y**, donde hay dos modas:

```{r}
# Datos multimodales discretos
y = c(3, 3, 5, 3, 6, 5, 5)

# Histograma
hist(y)
```

Para este caso los valores más repetidos son el 3 y el 5. Para calcular varias modas podemos recurrir a la función **mlv()** del paquete **modeest** y aplicar el método **mfv**.

```{r}
# installed.packages("modeest")
library(modeest)

# Modas
mlv(y, method = "mfv") # 3 5
```

### ESTIMACIÓN MULTIMODAL CONTINUA

Si queremos calcular varias modas en el caso de tener una variable continua podemos recurrir a la función **locmodes()** de la librería **multimode**.

Se consideran los siguientes datos multimodales, cuyas modas teóricas son 40 y 120, representadas con líneas rojas verticales:

```{r}
# Datos multimodales continuos
n = 1000
bin = rbinom(n, 1, 0.6)
y2 = rnorm(n, mean = 120, sd = 11) * bin +
  rnorm(n, mean = 40, sd = 5) * (1 - bin)

# Histograma
hist(y2, col = "grey")

# Moda teórica 1
abline(v = 40, col = 2, lwd = 2)

# Moda teórica 2
abline(v = 120, col = 2, lwd = 2)
```

A los datos anteriores les podemos aplicar la función **locmodes()**, **indicando el número de modas que esperamos encontrar** en el argumento **mod0**.

```{r}
# install.packages("multimode")
library(multimode)

modas = locmodes(y2, mod0 = 2)
modas
```

En la salida anterior podemos observar que las modas estimadas son 40.1491 y 122.455, muy próximas a los valores teóricos.

La librería también incorpora un método para dibujar las estimaciones que devuelve la función **locmodes()**, indicando la localización de las modas y de las antimodas, así como la ventana utilizada.[^khj]

```{r}
# Modas
plot(modas)
```

[^khj]: La librería también incluye la función ***modetest()***, para contrastar la experiencia de multimodalidad en los datos, así como funciones para explorar el número de modas, entre ellas se encuentra las funciones ***modetree()***, ***modeforest()*** y ***sizes()***.

\newpage

# CAPÍTULO 8

\newpage

## [**MEDIDAS DE DISPERSIÓN**](https://economipedia.com/definiciones/medidas-de-dispersion.html)

Las medidas de dispersión tratan, a través de diferentes fórmulas, de arrojar un valor numérico que ofrezca información sobre el grado de variailidad de una variable.

En otras palabras, las medidas de dispersión son números que indican si una variable se mueve mucho, poco, más o menos que otra. La razón de ser este tipo de medidas es conocer de manera resumida una característica de la variable estudiada. En este sentido, deben acompañar a las **medidas de tendencia central**. Juntas ofrecen información de un sólo vistazo que luego se puede utilizar para comparar y, si fuera preciso, tomar decisiones.

### PRINCIPALES MEDIDAS DE DISPERSIÓN

Las medidas de dispersión más conocidas son: el rango, la varianza, la desviación típica y el coeficiente de variación (no confundir con coeficiente de determinación).

En esta sección se definirán y se realizarán pruebas prácticas a través de R para medir la **Varianza**[^2121] y la **Desviación típica**.[^1212]

[^2121]: Para conocer la definición técnica de la **Varianza**, solamente se accede al siguiente enlace: Economipedia (2021), *Varianza*. Disponible en: [https://economipedia.com/definiciones/varianza.html](https://economipedia.com/definiciones/varianza.html) 
[^1212]: Para conocer la definición técnica de la **Desviación típica** se accede al siguiente enlace: Economipedia (2021), *Desviación estándar o típica*. Disponible en:  [https://economipedia.com/definiciones/desviacion-tipica.html](https://economipedia.com/definiciones/desviacion-tipica.html)

\newpage

## [**VARIANZA Y DESVIACIÓN TÍPICA EN R**](https://r-coder.com/varianza-desviacion-tipica-r/)

![](standard-deviation-variance.png)

La desviación típica y la varianza son medidas de dispersión que cuantifican el grado de variabilidad de una variable. Junto con las **medidas de tendencia central**, las **medidas estadísticas de dispersión** se usan para describir las propiedades de una distribución. En este tutorial aprenderás a calcular la varianza ya la desviación típica en R con las funciones **var()** y **sd()**.

### VARIANZA EN R CON LA FUNCIÓN **var()**

La varianza, generalmente denotada como $s^2_{n}$ o $\sigma^2_{n}$, es la **media aritmética** de las desviaciones al cuadrado de los valores de la variable con respecto a su media. Esto es:[^varianza]

[^varianza]: En ocasiones, la varianza se puede calcular como $S_{n}^2=\frac{1}{n-1}\Sigma_{i=1}^n(x_{i}-\bar{x})^2$, siendo $n$ el número de observaciones y $\bar{x}$ la media de la variable. Se usa el denominador $n-1$ para obtener un estimador insesgado de la varianza para observaciones *i.i.d*.

\begin{equation}
\sigma^2_{n}=\frac{\Sigma(x_{i}-\bar{x})^2}{n}
\end{equation}

Donde:

* $x$ → Variable sobre la que se pretende calcular la varianza.
* $x_{i}$ → Observación número $i$ de la varaible $x$. $i$ puede tomar valores entre 1 y $n$.
* $n$ → Número de observaciones.
* $\bar{x}$ → Es la media de la variable $x$.

**La varianza es siempre positiva y cuanto mayor sea su valor mayor será la dispersión de los datos**.

Usando R, podemos utilizar la función **var()** para calcular la varianza de una variable. Considerando el siguiente vector de ejemplo es posible calcular su varianza la dicha función:

```{r eval=FALSE}
# Vector de muestra
x = c(10, 25, 12, 18, 5, 16, 14, 20)

# Varianza
var(x) # 38.57143
```

Hay que tener en cuenta que la función proporiona un argumento llamado **na.rm** que puede establecerse como **TRUE**  para eliminar valores faltantes.

### DESVIACIÓN TÍPICA EN R CON LA FUNCIÓN **sd()**

La desviación típica o desviación estándar es la **raíz cuadrada positiva de la varianza**, eso es, $s_{n}=\sqrt{\sigma^2_{n}}$.

La desviación típica es otra medida que ofrece información de la dispersión respecto a la media. Su cálculo es exactamente el mismo que la varianza, pero realizando la raíz cuadrada de su resultado. Es decir, la desviación típica es la raíz cuadrada de la varianza.

\begin{equation}
\sigma_{n}=\sqrt{\frac{\Sigma(x_{i}-\bar{x})^2}{n}}
\end{equation}

Donde:

* $x$ → Variable sobre la que se pretende calcular la varianza.
* $x_{i}$ → Observación número $i$ de la varaible $x$. $i$ puede tomar valores entre 1 y $n$.
* $n$ → Número de observaciones.
* $\bar{x}$ → Es la media de la variable $x$.

En R, la desviación típica de una variable se puede calcular haciendo uso de la función **sd()**, tal y como se muestra a continuación:

```{r eval=FALSE}
# Vector de muestra
x = c(10, 25, 12, 18, 5, 16, 14, 20)

# Desviación típica
sd(x) # 6.21059

# Equivalente a:
sqrt(var(x)) # 6.21059
```

De manera similar, se puede calcular la varianza como el cuadrado de la desviación típica:

```{r eval=FALSE}
# Vector de muestra
x = c(10, 25, 12, 18, 5, 16, 14, 20)

# Varianza
sd(x) ^ 2 # 38.57143
```

La función **sd()** también proporciona el argumento **na.rm**, que puede establecerse como **TRUE** si el vector de entrada contiene algún valor **NA**. En otro caso, la salida de la función será también un **NA**.

\newpage

# CAPÍTULO 9

\newpage

## [**TABLA DE CONTINGENCIA EN R**](https://r-coder.com/tabla-contingencia-r/)

![](contingency-table-r.png)

En varias situaciones resulta interesante estudiar dos o más variables al mismo tiempo. Al trabajar con variables categóricas se puede **resumir los datos en una tabla llamada** *"tabla de contingencia o de frecuencia"*. La **relación entre las variables** también se puede verificar con **medidas de asociación**.

## ¿CÓMO HACER UNA TABLA DE CONTINGENCIA EN R? LA FUNCIÓN **table()**

Las variables cualitativas, también conocidas como variables nominales, categóricas o de tipo factor, aparecen cuando se tienen **variables no medibles** (género, lugar de nacimiento, raza, …). Este tipo de variables se pueden representar con texto, donde cada nombre representa una única categoría, o con números, donde cada número representa una categoría única. Al trabajar con varias variables categóricas, puedes representar su distribución conjunta de frecuencias con una tabla de frecuencias o **tabla de contingencia**.

Se considera el caso bidimesional con las variables $X$ e $Y$ y denotar que $x_{i}$, $i=1,...,k$ como los diferentes valores pueden tomarla variable $X$ e $y_{i}$, $i=1,...,h$ como los valores que puede tomar la variable $Y$. Con esto en mente se puede definir:

1. **Frecuencia absoluta conjunta** de ($x_{i}$, $y_{j}$). Es el **número de idividuos** que representan al mismo tiempo los valores $x_{i} \in X$ e $y_{j} \in Y$ y se denota como $n_{ij}$.
2. **Frecuencia relativa conjunta** o ($x_{i}$, $y_{j}$). Es la **proporción de individuos** que representan al mismo tiempo los valores $x_{i} \in X$ e $y_{j} \in Y$ del número total de individuos y se define como $f_{ij}=n_{ij}/n$, donde $n$ es el tamaño muestral.

Hay que tener en cuenta que la distribución bidimensional es el conjunto de valores que la variable bidimensional ($X$, $Y$) puede tomar además de las frecuencias conjuntas de esos valores. Para representar una distribución bidimensional, se puede usar la tabla de contingencia bidimensional, conocida como **tabla de dos vías o de dos entradas**, que tomará la forma como:

\begin{equation}
\begin{pmatrix}
X/Y & y_{1} & y_{2} & \cdots & y_{j} & \cdots & h_{h} & n_{j\bullet } \\
x_{1} & n_{11} & n_{12} & \cdots & n_{1j} & \cdots & n_{1h} & n_{1\bullet } \\
x_{2} & n_{21} & n_{22} & \cdots & n_{2j} & \cdots & n_{2h} & n_{2\bullet } \\
\vdots  & \vdots &  \vdots & \ddots & \cdots & \ddots & \vdots & \vdots \\
x_{i} & n_{i1} & n_{i2} & \cdots & n_{ij} & \cdots & n_{ih} & n_{i\bullet } \\
\vdots  & \vdots &  \vdots & \ddots & \cdots & \ddots & \vdots & \vdots \\
x_{k} & n_{1k} & n_{2k} & \cdots & n_{kj} & \cdots & n_{kh} & n_{k\bullet } \\
x_{\bullet j} & n_{\bullet 1} & n_{\bullet 2} & \cdots & n_{\bullet j} & \cdots & n_{\bullet h} & n_{}
\end{pmatrix}
\end{equation}

## TABLA DE FRECUENCIAS ABSOLUTAS EN R

Se puede hacer uso de la función **table()** para crear una tabla de contingencia en R. Se considera, como ejemplo, el siguiente conjunto de datos aleatorios, donde la variable $X$ represent los votos a favor (Si) y en contra (No) de una ley en un comité internacional compuesto por miembros de tres continentes (variable $Y$):

```{r}
# Fijamos semilla
set.seed(10)

# Generamos datos aleatorios para la variable X
X = sample(c("Si", "No"), 20, replace = TRUE)

# Generamos datos aleatorios para la variable Y
Y = sample(c("Europa", "America", "Asia"), 20, replace = TRUE)

tabla = table(X, Y)
tabla
```

Con la función **table()** se puede crear una tabla de frecuencias (la distribución marginal) para cada variable:

```{r}
table(X)
table(Y)
```

Sin embargo, si se pasan dos variables a la función, se puede crear una tabla de contingencia de dos entradas. Cabe mencionar que se podría agregar más variables a la función, dando como resultado un array multidimensional. Nótese que se pueden modificar los nombres de las columnas y de las filas con las funciones colnames y rownames, respectivamente.[^mma]

```{r}
rownames(tabla) = c("0", "1")
colnames(tabla) = c("Af", "Am", "As")
tabla
```

[^mma]: También se puede convertir un data frame o una matri en una tabla. Para ello, se puede utilizar la función **as.table()**

## TABLA DE FRECUENCIAS RELATIVAS EN R

La tabla creada con la función **table()** muestra la frecuencia absoluta conjunta de las variables. No obstante, puedes obtener la frecuencia relativa conjunta en R (como fracción de una tabla marginal) con la función **prop.table()**. Por defecto, la función calcula la proporción de cada celda con respecto al total de observaciones, por lo que la suma de las celdas es igual a 1.

```{r}
tabla_prop = prop.table(tabla)
tabla_prop
```

Sin embargo, el argumento **margin** permite seleccionar el índice (1: filas, 2: columnas) según el cual se van a calcular las proporciones.

Por una parte, si se establece **margin = 1**, la suma de cada fila será igual a 1.

```{r}
prop.table(tabla, margin = 1)
```

Por otra parte, si se establece **margin = 2**, la frecuencia relativa se calculará por columnas, por lo que cada columna sumará 1.

```{r}
tabla_2 = prop.table(tabla, margin = 2)
tabla_2 
```

Hay que tener en cuenta que también se pueden agregar los márgenes a una tabla de contingencia en R con la función **addmargins()**, para mostrar la frecuencia relativa acumulada (o la frecuencia absoluta acumulada, si se aplica a una tabla de frecuencias absoluta). En el siguiente ejemplo calculamos los márgenes de **tabla_prop**, expresando los datos como porcentaje.

```{r}
tabla_3 = addmargins(tabla_prop * 100)
tabla_3
```

## GRÁFICOS DE TABLAS DE CONTINGENCIA DE DOS ENTRADAS

Para dibujar una tabla en R, se pueden utilizar los gráficos de barras, que se pueden crear con la función **barplot()**. Hay dos tipos principales: agrupados y apilados. Por defecto, la función creará un diagrama de barras apiladas:

```{r}
# Dividimos la ventana gráfica en dos columnas
par(mfrow = c(1, 2))

colores = c("#80FFFF", "#FFFFFF")

barplot(tabla, col = colores)

# Añadimos una leyenda
legend("topleft", legend = c("No", "Si"), fill = colores)

barplot(tabla_2, col = colores)

# Volvemos a la ventana gráfica original
par(mfrow = c(1, 1))
```

Si se prefiere un gráfico de barras agrupadas, deberás establecer el argumento **beside** como **TRUE**:

```{r}
par(mfrow = c(1, 2))

barplot(tabla, col = colores, beside = TRUE)
legend("topleft", legend = c("No", "Si"), fill = colores)
barplot(tabla_2, col = colores, beside = TRUE)

par(mfrow = c(1, 1))
```

Una alternativa a los diagramas de barras son los gráficos de mosaico, que permiten mostrar dos o más variables categóricas. Este tipo de diagrama se puede crear en base R con la función **mosaicplot()** de la siguiente manera:[^lklk]

```{r}
par(mfrow = c(1, 2))

mosaicplot(tabla, cex = 1.1, col = 3:5)
mosaicplot(tabla_2, col = 3:5)

par(mfrow = c(1, 1))
```

[^lklk]: Si todos los cuadros en todas las categorías tienen la misma área estamos ante una señal de independencia.

## MEDIDAS DE ASOCIACIÓN EN R

Se puede comprobar que las variables son dependientes, si existe alguna relación entre ellas, o independientes en caso contrario. Para definir la confición de independencia, si $X$ es independiente de $Y$ se puede verificar para toodo: $i$:

\begin{equation}
\frac{n_{i1}}{n_{\bullet1}}=\frac{n_{i2}}{n_{\bullet2}}=\cdots=\frac{n_{ij}}{n_{\bullet j}}=\cdots=\frac{n_{ih}}{n_{\bullet h}} = \frac{n_{i\bullet}}{n}
\end{equation}

Lo anterior es equivalente a:

\begin{equation}
\frac{n_{ij}}{n}=\frac{n_{i\bullet}}{n}\frac{n_{\bullet j}}{n}; \: \forall i,j
\end{equation}

### COEFICIENTE CHI-CUADRADO EN R

Se puede verificar la independencia con la prueba de chi-cuadrado, comparando las frecuencias esperadas $e_{ij}$ con $n_{ij}$.La medida Chi-cuadrado es:

\begin{equation}
\chi^2=\Sigma_{ij}\frac{(n_{ij}-e_{ij})^2}{e_{ij}}
\end{equation}

Hay que tener en cuenta que esta variable proporciona, en términos relativos, la distancia entre la distribución conjunta de las variables del caso de independencia. Por lo tanto, **cuanto mayor sea el valor** de $\chi^2$, **mayor será la asociación** entre las variablees. Esta medida va de 0 (independencia) a $n(k-1)$, siendo $k$ el mínimo entre el número de filas y columnas.

Sin embargo, como esta métrica **no está acotada entre 0 y 1**, existen otras medidas de asociación, que se describen en las subsecciones siguientes.

Se puede obtener el coeficiente Chi-cuadrado en R con la función **chisq.test** como sigue:

```{r}
chi = chisq.test(tabla)
chi$statistic
```

### COEFICIENTE DE CONTINGENCIA

El coeficiente de contingencia C está limitado entre 0 (caso independencia) y 1. Se define como:

\begin{equation}
C=\sqrt{\frac{\chi^2}{\chi^2+n}}
\end{equation}

Para calcular el coeficiente de contingencia en R, se puede utilizar la siguiente función:

```{r}
# Se crea una función
Contingency = function(x) {
    chi = chisq.test(x)
    unname(sqrt(chi$statistic / (chi$statistic + sum(x))))
}

# Dentro de la función se pone el valor de tabla
Contingency(tabla)
```

Una alternativa es usar la función **ContCoef()** del paquete **DescTools**:

```{r}
# install.packages("DescTools")
library(DescTools)

ContCoef(tabla)
```

El valor máximo que puede tomar el coeficiente de contingencia es $\sqrt{(k-1)/k}$, por lo que el valor 1 nunca se alcanza para tablas cuadradas. Sea $k$ el número de filas y $h$ el número de columnas, algunos valores que puede tomar el coeficiente son:

|k=h|2|3|4|5|6|
|-------|-----|------|------|------|-----|
|max C|0.71|0.82|0.87|0.89|0.91|

### COEFICIENTES PHI Y V DE CRAMER

El coeficiente Phi se define como:

\begin{equation}
\phi=\sqrt{\frac{\chi^2}{n}}
\end{equation}

Hay que tener en cuenta que **toma valores entre 0 y 1 en las tablas 2x2**. Sin embargo, **puede tomar mayores que 1** entre otros casos. Para evitar este problema, **el coeficiente V de Cramer modifica el coeficiente Phi**, tomando la forma:

\begin{equation}
V=\sqrt{\frac{\chi^2}{[n(k-1)]}}
\end{equation}

Hay que recordar que $k$ es el mínimo entre el número de filas y de columnas. En R se puede utilizar las siguientes funciones para calcular estos coeficientes:

```{r}
# Coeficiente Phi
PhiCoef = function(x){
    unname(sqrt(chisq.test(x)$statistic / sum(x)))
}

# Coeficiente V de Cramer
V = function(x) {
    unname(sqrt(chisq.test(x)$statistic / (sum(x) * (min(dim(x)) - 1))))
}

PhiCoef(tabla)
V(tabla)
```

Una alternativa es usar las funciones **Phi()** y **CramerV** del paquete **DescTools**.

```{r}
# install.packages("DescTools")
library(DescTools)

Phi(tabla) # 0.4714045
CramerV(tabla) # 0.4714045
```

Como comentario final, cabe mencionar que se puede calcular varias medidas de asociación en R al mismo tiempo con la función **assocstats()** de la biblioteca **vcd**.

```{r}
# install.packages("vcd")
library(vcd)

assocstats(tabla)
```

\newpage

# CAPÍTULO 10

\newpage

## [**DISTRIBUCIÓN UNIFORME CONTINUA EN R**](https://r-coder.com/distribucion-uniforme-r/)

![](uniform-distribution-in-r.png)

La distribución uniforme es una distribución continua donde todos los intervalos de la misma longitud en el rango de la distribución acumulan la misma probabilidad.

## LA DISTRIBUCIÓN UNIFORME

Sea $X \sim U(a, b)$, es decir, una variable aleatoria con distribución uniforme en el intervalo $(a, b)$, con $a$, $b$ $\in \mathbb{R}$, $a<b$:

* La **función de densidad de probabilidad** (o PDF, por sus siglas en inglés) sw $x$ es $f(x)=\frac{1}{b-a}$ si $x \in(a, b)$ y $0$ en otro caso.
* La **función de distribución acumulada** (CDF) es $F(x)=P(X \leq x)=\frac{x-a}{b-a}$.
* La **función cuantil** es $Q(p)=F^{-1}(p)$.
* La **esperanza y la varianza** de $X$ son $E(X)=\frac{a+b}{2}$ y $Var(X)=\frac{(b-a)^2}{12}$.

Las diferentes funciones de la distribución uniforme se pueden calcular en R para cualquier valor de $x$. Estas funciones son: **dnorm()**, para la función de densidad, **pnorm()** para la distribución acumulada y **qnorm()**, para la función cuantil. Además, la función **rnorm()** permite obtener $n$ observaciones aleatorias de una distribución uniforme. Estas funciones se describen a continuación:

```{r echo=FALSE}
Función = c("dunif()",
            "punif()",
            "qunif()",
            "runif()")

Descripción = c("Densidad uniforme continua (Función de densidad de probabilidad)",
                "Distribución uniforme continua (Función de distribución)",
                "Función cuantil de la distribución uniforme",
                "Generación de números peudoaleatorios de la distribución uniforme continua")
df = data.frame(Función, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Descripción de las funciones de distribución Uniforme en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

Por defecto, estas funciones consideran la distribución uniforme en el intervalo (0, 1), también conocida como distribución uniforme estándar.

## LA FUNCIÓN **dunif()**

Para calcular la función de densidad uniforme en R en el intervalo $(a, b)$ para cualquier valor de $x$ se puede utilizar la función **dunif()**, que se tiene como la siguiente sintaxis:

```{r eval=FALSE}
# Sintaxis dunif
dunif(x,           # Valores del eje X (rejilla de valores)
      min = 0,     # Límite inferior de la distribución (a)
      max = 1,     # Límite superior de la distribución (b)
      log = FALSE) # Si TRUE, las probabilidades se devuelven como log
```

Se considera que se quiere calcular la función de densidad de probabilidad uniforme en el intervalo $(1, 3)$ para una rejilla de valores. Con tal propótido se puede escribir:

```{r}
x = 0:4 # Rejilla de valores
dunif(x, min = 1, max = 3)
```

### DIBUJAR LA FUNCIÓN DE DENSIDAD UNIFORME EN R

Se puede crear un gráfico de la  función de densidad de probabilidad en una distribución uniforme con la siguiente función:

```{r}
# Función para dibujar la función de densidad uniforme
# x: rejilla de valores del eje X (opcional)
# min: límite inferior de la distribución (a)
# max: límite superior de la distribución (b)
# lwd: ancho de los segmentos del gráfico
# col: color de los segmentos y de los puntos del gráfico
# ...: argumentos adicionales a ser pasados a la función plot
plotunif = function(x, min = 0, max = 1, lwd = 1, col = 1, ...) {

    # Rejilla de valores del eje X
    if (missing(x)) {
        x = seq(min - 0.5, max + 0.5, 0.01)
    }

    if(max < min) {
        stop("'min' must be lower than 'max'")
    }
   
    plot(x, dunif(x, min = min, max = max),
         xlim = c(min - 0.25, max + 0.25), type = "l",
         lty = 0, ylab = "f(x)", ...) 
    segments(min, 1/(max - min), max, 1/(max - min), col = col, lwd = lwd)
    segments(min - 2, 0, min, 0, lwd = lwd, col = col)
    segments(max, 0, max + 2, 0, lwd = lwd, col = col)
    points(min, 1/(max - min), pch = 19, col = col)
    points(max, 1/(max - min), pch = 19, col = col)
    segments(min, 0, min, 1/(max - min), lty = 2, col = col, lwd = lwd)
    segments(max, 0, max, 1/(max - min), lty = 2, col = col, lwd = lwd)
    points(0, min, pch = 21, col = col, bg = "white")
    points(max, min, pch = 21, col = col, bg = "white")
}
```


Como ejemplo, si se quiere dibujar la función de densidad uniforme estándar en color azul, se puede escribir:
 
```{r}
plotunif(min = 0, max = 1, lwd = 2, col = 4, main = "PDF uniforme")
```
 
## LA FUNCIÓN **punif()**
 
En R, se puede hacer uso de la función **punif()** para calcular la función de distribución acumulada uniforme, esto es, la probabilidad de que una variable $X$ tome valores menores o iguales a $x$. Esta función tiene la siguiente sintaxis:
 
```{r eval=FALSE}
# Sintaxis punif
punif(q,                  # Vector de cuantiles
      min = 0,            # Límite inferior de la distribución (a)
      max = 0,            # Límite superior de la distribución (b)
      lower.tail = TRUE,  # Si TRUE, las probabilidades son P(X <= x), o P(X > x) en otro caso
      log.p = FALSE)      # Si TRUE, las probabilidades se devuelven como log
```
 
Como ejemplo, si se quiere calcular la probabilidad de que una variable en el intervalo $(0, 1)$ tome valores menores o iguales que 0.6, es:
 
```{r}
punif(0.6) # 0.6
```
 
### EJEMPLO CON LA FUNCIÓN **punif()**
 
Un caso con mayor detalle. Se considera que $X$ es el tiempo (en minutos) que una persona tiene que esperar para tomar un vuelo. Si el vuelo despega cada hora $X \sim U(0, 60)$. Tomando lo anterior en cuenta:
 
* La probabilidad de **esperar menos de 15 minutos** es $P(X <15)=P(X)\leq15$:
 
```{r}
punif(15, min = 0, max = 60) # 0.25 o 25%
1 - punif(15, min = 0, max = 60, lower.tail = FALSE) # Equivalente
```
 
***Se ha creado la siguiente función para sombrear el área en un intervalo de la función de densidad de probabilidad uniforme con una sola línea de código:***

```{r}
# min: límite inferior de la distribución (a)
# max: límite superior de la distribución (b)
# lb: límite inferior del área
# ub: límite superior del área
# col: color de las líneas y puntos
# acolor: color del área
# ...: argumentos adicionales a ser pasados a la función plot
unif_area = function(min = 0, max = 1, lb, ub, col = 1,
                      acolor = "lightgray", ...) {
    x = seq(min - 0.25 * max, max + 0.25 * max, 0.001) 
    
    if (missing(lb)) {
       lb = min(x)
    }
    if (missing(ub)) {
        ub = max(x)
    }
    if(max < min) {
        stop("'min' must be lower than 'max'")
    }

    x2 = seq(lb, ub, length = 1000) 
    plot(x, dunif(x, min = min, max = max),
         xlim = c(min - 0.25 * max, max + 0.25 * max), type = "l",
         ylab = "f(x)", lty = 0, ...)   

    y = dunif(x2, min = min, max = max)
    polygon(c(lb, x2, ub), c(0, y, 0), col = acolor, lty = 0)
    segments(min, 1/(max - min), max, 1/(max - min), lwd = 2, col = col)
    segments(min - 2 * max, 0, min, 0, lwd = 2, col = col)
    segments(max, 0, max + 2 * max, 0, lwd = 2, col = col)
    points(min, 1/(max - min), pch = 19, col = col)
    points(max, 1/(max - min), pch = 19, col = col)
    segments(min, 0, min, 1/(max - min), lty = 2, col = col, lwd = 2)
    segments(max, 0, max, 1/(max - min), lty = 2, col = col, lwd = 2)
    points(0, min, pch = 21, col = col, bg = "white")
    points(max, min, pch = 21, col = col, bg = "white")
}
```

***A modo ilustrativo, si quieres dibujar el área entre 0 y 0.5 de una distribución uniforme en el intervalo*** $(0, 1)$, ***que se puede calcular con*** **punif(0.5)** ***se puede escribir:***

```{r}
unif_area(min = 0, max = 1, lb = 0, ub = 0.5,
          main = "punif(0.5)", acolor = "white")
```

La probabilidad calculada (0.25) corresponde al área:

```{r}
unif_area(min = 0, max = 60, lb = 0, ub = 15)
text(8, 0.008, "25%", srt = 90, cex = 1.2)
```

* La probabilidad de **esperar más de 45 minutos** por el vuelo es $P(X>45)=1-P(X \leq45)$:

```{r}
punif(45, min = 0, max = 60, lower.tail = FALSE) # 0.25 o 25%
1 - punif(45, min = 0, max = 60) # Equivalente
```

Que corresponde a:

```{r}
unif_area(min = 0, max = 60, lb = 45, ub = 60)
text(51, 0.008, "25%", srt = 90, cex = 1.2)
```

* La probabilidad de esperar **entre 20 y 30 minutos** a tomar el avión es $P(X \leq30)-P(X\leq20)$:

```{r}
punif(30, min = 0, max = 60) - punif(20, min = 0, max = 60) 
# 0.167 o 16.7%
```

La probabilidad calculada se puede representar con el siguiente gráfico:

```{r}
unif_area(min = 0, max = 60, lb = 20, ub = 30)
text(24, 0.008, "16.7%", srt = 90, cex = 1.2)
```

Como la distribución uniforme es continua $P(X=x)=0$, entonces $P(X\leq{x})=P(X>x)$ y $P(X\leq{x})=P(X<x)$.

### DIBUJAR LA FUNCIÓN DE DISTRIBUCIÓN ACUMULADA EEN R

También se puede crear un gráfico de la función de distribución acumulada de la distribución uniforme en R. para ello se tiene que escribir lo siguiente:

```{r}
# Función de distribución uniforme
# Rejilla de valores del eje X
x = seq(-0.5, 1.5, 0.01)

# Distribución uniforme entre 0 y 1
plot(x, punif(x, min = 0, max = 0), type = "l", main = "CDF uniforme",
     ylab = "F(x)", lwd = 2, col = "red")

# Equivalente a:
plot(punif, -0.5, 1.5, type = "l", main = "CDF uniforme",
     ylab = "F(x)", lwd = 2, col = "red")
```

## LA FUNCIÓN **qunif()**

En R, se puede calcular el ciantil correspondiente para una probabilidad (p) de una distribución uniforme con la función **qunif()**, que tiene la siguiente sintaxis:

```{r eval=FALSE}
qunif(p,                 # Vector de probabilidades
      min = 0,           # Límite inferior de la distribución (a)
      max = 1,           # Límite superior de la distribución (b)
      lower.tail = TRUE, # Si TRUE, las probabilidades son P(X <= x),
                         # o P(X > x) en otro caso
      log.p = FALSE)     # Si TRUE, las probabilidades se devuelven como log
```

En caso de querer calcular el cuantil para la probabilidad 0.5 de una distribución en el intervalo $(0, 60)$ se puede escribir:

```{r}
qunif(0.5, min = 0, max = 60) # 30
```

```{r}
unif_area(min = 0, max = 60, lb = 0, ub = 30)
text(15, 0.008, "50%", srt = 90, cex = 1.2)
arrows(38, 0.005, 31, 0.0005, length = 0.15)
text(44, 0.006, "qunif(0.5)")
```

### GRÁFICO DE LA FUNCIÓN CUANTIL UNIFORME

Es posible crear el gráfico de la función cuantil uniforme en R. Para ello se puede escribir lo siguiente para dibujar la función en el intervalo $(0, 1)$:

```{r}
# Función cuantil uniforme
plot(qunif, punif(0), punif(1), lwd = 2,
     main = "Función cuantil uniforme",
     xlab = "p", ylab = "Q(p)")
segments(0, 0.5, punif(0.5), 0.5, lty = 2, lwd = 2)
segments(punif(0.5), 0, punif(0.5), qunif(0.5), lty = 2, lwd = 2)
```

Recordando que **punif(0.5)= 0.5** y **qunif(0.5) = 0.5**

## LA FUNCIÓN **runif()**

La función **runif()** permite obtener $n$ observaciones aleatorias de una distribución uniforme. Los argumentos de la función se describenn a continuación:

```{r eval=FALSE}
runif(n        # Número de observaciones a ser generadas
      min = 0, # Límite inferior de la distribución (a)
      max = 0) # Límite superior de la distribución (b)
```

Como ejemplo, se puede obtener diez observaciones de una distribución uniforme en el intervalo $(-1,1)$ escribiendo:

```{r}
runif(n = 10, min = -1, max = 1)
```

Sin embargo, cada vez que se ejecute el código anterior se obtendrán diez números distintos. Si se quiere que la salida sea reproducible se puede fijar una semilla con la función **set.seed()**.

```{r}
set.seed(10)
runif(n = 10, min = -1, max = 1)
```

Se observa que a medida que se incrementa el número de observaciones generadas, el histograma de dichas observaciones se aproxima a la función de densidad uniforme real:

```{r}
# Una fila, tres columnas
par(mfrow = c(1, 3))

x = seq(-0.5, 1.5, 0.01)

set.seed(15)

# n = 10
hist(runif(10), main = "n = 100", xlim = c(-0.2, 1.25),
     xlab = "", prob = TRUE)
lines(x, dunif(x), col = "red", lwd = 2)

# n = 1000
hist(runif(1000), main = "n = 10000", xlim = c(-0.2, 1.25),
     xlab = "", prob = TRUE)
lines(x, dunif(x), col = "red", lwd = 2)

# n = 100000
hist(runif(100000), main = "n = 1000000", xlim = c(-0.2, 1.25),
     xlab = "", prob = TRUE)
lines(x, dunif(x), col = "red", lwd = 2)

# Volvemos a una fila y una columna
par(mfrow = c(1, 1))
```

\newpage

# CAPÍTULO 11

\newpage

## [**DISTRIBUCIÓN DE POISSON EN R**](https://r-coder.com/distribucion-poisson-r/)

![](poisson-distribution-r.png)

La distribución de Poisson es una distribución discreta que cuenta el número de eventos en un proceso de Poisson.

## LA DISTRIBUCIÓN DE POISSON

Un **proceso de Poisson** es un experimento aleatorio que consiste en observar la ocurrencia de eventos específicos sobre un soporte continuo (generalmente el espacio o el tiempo), tal que el proceso es estable (el número de ocurrencias, $\lambda$ es constante a largo plazo) y los eventos ocurren de forma aleatoria e independiente.

La **distribución de Poisson** se usa para modelar el número de eventos que ocurren en un proceso de Poisson. Sea $X \sim P(\lambda)$, esto es, una variable aleatoria con distribución de Poisson donde el número medio de eventos que ocurren en un determinado intervalo es $\lambda$:

* La **función de masa de probabilidad** (o PMF, por sus siglas en inglés) es $P(X=x)=\frac{e^{-\lambda}\lambda^{x}}{x!}$ para $x=0, 1, 2, \cdots, n$.
* La **función de distribución** (o CFD, por sis siglas en inglés) es $F(x)=\Sigma^{x}_{i=0}\frac{e^{-\lambda}\lambda^{x}}{x!}$.
* La **función cuantil** es $Q(p)=F^{-1}(p)$.
* La **esperanza y varianza** de $X$ son $E(X)= Var(X)=\lambda$.

Las funciones descritas en la lista enterior se pueden calcular en R para un conjunto de valores con las funciones **dpois()** (masa de probabilidad), **ppois()** (distribución) y **qpois()** (cuantil). Además, la función **rpois()** permite obtener $n$ observaciones aleatorias que siguen una distribución de Poisson. La tabla de abajo describe brevemente cada una de estas funciones.

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Función = c("dpois()",
            "ppois()",
            "qpois()",
            "rpois()")

Descripción = c("Función de masa de probabilidad de la distribución de Poisson",
                "Función de distribución acumulada de la distribución de Poisson",
                "Función cuantil de la distribución de Poisson",
                "Generación de números pseudoaleatorios de la distribución de Poisson")
df = data.frame(Función, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Descripción de las funciones de distribución de Poisson en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

## LA FUNCIÓN **dpois()**

La función de masa de probabilidad de una distribución de Poisson de media $\lambda$ se puede calcular en R con la función  **dpois()** para cualquier valor de $x$. El siguiente es un bloque de código que resume los argumentos de la función:

```{r, eval=FALSE}
# Sintaxis de la función dpois()
dpois(x,           # Valores del eje X (x = 0, 1, 2, ...)
      lambda,      # Número medio de eventos que ocurren en el intervalo
      log = FALSE) # Si TRUE, las probabilidades se devuelven como log
```

Como ejemplo, si quieres calcular la función de masa de probabilidad de una distribución de Poisson con media 5 para $x \in \{0, 1, 2, \cdots, 10 \}$, se puede escribir como:

```{r}
dpois(0:10, lambda = 5)
```

También se puede especificar un vector de medias en lugar de un único valor, como en el siguiente bloque de código:

```{r}
dpois(5, lambda = c(5, 10)) # 0.17546737 0.03783327
```

En el ejemplo anterior, el primer elemento de la salida procede de una distribución con media $\lambda=5$ y el segundo de una distribución con media $\lambda=10$ eventos por intervalo.

### GRÁFICO DE LA FUNCIÓN DE PROBABILIDAD DE LA DISTRIBUCIÓN DE POISSON EN R

La función de masa de probabilidad de la Poisson se puede dibujar en R haciendo uso de la función **plot()**, como el siguiente ejemplo:

```{r}
# Rejilla de valores del eje X
x = 0:50

#-----------
# lambda: 5
#-----------
lambda = 5
plot(dpois(x, lambda), type = "h", lwd = 2,
     main = "Función de masa de probabilidad",
     ylab = "P(X = x)", xlab = "Número de eventos")

#-----------
# lambda: 10
#-----------
lambda = 10
lines(dpois(x, lambda), type = "h", lwd = 2, col = rgb(1,0,0, 0.7))

#-----------
# lambda: 20
#-----------
lambda = 20
lines(dpois(x, lambda), type = "h", lwd = 2, col = rgb(0, 1, 0, 0.7))

# Leyenda
legend("topright", legend = c("5", "10", "20"),
       title = expression(lambda), title.adj = 0.75,
       lty = 1, col = 1:3, lwd = 2, box.lty = 0)
```

## LA FUNCIÓN **ppois()**

La probabilidad de que una variable $X$ siguiendo una distribución de Poisson tome valores menores o iguales a $x$ se puede calcular con la función **ppois()**, cuyos argumentos se describen a continuación:

```{r, eval=FALSE}
# Sintaxis de la función ppois()
ppois(q,                 # Cuantil o vector de cuantiles
      lambda,            # Media o vector de medias
      lower.tail = TRUE, # Si TRUE, las probabilidades son P(X <= x),
                         # o P(X > x) en otro caso
      log.p = FALSE)     # Si TRUE, las probabilidades se devuelven como log
```

Si se quiere calcular, por ejemplo, la probabilidad de observar 5 o menos eventos $P(X \leq{5})$ si la media de ocurrencia de los eventos en un intervalo específico es 1', se puede escribir:

```{r}
ppois(5, lambda = 10) # 0.06708596
```

Este ejemplo, el anterior resultado es equivalente a la suma de las probabilidades de cada valor hasta 5:

```{r}
sum(dpois(0:5, lambda = 10)) # 0.06708596
```

### EJEMPLO CON LA FUNCIÓN **ppois()**

En esta sección se presenta un ejemplo en detalle usando la función **ppois()**. Considerando que el número de visitas a una página web sigue una distribución de Poisson con media 15 visitas por hora. Por lo tanto $\lambda=15$.

* La probabilidad de **obtener 10 visitas o menos por hora**, es:

```{r, eval=FALSE}
ppois(10, lambda = 15) # 0.1184644 o 11.8%
1 - ppois(10, lambda = 15, lower.tail = FALSE) # Equivalente
sum(dpois(0:10, lambda = 15)) # Equivalente
```

Como la distribución de Poisson es discreta, la probabilidad acumulada se calcula sumando las correspondintes probabilidades de la función de masa de probabilidad. La siguiente función de R permite visualizar las probabilidades que se suman basadas en un límite inferior y uno superior.

```{r}
# lambda: media
# lb: límite inferior de la suma
# ub: límite supeior de la suma
# col: color
# lwd: ancho de línea
pois_sum = function(lambda, lb, ub, col = 4, lwd = 1, ...) {
    x = 0:(lambda + lambda * 2)
    
    if (missing(lb)) {
       lb = min(x)
    }
    if (missing(ub)) {
        ub = max(x)
    }
      
    plot(dpois(x, lambda = lambda), type = "h", lwd = lwd, ...)
  
    if(lb == min(x) & ub == max(x)) {
        color = col
    } else {
        color = rep(1, length(x))
        color[(lb + 1):ub ] = col
    }
    
    lines(dpois(x, lambda = lambda), type = "h",
          col =  color, lwd = lwd, ...)
}
```

A modo ilustrativo, si se quiere mostrar las probabilidades que se van a sumar para calcular la probabilidad de observar entre 10 y 15 eventos, si ocurren 10 eventos de media en cada intervalo, puedes escribir:

```{r}
 pois_sum(lambda = 10, lb = 10, ub = 15, lwd = 2,
           col = 2, ylab = "P(X = x)", xlab = "Número de eventos")
```

La suma de las probabilidades mostradas en rojo es igual a **ppois(15, lambda = 10) - ppois(10, lambda = 10)**.

La probabilidad calculada (11.8%) corresponde a la suma de las siguientes probabilidades:

```{r}
pois_sum(lambda = 15, ub = 10, lwd = 2,
         ylab = "P(X = x)", xlab = "Visitas por hora")
```

* La probabilidad de **obtener más de 20 visitas por hora**, $P(X>20)$, es:

```{r, eval=FALSE}
ppois(20, lambda = 15, lower.tail = FALSE) # 0.08297091 o 8.3%
1 - ppois(20, lambda = 15)        # Equivalente
1 - sum(dpois(0:20, lambda = 15)) # Equivalente
```

Esta probabilidad corresponde a:

```{r}
pois_sum(lambda = 15, lb = 20, lwd = 2,
         ylab = "P(X = x)", xlab = "Visitas por hora")
```

* La probabilidad de **recibir menos de 15 visitas por hora**, $P(X<15)$ es:

```{r, eval=FALSE}
ppois(14, lambda = 15, lower.tail = FALSE) # 0.5343463 o 53.43%
1 - sum(dpois(0:15, lambda = 15)) # Equivalente
```

Hay que tener en cuenta que se establece 14 en lugar de 15 porque la distribución de Poisson es discreta, por lo que $P(X<15)=P(X\leq14)$. El gráfico correspondiente es como sigue:

```{r}
pois_sum(lambda = 15, ub = 14, lwd = 2,
         ylab = "P(X = x)", xlab = "Visitas por hora")
```

* La probabilidad de **obtener entre 10 y 20 visitas por hora** es:

```{r, eval=FALSE}
ppois(20, lambda = 15) - ppois(10, lambda = 15) # 0.7985647 o 79.86%
sum(dpois(11:20, lambda = 15)) # Equivalente
```

La probabilidad se puede representar haciendo uso de la función que definimos antes:

```{r}
pois_sum(lambda = 15, lb = 10, ub = 20, lwd = 2,
         ylab = "P(X = x)", xlab = "Visitas por hora")
```

Como la distribución de Poisson es una distribución discreta $P(X=x)\neq0$, por lo que $P(X\geq{x})\neq{P}(X<x)$.

### GRÁFICO DE LA FUNCIÓN DE DISTRIBUCI´N DE POISSON EN R

La función de distribución acumulada de una distribución de Poisson se puede representar para diferentes valores de $\lambda$ con el siguiente bloque de código:

```{r}
# Rejilla de valores del eje X
x = 0:50

#-----------
# lambda: 5
#-----------
lambda = 5
plot(ppois(x, lambda), type = "s", lwd = 2,
     main = "Función de distribución",
     xlab = "Número de eventos", ylab = "F(x)")

#-----------
# lambda: 10
#-----------
lambda = 10
lines(ppois(x, lambda), type = "s", lwd = 2, col = 2)

#-----------
# lambda: 20
#-----------
lambda = 20
lines(ppois(x, lambda), type = "s", lwd = 2, col = 3)

# Legend
legend("bottomright", legend = c("5", "10", "20"),
       title = expression(lambda), title.adj = 0.75,
       lty = 1, col = 1:3, lwd = 2, box.lty = 0)
```

## LA FUNCIÓN **qpois()**

La función **qpois()** permite obtener los cuantiles correspondientes de la distribución de Poisson para un conjunto de probabilidades.

```{r, eval=FALSE}
# Sintaxis de la función qpois()
qpois(p,                 # Probabilidad o vector de probabilidades
      lambda,            # Media o vector de medias
      lower.tail = TRUE, # Si TRUE, las probabilidades son P(X <= x), o P(X > x) en otro caso
      log.p = FALSE)     # Si TRUE, las probabilidades se devuelven como log
```

Por ejemplo, el cuantil 0.5 de una distribución de Poisson es igual a la media:

```{r}
qpois(0.5, lambda = 10) # 10
```

### GRÁFICO DE LA FUNCIÓN CUANTIL DE LA DISTRIBUCIÓN DE POISSON

Las funciones cuantil de la distribución de Poisson se pueden dibujar en R para un conjunto de probabilidades. El siguiente gráfico muestra los salidas de la función **qpois()** para diferentes medias.

```{r}
#-----------
# lambda: 20
#-----------
plot(qpois(seq(0, 1, 0.001), lambda = 20),
     main = "Función cuantil",
     ylab = "Q(p)", xlab = "p",
     type = "s", col = 3, xaxt = "n")

axis(1, labels = seq(0, 1, 0.1), at = 0:10 * 100)

#-----------
# lambda: 10
#-----------
lines(qpois(seq(0, 1, 0.001), lambda = 10), type = "s", col = 2)

#-----------
# lambda: 5
#-----------
lines(qpois(seq(0, 1, 0.001), lambda = 5), type = "s")

# Legend
legend("topleft", legend = c("5", "10", "20"),
       title = expression(lambda), title.adj = 0.75,
       lty = 1, col = 1:3, lwd = 2, box.lty = 0)
```

## LA FUNCIÓN **rpois()**

Si se quiere obtener $n$ observaciones de una distribución de Poisson puedes hacer uso de la función **rpois()**. El siguiente bloque de código resume los argumentos de la función.

```{r, eval=FALSE}
# Sintaxis de la función rpois()
rpois(n,      # Número de observaciones a ser generadas
      lambda) # Media o vector de medias
```

Si se quiere obtener 10 observaciones aleatorias de una distribución de Poisson con media 4 puedes escribir:

```{r}
rpois(10, lambda = 4)
```

Sin embargo, la salida anterior no será reproducible. En caso de que se quiera generar una secuencia reproducible de números puedes fijar una semilla con cualquier número entero de la siguiente manera:

```{r}
set.seed(20)
rpois(10, lambda = 4)
```

\newpage

# CAPÍTULO 12

\newpage

## [**DISTRIBUCIÓN BINOMIAL EN R**](https://r-coder.com/distribucion-binomial-r/)

![](binomial-distribution-r.png)

La distribución binomial es una distribución discreta que cuenta el número de éxitos en $n$ experimentos o ensayos de Bernoulli.

## LA DISTRIBUCIÓN BINOMIAL

Un **proceso de Bernoulli** es la repetición de un experimento aleatorio (un ensayo de Bernoulli) donde cada observación independiente se clasifica como éxito, si el evento ocurre, o como fracaso en otro escenario y la proporción de éxitos en la población es constante y no depende de su tamaño.

Sea $X \sim{B(n,p)}$, es decir, una variable aleatoria que sigue una **distribución binomal**, donde $n$ el número de ensayos de Bernoulli, $p$ la probabilidad de éxito y $q=1-p$ la probabilidad de fracaso:

* La **función de masa de probabilidad** es $P(X=x)= \begin{pmatrix} n \\ x \end{pmatrix}p^{x}q^{n-x}$ si $x=0,1,2, \cdots,  n$.
* La **función de distribución acumulada** (o CFD, por sus siglas en inglés) es $F(x)=I_{q}(1-x, n-x)$.
* La **función cuantil** es $Q(p)=F^{-1}(p)$.
* La **esperanza y la varianza** de $X$ son $E(X)=np$ y $Var(X)=npq$, respectivamente.

Las funciones de la lista anterior se pueden calcular en R para  un conjunto de valores con las funciones **dbinom()** (probabilidad), **pbinom()** (distribución) y **qbinom()** (cuantil). Además de estas tres funciones, la función **rbinom()** permite obtener $n$ observaciones aleatorias que siguen una distribución binomial en R. La siguiente es una tabla que describe en breve dichas funciones.

```{r}
Función = c("dbinom()",
            "pbinom()",
            "qbinom()",
            "rbinom()")
Descripción = c("Función de masa de probabilidad Binomial (Función de probabilidad)",
                "Distribución binomial
(Función de distribución acumulada)",
                "Función cuantil binomial",
                "Generación de números
pseudoaleatorios binomiales")

df = data.frame(Función, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Descripción de las funciones de distribución Binomial en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

## LA FUNCIÓN **dbinom()**

Para calcular la función de probabilidad binomial para un conjunto de valores, $x$, un número de ensayos $n$ y una probabilidad de éxito $p$ se puede hacer uso de la función **dbinom()**, que tiene la siguiente sintaxis:

```{r, eval=FALSE}
# Sintaxis función dbinom()
dbinom(x,           # Valores del eje X (x = 0, 1, 2, ..., n)
       size,        # Número de ensayos (n > = 0)
       prob,        # Probabilidad de éxito en cada ensayo
       log = FALSE) # Si TRUE, las probabilidades se devuelven
                    # como log
```

Si se quiere calcular, por ejemplo, la función de masa de probabilidad binomial para $x=1,2, \cdots, 10$ y probabilidad de éxito en cada ensayo de 0.2, se puede escribir:

```{r}
dbinom(x = 1:10,
       size = 10,
       prob = 0.2)
```

### GRÁFICO DE LA FUNCIÓN DE PROBABILIDAD BINOMIAL EN R

La función de masa de probabilidad binomial se puede dibujar en R haciendo uso de la función **plot()**, pasanddo la salida de la función **dbinom()** para un conjunto de valores al primer argumento de la función y estableciendo **type = "h"** como sigue:

```{r}
# Rejilla de valores del eje X
x = 1:100

# n = 100, p = 0.2
plot(dbinom(x, size = 100, prob = 0.2), type = "h", lwd = 2,
     main = "Función de probabilidad binomial",
     ylab = "P(X = x)", xlab = "Número de éxitos")

# n = 100, p = 0.3
lines(dbinom(x, size = 100, prob = 0.3), type = "h",
      lwd = 2, col = rgb(1,0,0, 0.7))

# n = 100, p = 0.4
lines(dbinom(x, size = 100, prob = 0.4), type = "h",
      lwd = 2, col = rgb(0, 1, 0, 0.7))

# Añadimos una leyenda
legend("topright", legend = c("100  0.2", "100  0.3", "100  0.4"),
       title = "n     p", title.adj = 0.85,
       lty = 1, col = 1:3, lwd = 2, box.lty = 0)
```

## LA FUNCIÓN **pbinom()**

Para calcular la probabilidad de que una variable $X$ que sigue una distribución binomial tome valores menores o iguales a $x$ se puede hacer uso de la función **pbinom()**, cuyos argumento se describen a continuación:

```{r, eval=FALSE}
# Sintaxis función pbinom()
pbinom(q,                 # Cuantil o vector de cuantiles
       size,              # Número de experimentos (n > = 0)
       prob,              # Probabilidad de éxito en cada experimento
       lower.tail = TRUE, # Si TRUE, las probabilidades son P(X <= x), o P(X > x) en otro caso
       log.p = FALSE)     # Si TRUE, las probabilidades se 
                          # devuelven como log
```

A modo ilustrativo, la probabilidad de que el éxito oocurra menos de 3 veces si el número de ensayos es 10 y la probabilidad de éxito por ensayo es 0.3 es:

```{r}
sum(dbinom(0:3, size = 10, prob = 0.3)) # 0.6496107 o 64.96%
```

Como la distribución binomial es discreta, la probabilidad acumulada también se puede calcular como la suma de las correspodientes probabilidades de la función de probabilidad. La siguiente función de R permite visualizar las probabilidades que se suman basándose en un límite inferior y un límite superior de la función de probabilidad.

```{r}
# size: número de ensayos (n > = 0)
# prob: probabilidad de éxito en cada ensayo
# lb: límite inferior de la suma
# ub: límite superior de la suma
# col: color
# lwd: ancho de línea
binom_sum = function(size, prob, lb, ub, col = 4, lwd = 1, ...) {
    x = 0:size
    
    if (missing(lb)) {
       lb = min(x)
    }
    if (missing(ub)) {
        ub = max(x)
    }
      
    plot(dbinom(x, size = size, prob = prob), type = "h", lwd = lwd, ...)
  
    if(lb == min(x) & ub == max(x)) {
        color = col
    } else {
        color = rep(1, length(x))
        color[(lb + 1):ub ] = col
    }
    
    lines(dbinom(x, size = size, prob = prob), type = "h",
          col =  color, lwd = lwd, ...)
}
```

Como ejemplo se puede representar las probabilidades que van a ser sumadas para calcular la probabilidad de que una variable binomial tome valores menores o iguales que 5 si el número de ensayos es 20 y la probabilidad de éxito es 0.2 con el siguiente código:

```{r}
binom_sum(size = 20, prob = 0.2, lwd = 2, col = 2, ub = 5,
          ylab = "P(X = x)", xlab = "Número de éxitos")
```

La suma de las probabilidades mostradas en rojo es igual a **pbinom(5, size = 20, prob = 0.2)**.

### EJEMPO CON LA FUNCIÓN **pbinom()**

En esta parte se va a revisar con más detalle la función **pbinom()** con un ejemplo completo para entender cómo calcular probabilidades binomiales en varios escenarios. Considera que un jugador de baloncesto encesta 4 de cada 10 tiros $(p=0.4)$. Si el jugador tira 20 veces a canasta (20 ensayos):

* La probabilidad de encestar **6 canastas o menos**, $P(X \leq{6})$, es:

```{r, eval=FALSE}
pbinom(6, size = 20, prob = 0.4) # 0.2500107 o 25%
1 - pbinom(6, size = 20, prob = 0.4, lower.tail = FALSE) # Equivalente
```

Esta probabilidad también se puede calcular sumando los correspodientes elementos de la función de probabilidad binomial, tal y como explicamos en la sección anterior:

```{r, eval=FALSE}
sum(dbinom(0:6, size = 20, prob = 0.4)) # 0.2500107 o 25%
```

Usando la función que se definió antes, se puede representar la probabilidad calculada:

```{r}
binom_sum(size = 20, prob = 0.4, ub = 6, lwd = 2,
          ylab = "P(X = x)", xlab = "Número de éxitos")
```

*  Ña probabilidad de **anotar menos de 6 canastas**, $P(X<6)$, es:

```{r, eval=FALSE}
pbinom(5, size = 20, prob = 0.4) # 0.125599 o 12.56%
1 - pbinom(5, size = 20, prob = 0.4, lower.tail = FALSE) # Equivalente
sum(dbinom(0:5, size = 20, prob = 0.4)) # Equivalente
```

Hay que tener en cuenta que se pasó un 5 al primer argumento de la función en lugar de un 6 porque se está ante una distribución discreta, por lo que $P(X<6)=P(X \leq5)$. La probabilidad calculada se puede representar con la suma de las siguientes probabilidades de la función de masa de probabilidad:

```{r}
binom_sum(size = 20, prob = 0.4, ub = 5, lwd = 2,
          ylab = "P(X = x)", xlab = "Número de éxitos")
```

* La probabilidad de **anotar más de 12 canastas**, $P(X>12)$, es:

```{r, eval=FALSE}
pbinom(12, size = 20, prob = 0.4, lower.tail = FALSE) # 0.02102893 
                                                      # o 2.1%
1 - pbinom(12, size = 20, prob = 0.4)     # Equivalente
sum(dbinom(13:20, size = 20, prob = 0.4)) # Equivalente
```

Esta probabilidad corresponde a:

```{r}
binom_sum(size = 20, prob = 0.4, lb = 12, lwd = 2,
          ylab = "P(X = x)", xlab = "Número de éxitos")
```

* La probabilidad de **anotar entre 7 y 11 tiros**. $P(7 \leq{X} \leq{11})$, es:

```{r, eval=FALSE}
pbinom(11, size = 20, prob = 0.4) - pbinom(7, size = 20, prob = 0.4) 
# 0.5275807 o 52.8%
sum(dbinom(8:11, size = 20, prob = 0.4)) # Equivalente
```

El gráfico correspondiente se puede crear con el siguiente código:

```{r}
binom_sum(size = 20, prob = 0.4, lb = 7, ub = 11, lwd = 2,
          ylab = "P(X = x)", xlab = "Número de éxitos")
```

Como la distribución binomial es una distribución discreta $P(X=x)\neq0$, por lo que $P(x\geq{x})\neq{P}(X>x)$ y $P(X\leq{x})\neq{P(X<x)}$.

### GRÁFICO DE LA FUNCIÓN DE DISTRIBUCIÓN BINOMIAL ACUMULADA EN R

La función de distribución binomial se puede dibujar en R con la función **plot()**, estableciendo el argumento **type = "s"** y pasando la salida de la función **pbinom()** para un número específico de experimentos y una probabilidad de éxito.

El siguiente bloque de código se puede utilizar para dibujar el gráfico de la función de distribución acumulada para 80 ensayos de Bernoulli y diferentes probabilidades.

```{r}
# Rejilla de valores del eje X
x = 1:80

# n = 80, p = 0.2
plot(pbinom(x, size = 80, prob = 0.2), type = "s", lwd = 2,
     main = "Función de distribución binomial",
     xlab = "Número de éxitos", ylab = "F(x)")

# n = 80, p = 0.3
lines(pbinom(x, size = 80, prob = 0.3), type = "s",
      lwd = 2, col = 2)

# n = 80, p = 0.4
lines(pbinom(x, size = 80, prob = 0.4), type = "s",
      lwd = 2, col = 3)

# Añadimos una leyenda
legend("bottomright", legend = c("80  0.2", "80  0.3", "80  0.4"),
       title = "n     p", title.adj = 0.85,
       lty = 1, col = 1:3, lwd = 2, box.lty = 0)
```

## LA FUNCIÓN **qbinom()**

Dada una probabilidad o un conjunto de probabilidades, la función **qbinom()** permite obtener el cuantil binomial correspondiente. El siguiente bloque de código describe brevemente los argumentos de la función:

```{r, eval=FALSE}
# Sintaxis función qbinom()
qbinom(p,                 # Probabilidad o vector de probabilidades
       size,              # Número de ensayos (n > = 0)
       prob,              # Probabilidad de éxito en cada ensayo
       lower.tail = TRUE, # Si TRUE, las probabilidades son P(X <= x),
                          # o P(X > x) en otro caso
       log.p = FALSE)     # Si TRUE, las probabilidades se devuelven 
                          #  como log
```

Como ejemplo, el cuantil binomial para la probabilidad 0.4 si $n=5$ y $p=0.7$ es:

```{r}
qbinom(p = 0.4,
       size = 5,
       prob = 0.7) # 3
```

### GRÁFICO DE LA FUNCIÓN CUANTIL BINOMIAL EN R

La función cuantil binomial se puede dibujar en R para un conjunto de probabilidades, un número de ensayos y una probabilidad de éxito en cada ensayo con el siguiente código:

```{r}
# Rejilla de valores del eje X
x = 1:80

# size = 80, prob = 0.2
plot(qbinom(seq(0, 1, 0.001), size = 80, prob = 0.2),
     main = "Función binomial cuantil",
     ylab = "Q(p)", xlab = "p",
     type = "s", col = 3, xaxt = "n")
axis(1, labels = seq(0, 1, 0.1), at = 0:10 * 100)

# size = 80, prob = 0.3
lines(qbinom(seq(0, 1, 0.001), size = 80, prob = 0.3), type = "s", col = 2)

# size = 80, prob = 0.4
lines(qbinom(seq(0, 1, 0.001), size = 80, prob = 0.4), type = "s", col = 1)

# Añadimos una leyenda
legend("topleft", legend = c("80  0.2", "80  0.3", "80  0.4"),
       title = "n     p", title.adj = 0.85,
       lty = 1, col = 1:3, lwd = 2, box.lty = 0)
```

## LA FUNCIÓN **rbinom()**

Con el objetivo de obtener $n$ observaciones aleatorias de una distribución binomial en R se puede utilizar la función **rbinom()**. Los argumentos de la función se describen a continuación:

```{r, eval=FALSE}
# Sintaxis función rbinom()
rbinom(n,    # Número de observaciones aleatorias a ser generadas
       size, # Número de ensayos (> = 0)
       prob) # La probabilidad de éxito en cada ensayo
```

Si se quiere obtener, por ejemplo, 50 observaciones aleatorias de una distribución binomial si el número de ensayos es 100 y la probabilidad de éxito es de 0.6, se puede escribir:

```{r}
rbinom(n = 50,
       size = 100,
       prob = 0.6)
```

Sin embargo, si no especificamos una semilla antes de ejecutrar la función se obtendrá un conjunto de observaciones diferente cada vez. Si se quiere que la salida sea reproducible se puede establecer la semilla como sigue:

```{r}
set.seed(3)
rbinom(n = 50, size = 100, prob = 0.6)
```

\newpage

# CAPÍTULO 13

\newpage

## [**DISTRIBUCIÓN EXPONENCIAL EN R**](https://r-coder.com/distribucion-exponencial-r/)

![](exponential-distribution-r-1.png)

La distribución exponencial es una distribución de probabilidad continua que se utiliza para modelar el tiempo o espacio entre eventos en un proceso de Poisson.

## LA DISTRIBUCIÓN EXPONENCIAL

La distribución exponencial es la distribución de probabilidad del tiempo o espacio entre dos eventos en un proceso de Poisson, donde los eventos ocurren de manera continua e independiente a una tasa constante $\lambda$.

Como en toda distribución, es importante conocer su función de densidad de probabilidad, su función de distribución y su función cuantil. Sea $X \sim{Exp(\lambda)}$, es decir, una variable aleatoria con distribución exponencial de parámetro $\lambda$:

* La **función de densidad** (o PDF, por sus siglas en inglés) de $x$ es $f(x)=\lambda{e^{-\lambda{x}}}$ si $x\geq{0}$ o $0$ en otro caso.
* La **función de distribución** acumulada (o CDF, por sus siglas en inglés) es $F(x)=P(X\leq{x})=1-e^{-\lambda{x}}$ si $x\geq{0}$ o $0$ en otro caso.
* La **función cuantil** es $Q(p)=F^{-1}(p)=\frac{-ln(1-p)}{\lambda}$.
* La **esperanza y la varianza** de $X$ son $E(X)=\frac{1}{\lambda}$ y $Var(X)=\frac{1}{\lambda^{2}}$.

En R, las funciones anteriores se pueden calcular con las funciones **dexp()**, **pexp()**, y **qexp()**. Además, la función **rexp()** permite obtener observaciones aleatorias siguiendo una distribución exponencial. Las funciones se describen en la siguiente tabla:

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Función = c("dexp()",
            "pexp()",
            "qexp()",
            "rexp()")
Descripción = c("Densidad exponencial
(Función de densidad de probabilidad)",
                "Distribución exponencial
(Función de distribución acumulada)",
                "Función cuantil de la distribución exponencial",
                "Generación de números
pseudoaleatorios exponenciales")

df = data.frame(Función, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Descripción de las funciones de distribución Exponencias en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

Por defecto, estas funciones consideran la distribución exponencial con parámetro $\lambda=1$.

Aunque veremos cómo utilizar cada función en su correspondiente sección, puedes ver la relación entre las tres primeras funciones en el siguiente gráfico para $\lambda=1$:

![](dexp-pexp-qexp-r1.png)

## LA FUNCIÓN **dexp()**

La función en R para calcular la función de densidad de probabilidad exponencial de $\lambda$ para cualquier valor de $x$ es la función **dexp()**, que se describe a continuación:


```{r, eval=FALSE}
# Sintaxis de la función dexp()
dexp(x,           # Valores del eje X (> 0)
     rate = 1,    # Vector de parámetros (lambdas)
     log = FALSE) # Si TRUE, las probabilidades vienen dadas como
                  # logaritmo
```

Como ejemplo, si se quiere calcular la función de densidad exponencial de parámetro 2 en R para una serie de valores, puedes escribir:

```{r, eval=FALSE}
# Rejilla de valores
x = seq(from = 0, to = 8, by = 0.01)

# PDF exponencial de parámetro lambda = 2
dexp(x, rate = 2)
```

Sin embargo, hay que recordar que **el parámetro no es el valor esperado**, por lo tanto, si quieres calcular, por ejemplo, una distribución exponencial en R con media 10, deberás calcular el parámetro correspondiente:

```{r, eval=FALSE}
# Función de densidad exponencial con media 10
dexp(x, rate = 0.1) # E(X) = 1/lambda = 1/0.1 = 10
```

### DIBUJAR LA DENSIDAD EXPONENCIAL EN R

COn la salida de la función **dexp()** se puede dibujar la densidad de una distribución exponencial. Para ello, se debe pasar la rejilla del eje X como primer argumento de la función **plot()** y la función **dexp()** como segundo argumento. En el siguiente bloque de código mostramos cómo crear las funciones de densidad para $\lambda = 1$ y $\lambda = 2$.

```{r}
# Función de densidad exponencial
# Rejilla del eje X
x <- seq(0, 8, 0.1)

# lambda = 2
plot(x, dexp(x, 2), type = "l",
     ylab = "f(x)", lwd = 2, col = "red")
# lambda = 1
lines(x, dexp(x, rate = 1), col = "blue", lty = 1, lwd = 2)

# Agregamos una leyenda
legend("topright", c(expression(paste( , lambda)), "2", "1"),
       lty = c(0, 1, 1), col = c("blue", "red"), box.lty = 0, 
       lwd = 2)
```

## LA FUNCIÓN **pexp()**

La función de R que permite calcular la probabilidad de que una variable aleatoria exponencial $X$ tome valores menores o iguales que $x$ es la función **pexp()**, que tiene la siguiente sintaxis:

```{r, eval=FALSE}
# Sintaxis de la función pexp()
pexp(q,                 
     rate = 1,
     lower.tail = TRUE, # Si TRUE, las probabilidades son 
                        # P(X <= x), o P(X > x) en otro caso
     log.p = FALSE)
```

Por ejemplo, la probabilidad de que la variable (con $\lambda=1$) tome un valor menor o igual a 2 es 0.8646647:

```{r, eval=FALSE}
pexp(2) # 0.8646647
```

### EJEMPLO CON **pexp()**: CALCULANDO PROBABILIDADES EXPONENCIALES

Se sabe que el tiempo en una página web sigue una distribución exponencial con una media de 5 minutos por visita. En consecuencia, como $E(X)=\frac{1}{\lambda}$; $5=\frac{1}{\lambda}$; $\lambda=0.2$.

```{r, eval=FALSE}
pexp(3, rate = 0.2) # 0.4511884 o 45.12%
1 - pexp(3, rate = 0.2, lower.tail = FALSE) # Equivalente
```

Para dibujar el área bajo una curva exponencial con una sola línea de código, se puede utilizar la siguiente función que hemos desarrollado:

```{r}
# rate: parámetro lambda
# lb: límite inferior del área
# ub: límite superior del área
# acolor: color del área
# ...: argumentos adicionales a ser pasados a la función lines
exp_area = function(rate = 1, lb, ub, acolor = "lightgray", ...) {
    x = seq(0, 12/rate, 0.01) 
    
    if (missing(lb)) {
       lb = min(x)
    }
    if (missing(ub)) {
        ub = max(x)
    }

    x2 = seq(lb, ub, length = 100)    
    plot(x, dexp(x, rate = rate), type = "n", ylab = "")
   
    y = dexp(x2, rate = rate)
    polygon(c(lb, x2, ub), c(0, y, 0), col = acolor)
    lines(x, dexp(x, rate = rate), type = "l", ...)
}
```

Como ejemplo, se puede trazar el área bajo una curva exponencial de parámetro 0.5 entre 0.5 y 5 con el siguiente código:

```{r}
exp_area(rate = 0.5, lb = 0.5, ub = 5, acolor = "#4EE58E")
```

La probabilidad calculada (45.12%) corresponde a el área:

```{r}
exp_area(rate = 0.2, ub = 3, acolor = rgb(0, 0, 1, alpha = 0.5))
text(1, 0.075, "45.12%", srt = 90, col = "red", cex = 1.2)
```

En segundo lugar, si quieres calcular la probabilidad de que la visita dure más de 10 minutos, se puede escribir:

```{r}
pexp(10, rate = 0.2, lower.tail = FALSE) # 0.1353353 o 13.53%
```

El área que corresponde a la probabilidad anterior se puede dibujar con el siguiente código:

```{r}
exp_area(rate = 0.2, lb = 10, acolor = rgb(0, 0, 1, alpha = 0.5))
arrows(8, 0.1, 11, 0.015, length = 0.1, lwd = 2)
text(8, 0.12, "13.53%", cex = 1.2)
```

Finalmente, la probabilidad de que la visita dure entre 2 y 6 minutos es:

```{r}
pexp(6, rate = 0.2) - pexp(2, rate = 0.2) # 0.3691258 o 36.91%
```

El gráfico correspondiente es el que sigue:

```{r}
exp_area(rate = 0.2, lb = 2, ub = 6, acolor = rgb(0, 0, 1, 
                                                  alpha = 0.5))
text(4, 0.05, "36.91%", col = "red", cex = 1.2)
```

Como la distribución exponencial es una distribución continua $P(X=x)=0$, por lo que $P(X\geq{x})=P(X>x)$ y $P(X\leq{x})=P(X<x)$.

### GRÁFICO DE LA FUNCIÓN DE DISTRIBUCIÓN EXPONENCIAL ACUMULADA EN R

Se puede trazar la función de distribución exponencial acumulada pasando la rejilla de valores como primer argumento de la función **plot()** y la salida de la función **pexp()** como el segundo. Con el siguiente código dibujamos las funciones de distribución para parámetros 1 y 2.

```{r}
# Función de distribución exponencial
# Rejilla de valores del eje X
x = seq(0, 12, 0.1)

# lambda = 2
plot(x, pexp(x, 2), type = "l",
     ylab = "F(x)", lwd = 2, col = "red")
# lambda = 1
lines(x, pexp(x, rate = 1), col = "blue", lty = 1, lwd = 2)

# Añadimos una leyenda
legend("topright", c(expression(paste( , lambda)), "1", "2"),
       lty = c(0, 1, 1), col = c("red", "blue"), box.lty = 0, 
       lwd = 2)
```

Hay que recordar que **pexp(2)** era igual a 0.8646647. En el siguiente gráfico se puede ver la relación entre la distribución y la función de densidad exponencial.

```{r}
par(mfrow = c(1, 2))

#-------------------------------------
# Función de distribución
#-------------------------------------
plot(x, pexp(x), type = "l", ylab = "F(x)", col = "blue", lwd = 2)
segments(2, 0, 2, pexp(2), lwd = 2, lty = 2)
segments(0, pexp(2), 2, pexp(2), lwd = 2, lty = 2)

#-------------------------------------
# Función de densidad de probabilidad
#-------------------------------------
exp_area(rate = 1, ub = 2, acolor = rgb(1, 0, 1, alpha = 0.1)) 
text(1, 0.1, "86.47%") # Texto

par(mfrow = c(1, 1))
```

## LA FUNCIÓN **qexp()**

La función **qexp()** permite calcular el cuantil correspondiente para cualquier probabilidad $p$:

```{r, eval=FALSE}
# Sintaxis función qexp()
qexp(q,                 
     rate = 1,
     lower.tail = TRUE, # Si TRUE, las probabilidades son 
                        # P(X <= x), o P(X > x) en otro caso
     log.p = FALSE)
```

Como ejemplo, se quiere calcular el cuantil para la probabilidad 0.8646647 $Q(0.86)$, se puede escribir:

```{r, eval=FALSE}
qexp(0.8646647) # 2
qexp(1 - 0.8646647, lower.tail = FALSE) # Equivalente
```

```{r}
exp_area(rate = 1, ub = 2, acolor = rgb(0, 0, 1, alpha = 0.5))
points(2, 0, pch = 19)
arrows(4, 0.4, 2.2, 0.02, length = 0.1)
text(7.5, 0.5, "qexp(0.8646647) = 2", cex = 1.2)
```

Hay que recordar que **pexp(2)** era 0.8646647.

Se establece el argumento **lower.tail = FALSE** si se quiere ver que la probabilidad esté en la cola derecha.

### DIBUJAR LA FUNCIÓN CUANTIL EXPONENCIAL

Se puede hacer un gráfico de la función cuantílica exponencial, que muestra los posibles resultados de la función **qexp()**, con el código del siguiente bloque:

```{r}
# Función cuantil exponencial
plot(qexp, pexp(0), pexp(8), lwd = 2, xlab = "p", ylab = "Q(p)")
segments(0, 2, pexp(2), 2, lty = 2, lwd = 2)
segments(pexp(2), 0, pexp(2), qexp(0.8646647), lty = 2, lwd = 2)
```

Hay que recordar que **pexp(2)** es 0.8647 y que **qexp(0.8647)** es 2.

## LA FUNCIÓN **rexp()**

La función **rexp()** permite obtener $n$ observaciones de una distribución exponencial. La sintaxis de la función es la siguiente:

```{r, eval=FALSE}
# Sintaxis función rexp()
rexp(n, # Número de observaciones a ser generadas
     rate = 1) 
```

Como ejemplo, si se desea extraer diez observaciones de una distribución exponencial del parámetro 1, se puede escribir:

```{r}
rexp(10)
```

Sin embargo, si se quiere que la salida sea reproducible, se deberá establecer una semilla para el generador de números pseoudoaleatorios de R:

```{r}
set.seed(12)
rexp(10)
```

Se puede comprobar que a medida que aumenta el número de observaciones, el histograma de los datos se aproximan a la función de densidad exponencial real:

```{r}
# Dividimos la ventana gráfica en tres columnas
par(mfrow = c(1, 3))

# Rejilla de valores del eje X
x = seq(0, 12, length = 200)

# Fijamos semilla
set.seed(1)

# n = 10
hist(rexp(10), main = "n = 10",
     xlab = "", prob = TRUE)
lines(x, dexp(x), col = "red", lwd = 2)

# n = 100
hist(rexp(100), main = "n = 100",
     xlab = "", prob = TRUE)
lines(x, dexp(x), col = "red", lwd = 2)

# n = 1000
hist(rexp(1000), main = "n = 1000",
     xlab = "", prob = TRUE)
lines(x, dexp(x), col = "red", lwd = 2)

# Volvemos a la ventana gráfica original
par(mfrow = c(1, 1))
```

\newpage

# CAPÍTULO 14

\newpage

## [**DISTRIBUCIÓN NORMAL EN R**](https://r-coder.com/distribucion-normal-r/)

![](normal-distribution-r.png)

La distribución normal o gaussiana es la distribución más conocida e importante en Estadística.

## LA DISTRIBUCIÓN GAUSSIANA

Entre las variables aleatorias continuas, la más importante es la distribución normal o gaussiana. Esta variable fue introducida por Carl Friedrich en el siglo XIX para estudiar las medidas de error.

Sea $X \sim N(\mu, \sigma)$, es decir, una variable aleatoria con distribución normal de media $\mu$ y desviación típica $\sigma$:

* La **función de densidad** (o PDF, por sus siglas en inglés), también conocida como campana de Gauss, de $x$ es $f(x)=\frac{1}{\sqrt{2\pi\sigma^{2}}}e^{\frac{1}{2}(\frac{x-\mu}{\sigma})^2}$.
* La **función de distribución** acumulada (o CDF, por sus siglas en inglés) es $F(x)=P(X\leq{x})$.
La **función cuantil** es $Q(p)=F^{-1}(p)$.
* La **esperanza y la varianza** es $E(X)=\mu$ y $Var(X)=\sigma^{2}$, respectivamente.


En R existen las funciones **dnorm()**, **pnorm()** y **qnorm()**, que permiten calcular la función de densidad, la de distribución y la cuantil normal para una serie de valores. Además, la función **rnorm()** permite obtener observaciones aleatorias siguiendo una distribución normal. Las funciones relacionadas con la distribución normal se describen en la siguiente tabla:

```{r}
Función = c("dnorm()",
            "pnorm()",
            "qnorm()",
            "rnorm()")
Descripción = c("Densidad normal
(Función de densidad de probabilidad)",
                "Distribución normal
(Función de distribución acumulada)",
                "Función cuantil de la distribución normal",
                "Generación de números
pseudoaleatorios normales")

df = data.frame(Función, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Descripción de las funciones de distribución Normal en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

Por defecto, estas funciones consideran la distribución normal estándar, que tiene media 0 y desviación típica 1.

Aunque se tratará en detalle cada función en su correspondiente sección, en la siguiente ilustración puedes ver la relación entre las funciones **dnorm()**, **pnorm()** y **qnorm()**:

![](dnorm-pnorm-qnorm-functions.png)

## LA FUNCIÓN **dnorm()**

En R, se puede hacer uso de la función **dnorm()** para calcular la función de densidad normal de parámetros $\mu$ y $\sigma$ para cualquier valor de $x$.

```{r, eval=FALSE}
# Sintaxis de la función dnorm()
dnorm(x,           # Valores del eje X (rejilla)
      mean = 0,    # Número o vector representando la/s media/s
      sd = 1,      # Número o vector representando la/s desviación/es típica/s
      log = FALSE) # Si TRUE, las probabilidades se devuelven como logaritmos
```

Se considera, como ejemplo, que se quiere crear la función de densidad de probabilidad normal para $x \in(-4, 4)$, con media 1 y desviación típica de 3. Para calcularla, se puede escribir:

```{r}
x = -4:4
# x <- seq(-4, 4, length = 100) # Más observaciones
dnorm(x, mean = 1, sd = 3) 
```

### DIBUJAR LA DISTRIBUCIÓN NORMAL EN R

Crear un gráfico de distribución normal en R es fácil. Solo se necesita crear una rejilla (grid) para el eje X para el primer argumento de la función **plot()** y pasar como entrada del segundo la función **dnorm()** para la rejilla correspondiente. En el siguiente ejemplo mostramos cómo dibujar distribuciones normales para diferentes medias y varianzas.

```{r}
par(mfrow = c(1, 2))

# Rejilla de valores para el eje X
x = seq(-4, 8, 0.1)

#-----------------------------------------
# Misma desviación típica, distinta media
#-----------------------------------------
# Media 0, desviación típica 1
plot(x, dnorm(x, mean = 0, sd = 1), type = "l",
     ylim = c(0, 0.6), ylab = "", lwd = 2, col = "red")
# Media 3, desviación típica 1
lines(x, dnorm(x, mean = 3, sd = 1), col = "blue", lty = 1, lwd = 2)

# Añadimos una leyenda
legend("topright", c(expression(paste( , mu, " ", sigma)),
                     "0 1", "3 1"),
       lty = c(0, 1, 1), col = c("blue", "red"), box.lty = 0,
       lwd = 2)

#-----------------------------------------
# Misma media, distinta desviación típica
#-----------------------------------------
# Media 1, desviación típica 1
plot(x, dnorm(x, mean = 1, sd = 1), type = "l",
     ylim = c(0, 1), ylab = "", lwd = 2, col = "red")
# Media 1, desviación típica 0.5
lines(x, dnorm(x, mean = 1, sd = 0.5), col = "blue", lty = 1,
      lwd = 2)

# Añadimos una leyenda
legend("topright", c(expression(paste(, mu, " ", sigma)),
                     "1 1", "1 0.5"),
       lty = c(0, 1, 1), col = c("blue", "red"), box.lty = 0,
       lwd = 2)

par(mfrow = c(1, 1))
```

## LA FUNCIÓN **pnorm()**

La función **pnorm()** permite calcular la **función de distribución acumulada** (CDF, por sus siglas en inglés) de la distribución normal en R, que es la probabilidad que la variable $X$ tome valores menores o iguales que $x$. La sintaxis de la función es la siguiente:

```{r, eval=FALSE}
# Sintaxis de la función pnorm()
pnorm(q,
      mean = 0,
      sd = 1,
      lower.tail = TRUE, # Si TRUE, las probabilidades son 
                         # P(X <= x), o P(X > x) si FALSE
      log.p = FALSE)     # Si TRUE, las probabilidades vienen 
                         # dadas como logaritmos
```

Como ejemplo, teniendo en cuenta que la distribución normal es simétrica, la probabilidad de que la variable tome un valor inferior a la media es 0.5:

```{r}
pnorm(0, mean = 0, sd = 1) # 0.5
```

### EJEMPLO DE LA FUNCIÓN **pnorm()**

Ahora, se supone que se tiene una máquina que empaqueta arroz dentro de cajas. El proceso sigue una distribución normal y se sabe que la media del peso de cada caja es de 1000 gramos y la desviación típica es 10 gramos. Puedes dibujar la función de densidad normal en R escribiendo:

```{r}
# Media y desviación típica
mu = 1000
sigma = 10

# Grid para una distribución normal no estándar
x = seq(-3, 3, length = 100) * sigma + mu

# Función de densidad
f = dnorm(x, mu, sigma)

plot(x, f, type = "l", lwd = 2, col = "blue", ylab = "", xlab = "Weight")
abline(v = mu) # Línea vertical en la media
```

Primero, si se quiere calcular la **probabilidad de que una caja pese menos de 1010 gramos**, $P(X<1010)=P(X\leq1010)$, se puede escribir lo que sigue:

```{r, eval=FALSE}
pnorm(1010, mu, sigma) # 0.8413447 o 84.13%
1 - pnorm(1010, mu, sigma, lower.tail = FALSE) # Equivalente
```

Por lo que la probabilidad de que la caja pese menos de 1010 gramos es 0.8413 o 84.13%, que corresponde a el área de la siguiente ilustración:

```{r}
lb = min(x) # Límite inferior
ub = 1010   # Límite superior

x2 = seq(min(x), ub, length = 100) # Nueva rejilla
y = dnorm(x2, mu, sigma) # Densidad

plot(x, f, type = "l", lwd = 2, col = "blue", ylab = "", xlab = "Peso")
abline(v = ub) 

polygon(c(lb, x2, ub), c(0, y, 0), col = rgb(0, 0, 1, alpha = 0.5))
text(995, 0.01, "84.13%")
```

Como sombrear el área debajo de la curva normal puede ser complicado y requiere varias líneas de código, se ha creado una función muy sencilla para lograrlo en una sola línea:

```{r}
# mean: media de la variable normal
# sd: desviación típica de la variable normal
# lb: límite inferior del área
# ub: límite superior del área
# acolor: color del área
# ...: argumentos adicionales para ser pasados a la función lines

normal_area = function(mean = 0, sd = 1, lb, ub, 
                        acolor = "lightgray", ...) {
    x <- seq(mean - 3 * sd, mean + 3 * sd, length = 100) 
    
    if (missing(lb)) {
       lb = min(x)
    }
    if (missing(ub)) {
        ub = max(x)
    }

    x2 = seq(lb, ub, length = 100)    
    plot(x, dnorm(x, mean, sd), type = "n", ylab = "")
   
    y = dnorm(x2, mean, sd)
    polygon(c(lb, x2, ub), c(0, y, 0), col = acolor)
    lines(x, dnorm(x, mean, sd), type = "l", ...)
}
```

Como ejemplo, si se quiere sombrear el área entre -1 y 2 de una distribución normal estándar se puede escribir:

```{r}
normal_area(mean = 0, sd = 1, lb = -1, ub = 2, lwd = 2, 
            acolor = "#4EE58E")
```

Segundo, en caso de que se quiera calcular la **probabilidad de que una caja pese más de 980 gramos**, $P(X>980)=P(X\geq{980})$, se puede usar el argumento **lower.tail**:

```{r, eval=FALSE}
pnorm(980, mu, sigma, lower.tail = FALSE) # 0.9772499 o 97.72%
1 - pnorm(980, mu, sigma) # Equivalente
pnorm(1020, mu, sigma)    # Equivalente por simetría
```

La probabilidad calculada corresponde al área:

```{r}
normal_area(mean = mu, sd = sigma, lb = 980, acolor = 
              rgb(0, 0, 1, alpha = 0.5))
text(1000, 0.01, "97.72%")
```

Pr último, si se quiere calcular la **probabilidad de que una caja pese más de 990 gramos y menos de 1000** se tiene que calcular $P(X\leq{1000})-P(x\leq{990})=P(X<1000)-P(x<990)$ y por tanto se puede ejecutar:

```{r, eval=FALSE}
pnorm(1000, mu, sigma) - pnorm(990, mu, sigma) # 0.3413447 o 34.13%
```

Se puede dibujar el área con el siguiente código:

```{r}
normal_area(mean = mu, sd = sigma, lb = 990, ub = 1000,
            acolor = rgb(0, 0, 1, alpha = 0.5))
text(995, 0.01, "34.13%", srt = 90)
```

Para variables que son continuas, como $P(X=x)=0, P(X\geq{x})=P(X>z)$ y $P(x\leq{x})=P(X<x)$.

### GRAFICAR LA FUNCIÓN DE DISTRIBUCIÓN NORMAL ACUMULADA EN R

Con la función **pnorm()** también se puede dibujar la función de densidad acumulada de la distribución normal en R:

```{r}
par(mfrow = c(1, 2))

# Rejilla de valores para el eje X
x = seq(-4, 8, 0.1)

#-----------------------------------------
# Misma desviación típica, distinta media
#-----------------------------------------
# Media 0, desviación típica 1
plot(x, pnorm(x, mean = 0, sd = 1), type = "l",
     ylim = c(0, 1), ylab = "", lwd = 2, col = "red")
# Media 3, desviación típica 1
lines(x, pnorm(x, mean = 3, sd = 1), col = "blue", lty = 1,
      lwd = 2)

# Leyenda
legend("topleft", c(expression(paste(, mu, " ", sigma)),
                    "0 1", "3 1"),
       lty = c(0, 1, 1), col = c("blue", "red"),
       box.lty = 0, lwd = 2)

#-----------------------------------------
# Misma media, distinta desviación típica
#-----------------------------------------
# Media 1, desviación típica 1
plot(x, pnorm(x, mean = 1, sd = 1), type = "l",
     ylim = c(0, 1), ylab = "", lwd = 2, col = "red")
# Media 0, desviación típica 0.5
lines(x, pnorm(x, mean = 1, sd = 0.5), col = "blue", lty = 1, lwd = 2)

# Leyenda
legend("topleft", c(expression(paste(, mu, " ", sigma)), "1 1", "1 0.5"),
       lty = c(0, 1, 1), col = c("blue", "red"), box.lty = 0, lwd = 2)

par(mfrow = c(1, 1))
```

Hay que recordar que $P(X<0)=0.5$ para una distribución normal estándar:

```{r}
x = seq(-4, 4, 0.1)
plot(x, pnorm(x, mean = 0, sd = 1), type = "l",
     ylim = c(0, 1), ylab = "P(X < x)", lwd = 2, col = "red")
segments(0, 0, 0, 0.5, lwd = 2, lty = 2)
segments(-4, 0.5, 0, 0.5, lwd = 2, lty = 2)
```

## LA FUNCIÓN **qnorm()**

La función **qnorm()** permite encontrar el cuantil (percenti) $Q$ para cualquier probabilidad $p$.

En consecuencia, la función **qnorm()** es la inversa de la función **pnorm()**. La sintaxis de la función **qnorm()** es como sigue a continuación:

```{r, eval=FALSE}
# Sintaxis de la función qnorm()
qnorm(p,                 # Número o vector de probabilidades
      mean = 0,          # Número o vector representando 
                         # la/s media/s
      sd = 1,            # Número o vector representando 
                         # la/s desviación/es típica/s
      lower.tail = TRUE, # Si TRUE, las probabilidades son 
                         # P(X <= x), o P(X > x) si FALSE
      log.p = FALSE)     # Si TRUE, las probabilidades vienen dadas                          # como logaritmos
```

Como primer ejemplo, el cuantil para la probabilidad 0.5, $Q(0.5)$, en una distribución simétrica es igual a la media:

```{r, eval=FALSE}
qnorm(0.5, mean = 0, sd = 1) # 0
```

Además, se puede obtener el cuantil para la probabilidad dada. Nótese la relación entre las funciones **pnorm()** y **qnorm()**:

```{r}
x = pnorm(-1.5, mean = 0, sd = 1) # 0.0668072
qnorm(x, mean = 0, sd = 1) # -1.5

normal_area(mean = 0, sd = 1, ub = -1.5,
            lwd = 2, acolor = rgb(0, 0, 1, alpha = 0.5))
arrows(-0.5, 0.1, -1.45, 0, lwd = 2, length = 0.2)
text(-0.25, 0.13, "-1.5", cex = 1.5)
```

Si se quiere calcular, por ejemplo, el cuantil $Q(P(X>1.5))=Q(1-P(X\leq{1.5}))=Q(0.067)$, se puede establecer el argumento **lower.tail** de la función como **TRUE**:

```{r, eval=FALSE}
x = pnorm(1.5, mean = 0, sd = 1, lower.tail = FALSE) # 0.0668072
qnorm(x, mean = 0, sd = 1, lower.tail = FALSE) # 1.5

# Equivalente a:
# x = 1- pnorm(1.5, mean = 0, sd = 1) 
# qnorm(1 - x, mean = 0, sd = 1)
```


```{r}
normal_area(mean = 0, sd = 1, lb = 1.5, lwd = 2,
            acolor = rgb(0, 0, 1, alpha = 0.5))
arrows(0, 0.1, 1.45, 0, lwd = 2, length = 0.2)
text(0, 0.13, "1.5", cex = 1.5)
```

### DIBUJAR LA FUNCIÓN CUANTIL NORMAL

Se puede dibujar la función cuantil de una distribución normal estándar escribiendo lo siguiente:

```{r}
plot(qnorm, pnorm(-4), pnorm(4), lwd = 2, xlab = "p",
     ylab = "Q(p)")

# Equivalente a:
# x = seq(pnorm(-4), pnorm(4), length = 100)
# plot(x, qnorm(x, mean = 0, sd = 1), type = "l",
#      lwd = 2, xlab = "p", ylab = "Q(p)")
```

La gráfica anterior representa los posibles resultados de la función **qnorm()** para la distribución normal estándar. Recordemos que $Q(0.5)=0$:

```{r}
plot(qnorm, pnorm(-4), pnorm(4), lwd = 2,
     xlab = "p", ylab = "Q(p)")
segments(0.5, -4, 0.5, 0, lty = 2, lwd = 2)
segments(0, 0, 0.5, 0, lty = 2, lwd = 2)
```

## LA FUNCIÓN **rnomr()**

La función **rnorm()** genera $n$ observaciones de la distribución normal con media $\mu$ y desviación típica $\sigma$. La sintaxis de la función **rnomr()** en R es la siguiente:

```{r, eval=FALSE}
# Sintaxis de la función rnorm()
rnorm(n,        # Número de observaciones a ser generadas
      mean = 0, # Número o vector representando la/s media/s
      sd = 1)   # Número o vector representando la/s desviación/es típica/s
```

Por lo tanto, se puede generar 10 observaciones de una distribución estándar en R con el siguiente código:

```{r}
rnorm(10)
```

Sin embargo, se debe de tener en cuenta que si no se especifica una semilla, la salida no será reproducible. Puede utilizarse la función **set.seed()** para hacer que la salida sea reproducible:

```{r}
# Semilla para reproducibilidad
set.seed(80)

rnorm(1) # -0.1519526
```

Además, en la siguiente ráfica e puede observar cómo al aumentar el número de observaciones, los histogramas de los datos se acercan a la función de densidad normal real:

```{r}
# Dividimos la ventana gráfica en una fila y tres columnas
par(mfrow = c(1, 3))

x <- seq(-10, 10, length = 200)

# Semilla
set.seed(50)

# n = 10
hist(rnorm(10, mean = 0, sd = 1), main = "n = 10",
     xlab = "", prob = TRUE)
lines(x, dnorm(x), col = "red", lwd = 2)

# n = 100
hist(rnorm(100, mean = 0, sd = 1), main = "n = 100",
     xlab = "", prob = TRUE)
lines(x, dnorm(x), col = "red", lwd = 2)

# n = 1000
hist(rnorm(1000, mean = 0, sd = 1), main = "n = 1000",
     xlab = "", prob = TRUE)
lines(x, dnorm(x), col = "red", lwd = 2)

# Volvemos a la ventana original
par(mfrow = c(1, 1))
```

\newpage

# CAPÍTULO 15

\newpage

## [**FUNCIÓN plot() EN R**](https://r-coder.com/plot-en-r/)

![](plot-r.png)

La función gráfica más básica en R es la función **plot()**. Esta función tiene múltiples argumentos para configurar el gráfico final, que permiten agregar un título, cambiar las etiquetas de los ejes, personalizar colores, cambiar tipos de línea, etc. 

## FUNCIÓN **plot()** EN R

La función **plot()** en R permite **crear un gráfico** pasando dos vectores (de la misma longitud), un data frame, una matriz o incluso otros objetos, dependiendo de su clase o tipo de los datos de entrada. A continuaación se simulará dos variables normales aleatorias llamadas **x** e **y**, usando en gran parte de estos ejemplo:

```{r}
# Datos de ejemplo
set.seed(33) # Se fija una semilla para que los datos no
            # sean aleatorios.

# Generamos datos de ejemplo
x = rnorm(350)
y = x + rnorm(350)
```

Se pueden dibujar los datos creados escribiendo:

```{r}
# Dibujamos los datos
plot(x, y)

# Equivalente
M = cbind(x, y)
plot(M)
```

Con la función **plot()** se puede crear una **amplia gama de gráficos, dependiendo de los argumentos de entrada**. En la siguiente tabla se resume toddas las posibilidades disponibles para la función **plot()** de R base.

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Función = c("plot(x, y)",
            "plot(factor)",
            "plot(factor, y)",
            "plot(serie_temporal)",
            "plot(data_frame)",
            "plot(fecha, y)",
            "plot(función, inferior, superior)")
Descripción = c("Diagrama de dispersión de
los vectores numéricos x e y",
            "Gráfico de barras del factor",
            "Diagrama de caja del vector
numérico y los niveles del factor",
            "Gráfico de una serie de tiempo
(clase ts)",
            "Gráfico de correlación
de todas las columnas
del data frame",
            "Traza un vector basado en fechas",
            "Traza la función entre el valor
inferior y máximo especificado")

df = data.frame(Función, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Descripción de las funciones plot() en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

Si se ejecuta el siguiente código, se obtendrán ejemplos de los diferentes tipos de gráficos:

```{r}
# Ejemplos

par(mfrow = c(2, 3))

# Datos
mi_ts = ts(matrix(rnorm(500), nrow = 500, ncol = 1),
              start = c(1950, 1), frequency = 12)

mis_fechas = seq(as.Date("2005/1/1"), by = "month", length = 50)

mi_factor = factor(mtcars$cyl)

fun = function(x) x^2

# Diagrama de dispersión
plot(x, y, main = "Gráfico de dispersión")

# Gráfico de barras
plot(mi_factor, main = "Diagrama de barras")

# Diagrama de cajas
plot(mi_factor, rnorm(32), main = "Diagrama de cajas y bigotes")

# Gráfico de una serie temporal
plot(mi_ts, main = "Serie temporal")

# Time-based plot
plot(mis_fechas, rnorm(50), main = "Gráfico basado en fechas")

# Dibujar una función
plot(fun, 0, 10, main = "Trazar una función")

# Gráfico de correlación
plot(trees[, 1:3], main = "Matriz de correlación")

par(mfrow = c(1, 1))
```

**Cuando se crean varios gráficos en R base (no en R Studio), el siguiente gráfico borrará el anetrior**. Sin embargo, se pueden crear nuevas ventanas gráficas con las funciones **windows()**, **X11()** y **quartz()** según tu sistema operativo, para resolver este problema.

## VENTANAS GRÁFICAS

Al crear gráficos en R base, se abrirán en una nueva ventana. Sin embargo, es posible que necesites personalizar la altura y el ancho de la ventana, que por defecto es de 7 pulgadas. Para ese propósito, se puede utilizar los argumentos **height** y **width** de las siguientes funciones, dependiendo de tu sistema operativo.

Cabe destacar que en R Studio el gráfico se mostrará en el panel de gráficos, pero si utilizas la función correspondiente, el gráfico se abrirá en una nueva ventana, al igual que en R base.

```{r, eval=FALSE}
windows() # Windows
X11()     # Unix
quartz()  # Mac
```

Además de poder abrir y establecer el tamaño de la ventana, estas funciones se usan para evitar sobrescribir gráficos, ya que al crear uno nuevo perderás el anterior. Hay que tener en cuenta que en RStudio puedes navegar por todas los gráficos que hayas creado en tu sesión en el panel de gráficos:

```{r, eval=FALSE}
# Este gráfico se 
# abrirá en una ventana nueva
plot(x, y)

# Nueva ventana
windows()

# Otro gráfico en la nueva ventana
plot(x, x)
```

También se puede **limpiar la ventana gráfica en R** con la función **dev.off()**, para borrar la ventana actual y **graphics.off()** para borrar todas las gráficas y restablecer la configuración gráfica predeterminada.

```{r, eval=FALSE}
# Borrar el plot actual
dev.off()

# Borrar todos los gráficos
graphics.off()
while (dev.cur() > 1) dev.off() # Equivalente
```
Nótese que la función **dev.cur()** cuenta el número de dispositivos gráficos disponibles actualmente.


## TIPOS DE **plot()** EN R

Se puede **personalizar el tipo de gráfico** con el argumento **type**. **La selección del tipo dependerá de los datos que se esté representando**. En el siguiente bloque de código mostramos los tipos de gráficos más comunes que se pueden crear con la función **plot()** en R.

```{r}
j = 1:20
k = j

par(mfrow = c(2, 3))

plot(j, k, type = "l", main = "type = 'l'")
plot(j, k, type = "s", main = "type = 's'")
plot(j, k, type = "p", main = "type = 'p'")
plot(j, k, type = "l", main = "type = 'l'")
plot(j, k, type = "s", main = "type = 's'")
plot(j, k, type = "p", main = "type = 'p'")

par(mfrow = c(1, 1))
```

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Función = c("p",
            "l",
            "b",
            "o",
            "s",
            "h",
            "n")
Descripción = c("Gráfico de puntos
(por defecto)",
                "Gráfico de líneas",
                "Ambos
(puntos y líneas, separados)",
                "Ambos
(líneas y por encima puntos)",
                "Gráfico de escaleras",
                "Gráfico estilo histograma",
                "Gráfico vacío")

df = data.frame(Función, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Descripción del tipo de plot() en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

## EL ARGUMENTO **pch =**

El argumento **pch =** permite **modificar el símbolo de los puntos en el gráfico**. Los símbolos principales se pueden seleccionar pasando los **números 1 a 25** como parámetros. También se **puede cambiar el tamaño de los símbolos** con el argumento **cex =** y el **ancho de los bordes de los símbolos** (excepto los símbolos 15 a 18) con el argumento **lwd =**.

```{r}
r = c(sapply(seq(5, 25, 5), function(i) rep(i, 5)))
t = rep(seq(25, 5, -5), 5)

plot(r, t, pch = 1:25, cex = 2, yaxt = "n", xaxt = "n",
     ann = FALSE, xlim = c(3, 27), lwd = 1:3)
text(r - 1.5, t, 1:25)
```

Además, **los símbolos 21 a 25 permiten establecer el ancho del borde y también el color de fondo**, con los argumentos **lwd =** y **bg =**, respectivamente.

```{r}
plot(r, t, pch = 21:25, cex = 3, yaxt = "n", xaxt = "n", lwd = 3,
     ann = FALSE, xlim = c(3, 27), bg = 1:25, col = rainbow(25))
```

El siguiente bloque de código muestra un ejemplo simple de cómo personalizar uno de estos símbolos.

```{r}
# Ejemplo

plot(x, y, pch = 21,
     bg = "#F1948A",   # Color de fondo
     col = "#154360", # Color del borde
     cex = 3,      # Tamaño del símbolo
     lwd = 3)      # Ancho del borde
```

## TÍTULO DEL **plot()** EN E

Se puede agregar un título a un **plot()** en R con el argumento **main =** o con la función **title()**.

```{r}
plot(x, y, main = "Mi título")

# Equivalente
plot(x, y)
title("Mi título")
```

La principal diferencia entre usar la función **title()** o el argumento es que **los argumentos que se pasan a la función solo afectan al título**.

Para cambiar la posición del título del gráfico se puede establecer el argumento **adj** como un valor entre 0 (izquierda total) y 1 (derecha total) y el argumento **line** como un valor por encima de 1.7 (valor predeterminado) para mover el título hacia arriba o un valor por debajo de 1.7 para moverlo hacia abajo. Valores negativos de **line** hacen que el título se desplace hacia abajo, entrando dentro del gráfico. Nótese que si estableces estos argumentos en la función **plot()**, los cambios se aplicarán a todos los textos.

```{r}
plot(x, y)
title("Mi título",
      adj = 0.85,  # Título a la derecha
      line = 0.25)
```

## TÍTULO EN LATEX

Es muy común para los científicos de datos la necesidad de **mostrar expresiones matemáticas en el título de los gráficos**. Para ese propósito se puede usar la función **expression()**. Puedes buscar todas las opciones disponibles para utilizar la notación matemática similar a LaTeX con el siguiente comando de ayuda: **?plotmath**.

```{r}
plot(x, y, main = expression(rho[1] ^ 2 + frac(phi, 3)))
```

Sin embargo, se verá que la sintaxis de la función es bastante diferente que la sintaxis de LaTeX. Si es de preferencia, se puede usar la función **TeX()** del paquete **latex2exp**, pero hay que tener en cuenta que esta función traduce la notación TeX a la notación de función **expression**, por lo que **los símbolos y la notación disponible son los mismos en ambas funciones**.

```{r}
# install.packages("latex2exp")
library(latex2exp)

plot(x, y, main = TeX('$\\Delta^3, \\epsilon \\in 1 \\ldots n$'))
```

Las expresiones de **LaTeX se pueden usar también en** los subtítulos, llas etiquetas de eje o **cualquier otro texto**, como textos agregados a la gráfica.

## SUBTÍTULO DEL GRÁFICO

Además, se puede **agregar un subtítulo** a un **plot()** en R con el argumento **sub =** que se mostrará debajo del gráfico. También se puede agregar un subtítulo aunque no haya un título principal.

```{r}
plot(x, y, main = "Mi título", sub = "Mi subtítulo")

# Equivalente
plot(x, y)
title(main = "Mi título", sub = "Mi subtítulo")
```

## EJES DE LOS **plots()** EN R

En los gráficos de R se puede modificar las etiquetas de los ejes X e Y, agregar y cambiar las etiquetas de los ticks (marcas) de los ejes, la escala e incluso los límites de los ejes.

### ETIQUETA DE LOS EJES X E Y

Por defecto, R usará los nombres de los vectores que se pasen a la función **plot()** como etiquetas de los ejes X e Y. Sin embargo, se pueden cambiar con los argumentos **xlab** e **ylab**.

```{r}
plot(x, y, xlab = "Etiqueta del eje X", ylab = "Etiqueta del eje Y")
```

Si se quieren **borrar las etiquetas de los ejes**, se puede establecer como una cadena de carácteres vacíos o establecer el argumento **ann** como **FALSE**.

```{r}
# Eliminar las etiquetas de los ejes
plot(x, y, xlab = "", ylab = "")

# Equivalente
plot(x, y, xlab = "Etiqueta del eje X", ylab = "Etiqueta del eje Y",
     ann = FALSE)
```

### LA FUNCIÓN **axis()**

El argumento **axes** de la función **plot()** puedeestablecerse en **FALSE** para **evitar dibujar los ejes**, por lo que, en caso de que se quiera, se puede agregar solo uno de ellos con la función **axis()** y personalizarlo. Pasar un **1** como argumento dibujará el eje X, pasar un **2** dibujará el eje Y, pasar un **3** agregará el eje superior y un **4** el derecho.

```{r}
plot(x, y, axes = FALSE)

# Añadir el eje X
axis(1)

# Añadir el eje Y
axis(2)
```

### CAMBIAR LOS TICKS

También es posible cambiar los ticks de los ejes. Por una parte, el argumento **at =** de la función axis permite indicar los puntos en los que se van a dibujar las etiquetas.

```{r}
plot(x, y, axes = FALSE)
axis(1, at = -1:1)
```

Por otra parte, la función **minor.tick()** del paquete **Hmisc** permite crear ticks más pequeños entre los ticks princiáles:

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
# install.packages("Hmisc")
library(Hmisc)

plot(x, y)
minor.tick(nx = 3, ny = 3, tick.ratio = 0.5)
```

Por último, pasar un número positivo al argumento **tck =** de la función **plot()** permite añadir ticks interiores.

```{r}
# Ticks interiores
plot(x, y, tck = 0.02)
```

### ELIMINAR ETIQUETAS DE LAS MARCAS DE LOS EJES

Estableciendo los argumentos **xaxt** o **yaxt** como **"n"** en la función **plot()** evitará trazar las etiquetas de los ejes X e Y, respectivamente.

```{r}
par(mfrow = c(1, 3))

# Eliminar las etiquetas de los ticks del eje X
plot(x, y, xaxt = "n", main = "xaxt = 'n'")

# Eliminar las etiquetas de los ticks del eje Y
plot(x, y, yaxt = "n", main = "yaxt = 'n'")

# Eliminar las etiquetas de los ticks de ambos ejes
plot(x, y, yaxt = "n", xaxt = "n", main = "xaxt = 'n', yaxt = 'n'")

par(mfrow = c(1, 1))
```

### CAMBIAR LAS ETIQUETAS DE LOS TICKS

Las etiquetas de los ticks de los ejes se numerarán para seguir la numeración de los datos. Sin embargo, **se pueden modificar estas etiquetas** si es necesario con el argumento **labels =** de la función **axis()**. También se deberá especificar dónde se mostrarán las etiquetas de los ticks con el argumento **at =**.

```{r}
par(mfrow = c(1, 2))

# Cambiar las etiquetas de los ticks del eje X
plot(x, y, xaxt = "n")
axis(1, at = seq(round(min(x)), round(max(x)), by = 1), labels = 1:7)

# Cambiar las etiquetas de los ticks del eje Y
plot(x, y, yaxt = "n")
axis(2, at = seq(round(min(y)), round(max(y)), by = 1), labels = 1:9)
```

### ROTAR LAS ETIQUETAS DE LOS EJES

El argumento **las =** de la función **plo()** en R permite **rotar las etiquetas de los ejes de los gráficos**. En el siguiente código se encontrará con ejemplos y la explicación de las diferentes alternativas.

```{r}
par(mfrow = c(2, 2))

plot(x, y, las = 0, main = "Paralelo")      
# Paralelo a los ejes (por defecto)
plot(x, y, las = 1, main = "Horizontal")    # Horizontal
plot(x, y, las = 2, main = "Perpendicular") # Perpendicular a los ejes
plot(x, y, las = 3, main = "Vertical")      # Vertical

par(mfrow = c(1, 1))
```

### LÍMITES DE LOS EJES

Se puede acercar o alejar el gráfico cambiando los límites de los ejes. Estos argumentos son muy útiles cuando se agregan curvas al gráfico.

```{r}
plot(x, y,
     ylim = c(-10, 10), # Eje Y desde -10 hasta 10
     xlim = c(-7, 7)) # Eje X desde -7 hasta 7
```

### CAMBIAR LA ESCALA DE LOS EJES

El argumento **log =** permite cambiar la estala de los ejes de un gráfico. Puede transformar el eje X, el eje Y o ambos, de la siguiente manera:

```{r}
# Nuevos datos para evitar números negativos
s = 1:20
u = 1:20

par(mfrow = c(2, 2))

# Por defecto
plot(s, u, pch = 19,
     main = "Sin transformar")

# Log x
plot(s, u, pch = 19, log = "x", 
     cex = 2, main = "Eje X transformado")

# Log y
plot(s, u, pch = 19, log = "y",
     cex = 2, main = "Eje Y transformado")

# Log xy
plot(s, u, pch = 19, log = "xy",
     cex = 2, main = "Ambos ejes transformados")
```

Sin embargo, se puede estar pensando que usar la función **log()** es equivalente a usar el argumento, pero no lo es. Como se puede ver en el gráfico anterior, al usar el argumento **log =** solo se modifica la escala, no los datos, pero la función **log()** sí los transformará. Se mostrará, a continuación, la diferencia entre los ejes del siguiente gráfico y los del anterior.

```{r}
par(mfrow = c(1, 3))

# Log-log
plot(log(s), log(u), pch = 19,      
     main = "log-log")

# log(x)
plot(log(s), u, pch = 19,
     main = "log(x)")

# log(y)
plot(s, log(u), pch = 19,
     main = "log(y)")

par(mfrow = c(1, 1))
```

## FUENTE DE TEXTO DE UN **plot()** EN R

### TAMAÑO DE LA FUENTE

Se puede cambiar el tamaño de fuente de un gráfico en R con los argumentos **cex.main**, **cex.sub**, **cex.lab**, y **cex.axis** para cambiar el título, los subtítulos, las etiquetas de los ejes X e Y y los ticks de los ejes, respectivamente. Valores mayores mostrarán textos más grandes:

```{r}
plot(x, y, main = "Mi título", sub = "Mi subtítulo",
     cex.main = 2,   # Tamaño del título
     cex.sub = 1.5,  # Tamaño del subtítulo
     cex.lab = 3,    # Tamaño de las etiquetas de los ejes X e Y
     cex.axis = 0.5) # Tamaño de las etiquetas de los ticks de los ejes
```

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Argumento = c("cex.main",
              "cex.sub",
              "cex.lab",
              "cex.axis")
Descripción = c("Establece el tamaño del título",
                "Establece el tamaño del subtítulo",
                "Establece el tamaño de las
etiquetas de los ejes",
                "Establece el tamaño de las etiquetas
de los ticks de los ejes")

df = data.frame(Argumento, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Descripción del tipo de argumento de plot() en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

### ESTILO DE LAS FUENTES

Además, se puede cambiar el estilo de fuente de los gráficos de R con el argumento **font**. Se puede establecer este argumento en 1 para texto sin formato, 2 en negrita (predeterminado), 3 en cursiva y 4 en negrita y cursiva. Este argumento no aplica para el título.

```{r}
par(mfrow = c(1, 3))

plot(x, y, font = 2, main = "Negrita") # Negrita
plot(x, y, font = 3, main = "Cursiva") # Cursiva
plot(x, y, font = 4, main = "Negrita y cursiva") # Negrita y cursiva
```

También se puede especificar el estilo de cada uno de los textos del gráfico con los argumentos **font.main**, **font.sub**, **font.axis** y **font.lab**.

```{r}
plot(x, y,
     main = "Mi título",
     sub = "Subtítulo",
     font.main = 1, # Estilo de fuente del título
     font.sub  = 2, # Estilo de fuente del subtítulo
     font.axis = 3, # Estilo de fuente de los ejes X e Y
     font.lab  = 4) # Estilo de fuente de los ticks de los ejes
```

Hay que tener en cuenta que, de forma predeterminada, el título de los gráficos está en negrita.

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Fuente = c("1",
           "2",
           "3",
           "4")
Descripción = c("Texto plano",
                "Negrita",
                "Cursiva",
                "Negrita y Cursiva")

df = data.frame(Fuente, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Descripción del tipo de fuente de plot() en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

### FAMILIA DE LAS FUNETES

El argumento **family** permite cambiar la familia de las fuentes de los textos de los plots en R. Incluso puedes agregar más texto con otras familias de fuentes. Hay que tener en cuenta que se puede ver la lista completa de fuentes disponibles en R con el comando **names(pdfFontss())**, pero algunas de ellas pueden no estar instaladas en el ordenador.

```{r}
# Fuentes
names(pdfFonts())

plot(x, y, family = "mono")
text(-2, 3, "Un texto", family = "sans")
text(-2, 2, "Más texto", family = "serif")
text(1, -4, "Otro texto", family = "HersheySymbol")
```

Una alternativa es usar el paquete **extrafont**:

```{r, eval=FALSE}
# install.packages("extrafont")
library(extrafont)

# Autodetecta las fuentes disponibles en el ordenador
# Esto puede tardar varios minutos en ejecutarse
font_import()

# Nombres de las fuentes
fonts()

# Data frame con los nombres de las fuentes
fonttable()
```

## COLOREAR **plots() EN R

En la sección sobre símbolos **pch** se explicó cómo configurar el argumento **col**, que permite **modificar el color de los símbolos de los gráficos**. En R, hay una amplia variedad de [**paletas de colores**](https://r-charts.com/es/paletas-colores/). Con la función **colors()** se puede devolver **todos los colores** base de R disponibles. Además, se puede usar la función **grep()** (una función para expresiones regulares) para devolver un vector de colores que contenga algún texto concreto.

```{r, eval=FALSE}
# Devolver todos los colores
colors()

# Devolver todos los colores que contengan "green"
cl = colors()
cl[grep("green", cl)]

# Gráfico con puntos azules
plot(x, y, col = "blue")
plot(x, y, col = 4) # Equivalente
plot(x, y, col = "#0000FF") # Equivalente
```

Se puede especificar colores con su nombre en inglés (*"red"*, *"green"*, $\cdots$), con números (1 a 8) o incluso con su referencia HEX (*"#FF0000"*, *"#0000FF"*, $\cdots$).

También se pueden modificar los colores de los textos con las funciones **col.main**, **col.sub**, **col.lab**, y **col.axis** e incluso cambiar el color de la caja del gráfico con el argumento *fg*.

```{r}
plot(x, y, main = "Título", sub = "Subtítulo",
    pch  = 16,
    col = "cornflowerblue",            # Color del símbolo
    col.main = "green",     # Color del título
    col.sub = "blue",       # Color del subtítulo
    col.lab = "sienna2",    # Color de las etiqetas de los ejes
    col.axis = "maroon4",   # Color de las etiquetas de los ticks
    fg = "orange")          # Color de la caja
```

### COLOREAR SEGÚN GRUPO

Si se tienen varias variables numéricas etiquetadas por grupo, puede **dibujarse las observaciones separadas por color**, pasando al argumento **col** la variable categórica (como factor). Los colores dependerás de los factores.

```{r}
# Creamos un data frame con grupos
grupo = ifelse(x < 0 , "coche", ifelse(x > 1, "avión", "barco"))
df = data.frame(x = x, y = y, grupo = factor(grupo))

# Color por grupo
plot(df$x, df$y, col = df$grupo, pch = 16)

# Cambiar los colores de los grupos
colores = c("red", "green", "blue")
plot(df$x, df$y, col = colores[df$grupo], pch = 16)

# Cambiar el orden del color, cambiando el orden de los niveles
plot(df$x, df$y, pch = 16,
     col = colores[factor(grupo, levels = c("coche", "barco", "avión"))])
```

Nótese que, por defecto, los niveles de los factores **están ordenados alfabéticamente**, por lo que en este caso el orden del vector de colores no es el orden de los colores en el gráfico, ya que la primera fila del data frame corresponde a *“coche”*, que es el tercer nivel. Por lo tanto, si se cambia el orden de los niveles, puedes modificar el orden de los colores.

Desde R 4.0.0 el argumento **stringAsFactors** de la función **data.frame()** es **FALSE** por defecto, por lo que deberás convertir la variable categórica a factor si se quiere colorear las observaciones por grupo como en el ejemplo anterior.

### CAMBIAR EL COLOR DE FONDO

Hay dos formas de cambiar el color de fondo de los gráficos en R: cambiando todo el color o cambiando el color de fondo de la caja. Para cambiar todo el color se puede usar el siguiente comando:

```{r}
# Color de fondo gris claro
par(bg = "#f7f7f7")

# Añadimos nuestro gráfico
plot(x, y, col = "#8E44AD", pch = 16)

# Volvemos al color original
par(bg = "white")
```

Sin embargo, el resultado quedará más bonito si solo se colorea la caja de un determinado color, aunque esto requiere más codigo. Nótese que la función **plot.new()** permite crear un gráfico vacío en R y que **par(new = TRUE)** permite añadir un gráfico sobre otro.

```{r}
# Creamos un plot vacío
plot.new()

# Coloreamos la caja
rect(par("usr")[1], par("usr")[3],
     par("usr")[2], par("usr")[4],
     col = "#f7f7f7") # Color

par(new = TRUE)

# Añadimos nuestro gráfico
plot(x, y, col = "#16A085", pch = 16)
```

## AÑADIR LÍNEAS O CURVAS A UN GRÁFICO EN R

Se puede agregar una línea a un diagrama en R con la función **lines()**. Supongamos que se quiere agregar una línea roja a una gráfica, desde (-4, -4) a (4, 4), para ello se puede escribir:

```{r}
plot(x, y)
lines(-4:4, -4:4, lwd = 3, col = "#E74C3C")
```

### GROSOR DE LA LÍNEA

El ancho o grosor de línea en R se puede acambiar con el argumento **lwd**. Valores más grandes trazarán una línea más ancha.

```{r}
M = matrix(1:36, ncol = 6)

matplot(M, type = c("l"), lty = 1, col = "black", lwd = 1:6)

# Solo para indicar los anchos de línea en el gráfico
j = 0
invisible(sapply(seq(4, 40, by = 6),
                 function(i) {
                   j <<- j + 1
                   text(2, i, paste("lwd =", j))}))
```

### TIPO DE LÍNEA

Al trazar un gráfico de tipo “l”, “o”, “b”, “s”, o al agregar una nueva línea sobre un gráfico ya creado, se puede elegir entre diferentes **tipos de línea en R**, estableciendo el argumento **lty()** de 0 a 6.

```{r, eval=FALSE}
matplot(M, type = c("l"), lty = 1:6, col = "black", lwd = 3)

# Solo para indicar los tipos de líneas en el gráfico
j = 0
invisible(sapply(seq(4, 40, by = 6),
                 function(i) {
                   j <<- j + 1
                   text(2, i, paste("lty =", x))}))
```

![](1line-type1.png)

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Tipo = c("0",
         "1",
         "2",
         "3",
         "4",
         "5",
         "6")
Descripción = c("Sin línea",
                "Línea sólida (por defecto)",
                "Línea discontinua",
                "Línea punteada",
                "Línea discontinua con puntos",
                "Líneas largas discontinuas",
                "Línea discontinua con dos trazos")

df = data.frame(Tipo, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Descripción del tipo de línea de plot() en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

## AÑADIR TEXTO A UN **plot()** EN R

Por un lado, la función **mtext()** permite agregar texto a todos los lados del gráfico. Hay 12 combinaciones (3 en cada lado de la caja: alineadas a la izquierda, al centro y a la derecha). Sólo se nececita cambiar los argumentos **adj** y **side** para obtener la combinación que se necesite.

Por otro lado, la función **text()** permite agregar texto o fórmulas dentro del gráfico en alguna posición configurando las coordenadas. En el siguiente bloque de código se muestran algunos ejemplos de ambas funciones.

```{r}
plot(x, y, main = "Título principal", cex = 2, col = "blue")

#---------------
# Función mtext
#---------------

# Abajo centro
mtext("Texto abajo", side = 1)

# Izquierda centro
mtext("Texto izquierda", side = 2)

# Arriba centro
mtext("Texto arriba", side = 3)

# Derecha centro
mtext("Texto derecha", side = 4)


# Abajo izquierda
mtext("Texto abajo izquierda", side = 1, adj = 0)

# Arriba derecha
mtext("Texto arriba derecha", side = 3, adj = 1)


# Arriba, con separación
mtext("Texto arriba", side = 3, line = 2.5)

#--------------
# Función text
#--------------

# Texto en las coordenadas (-2, 2)
text(-2, 2, "Más texto")

# Fórmula en las coordenadas (3, -3)
text(3, -3, expression(frac(alpha[1], 4)))
```

### ETIQUETAR PUNTOS EN R

Aprender a **etiquetar observaciones en R** es sumamente sencillo. Para ello, se puede usar la función **text()**, **indicar las coordenadas y la etiqueta de los puntos de datos** en el argumento **labels**. Con el argumento **pos** se puede establecer la posición de la etiqueta con respecto al punto, siendo 1 debajo, 2 a la izquierda, 3 arriba y 4 a la derecha.

```{r}
# Base de datos usada en este ejemplo
attach(USJudgeRatings)

# Creamos el plot
plot(FAMI, INTG,
     main = "Familiaridad con la ley vs Integridad judicial",
     xlab = "Familiaridad", ylab = "Integridad",
     pch = 18, col = "darkblue")

# Asignamos las etiquetas
text(FAMI, INTG,
     labels = row.names(USJudgeRatings),
     cex = 0.6, pos = 4, col = "darkred")

detach(USJudgeRatings)
```

También se puede **etiquetar puntos de datos individuales** si se indexan los elementos de la función **text()** de la siguiente manera:

```{r}
# Base de datos usada para este ejemplo
attach(USJudgeRatings)

plot(FAMI, INTG,
     main = "Familiaridad con la ley vs Integridad judicial",
     xlab = "Familiaridad", ylab = "Integridad",
     pch = 18, col = "blue")

# Seleccionamos los índices de los elementos que queremos etiquetar
seleccionados <- c(10, 15, 20)

# Indexamos los elementos con el vector
text(FAMI[seleccionados], INTG[seleccionados],
     labels = row.names(USJudgeRatings)[seleccionados],
     cex = 0.6, pos = 4, col = "red")

detach(USJudgeRatings)
```

## CAMBIAR EL TIPO DE CAJA CON EL ARGUMENTO **bty**

El argumento **bty** permite cambiar el tipo de caja de los gráficos de R. Hay diversas opciones, resumidas en la siguiente tabla:

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Tipo = c("o",
         "7",
         "L",
         "U",
         "C",
         "n")
Descripción = c("Caja entera (por defecto)",
                "Arriba y derecha",
                "Izquierda y abajo",
                "Izquierda, abajo y derecha",
                "Arriba, izquierda y abajo",
                "Sin caja")

df = data.frame(Tipo, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Descripción del tipo de línea de plot() en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

La forma de los carácteres *"7"*, *"L"*, y *"U"* representan la forma de los bordes que dibujan.

```{r}
par(mfrow = c(2, 3))

plot(x, y, bty = "o", main = "Por defecto")
plot(x, y, bty = "7", main = "bty = '7'")
plot(x, y, bty = "L", main = "bty = 'L'")
plot(x, y, bty = "U", main = "bty = 'U'")
plot(x, y, bty = "C", main = "bty = 'C'")
plot(x, y, bty = "n", main = "bty = 'n'")
```

Hay que tener en cuenta que en otros gráficos, como el caso de los boxplots, se deberá de especificar el argumento **bty** dentro de la función **par()**.

## AÑADIR UNA LEYENDA A UN **plot()** EN R

Por último, se revisará cómo añadir una leyenda a un plot de R con la función **legend()**. Se puede establecer las coordenadas en las que se quiere agregar la leyenda o especificar *"top"*, *"bottom"*, *"topleft"*, *"toprigth"*, *"bottomleft"* o *"bottomrigth"*. También se pueden especificar muchos argumentos como en la función **plot()**. Como por ejemplo, se puede cambiar el argumento **bty** en la leyenda, o el color de fondo con el argumento **bg**, entre otros.

```{r}
plot(x, y, pch = 19)
lines(-4:4, -4:4, lwd = 3, col = "blue")
lines(-4:1, 0:5, lwd = 3, col = "green")

# Añadimos la leyenda
legend("bottomright", legend = c("azul", "verde"),
       lwd = 3, col = c("blue", "green"))
```

\newpage

# CAPÍTULO 16

\newpage

## [**GRÁFICO DE DISPERSIÓN EN R**](https://r-coder.com/grafico-dispersion-r/)

![](scatterplot-r.png)

**Los diagramas o gráficos de dispersión**, también conocidos como nubes de puntos, scatter plots o scatter chart por su nombre en inglés, **representan las observaciones de las variables** (generalmente dos, pero también pueden ser tres). El uso principal de un gráfico de dispersión en R es verificar visualmente si existe alguna relación entre ciertas variables numéricas.

## ¿CÓMO HACER UN GRÁFICO DE DISPERSIÓN EN R?

Se puede crear un diagrama de dispersión en R con la función **plot()**, especificando los valores de $x$ en el primer argumento y los valores de $y$ en el segundo, siendo $x$ e $y$ vectores numéricos de la misma magnitud.

Al pasar estos parámetros, la función **plot()** creará un gráfico de dispersión de forma predeterminada. También se puede **especificar el símbolo de las observaciones** de datos o incluso **el color**, entre otros parámetros gráficos.

Considerando, como ejemplo, el modelo $Y=3+2X^{2}+\varepsilon$, siiendo $Y$ la variable dependiente, $X$ la variable independiente y $\varepsilon$ un término de error, tal que $X \sim{U(0,1}$  y $\varepsilon \sim{N(0, 0.25)}$.

```{r}
# Datos de ejemplo
set.seed(18)

n = 110
x = runif(n)
eps = rnorm(n, 0, 0.25)

y = 3 + 2 * x^2 + eps
```

Para dibujar las observaciones generadas, se puede escribir:

```{r}
plot(x, y, pch = 19)
plot(y ~ x, pch = 19, col = "black") # Equivalente
```

### NUBE DE PUNTOS EN R CON COLORES POR GRUPO

Si se tiene una variable que clasifica las observaciones en grupos, se puede establecer como parámetro del argumento **col** para dibujar los  **puntos con diferentes colores** dependiendo de su grupo, o incluso establecer diferentes símbolos según el grupo.

```{r}
# Grupos de ejemplo
grupo = as.factor(ifelse(x < 0.5, "Grupo 1", "Grupo 2"))

plot(x, y, pch = as.numeric(grupo), col = grupo)
```

### GRÀFICO DE DISPERSIÒN CON CURVA DE REGRESIÒN

Como se mencionó en la introducción, el uso principal de los diagramas de dispersión en R es **verificar la relación entre variables**. Para este propósito, se **puede añadir líneas de regresión** (ocurvas en caso de estimadores no lineales) con la función **lines()**, que permite personalizar el ancho de línea con el argumento **lwd** o el tipo de línea con el argumento **lty**, entre otros argumentos.

En este ejemplo, se va a ajustar un modelo lineal y otro no paramétrico con las funciones **lm()** y **lowess** respectivamente, con los argumentos predeterminados.

```{r}
plot(x, y, pch = 19, col = "gray52")

# Modelo subyacente
lines(seq(0, 1, 0.05), 2 + 3 * seq(0, 1, 0.05)^2, col = "2", lwd = 3,
      lty = 2)

# Ajsute lineal
abline(lm(y ~ x), col = "orange", lwd = 3)

# Ajuste suavizado
lines(lowess(x, y), col = "blue", lwd = 3)

# Leyenda
legend("topleft", legend = c("Teórico", "Lineal", "Suavizado"),
       lwd = 3, lty = c(2, 1, 1), col = c("red", "orange", "blue"))
```

Además, se puede agregar la correlación de Pearson que existe entre las variables, calculándola con la función **cor()**. Luego se puede colocar la salida en algunas coordenadas del gráfico con la función **text()**.

```{r}
# Calculamos la correlación entre las variables
Corr = cor(x, y)

# Creamos el gráfico y añadimos el valor calculado
plot(x, y, pch = 19)
text(paste("Correlación:", round(Corr, 2)), x = 0.2, y = 4.5)
```

### AÑADIR MÚLTIPLES SERIES AL GRÁFICO DE DISPERSIÓN

También se pueden agregar más datos al gráfico original con la función **point()**, que añadirá los nuevos puntos sobre el gráfico anterior, respetando la escala original.

```{r}
set.seed(100)

plot(x, y, pch = 19)

n = 200

x2 = runif(n)
y2 = 2.5 + x2 + rnorm(n, 0, 0.1)

points(x2, y2, col = "green", pch = 19)
```

También se pueden agregar los datos al conjunto de datos original y clasificar las observaciones para dibujar todas al mismo tiempo y con colores diferentes para cada serie.

### DIAGRAMA DE DISPERSIÓN EN R CON BARRAS DE ERROR

**Agregar barra de error a un gráfico de dispersión en R** es bastante sencillo. Se considera, como ejemplo, que se tienen 10 grupos con media gaussiana y desviación típica, también gaussiana, como en el siguiente ejemplo. Se pueden graficar los datos y especificar el límite del eje Y como el rango de la barra inferior y superior. Luego, se deberá usar la función **arrows()** de la siguiente manera para crear las barras de error.

```{r}
mis_datos = 1:10
media = rnorm(10)
desv = rnorm(10, 1, 0.1)

plot(mis_datos, media,
     ylim = range(c(media - desv, media + desv)),
     pch = 16)

# Barras de error
arrows(x0 = mis_datos, y0 = media - desv, x1 = mis_datos, y1 = media + desv,
       length = 0.15, code = 3, angle = 90)
```

### DIAGRMA DE DISPERSIÓN CONECTADO EN R

Un gráfico de dispersión conectado es similar a un gráfico de líneas, pero **los puntos de corte están marcados con puntos u otro símbolo**. Para este propósito, se puede establecer el argumento **type** como **"b"** y especificar el símbolo que se prefiera con el argumento **pch**.

Hay que recordar usar este tipo de gráfico cuando se tenga sentido (cuando las variables que se quieran dibujar estén ordenadas correctamente), o los resultados no serán los esperados.

```{r}
set.seed(99)

x3 = 0:10
y3 = (0:10) ^ 1.45 + rnorm(11)
y4 = (0:10) ^ 1.15 + rnorm(11)
y5 = (0:10) ^ 1.05 + rnorm(11)

plot(x3, y3,  type = "b", col = 2 , lwd = 3, pch = 1)
lines(x3, y4, type = "b", col = 3 , lwd = 3, pch = 1)
lines(x3, y5, type = "b", col = 4 , lwd = 3, pch = 1)
```

Si se prefiere unir los puntos con flechas se puede usar la siguiente función:


```{r}
# Función para conectar lo puntos con flechas
arrowsPlot = function(x, y, lwd = 1, col = 1, angle = 20,
                       length = 0.2) {
  invisible(sapply(1:length(x),
    function(i) arrows(x[i], y[i], x[i + 1], y[i + 1], lwd = lwd,
                       col = col, angle = angle, length = length)))
}

plot(x3, y3, col = 2, lwd = 3, pch = "")
arrowsPlot(x3, y3, col = 2, lwd = 3)

lines(x3, y4, col = 3, lwd = 3)
arrowsPlot(x3, y4, col = 3, lwd = 3)

lines(x3, y5, col = 4 , lwd = 3)
arrowsPlot(x3, y5, col = 4 , lwd = 3)
```

Este tipo de gráficos también son interesantes cuando se quiere **mostrar la trayectoria que dibujan dos variables a lo largo del tiempo**.

Se considera, como ilustración, que se desea mostrar la popularidad de un artista frente a los álbunes vendidos a lo largo del tiempo. Se puede dibujar algo como lo siguiente:

```{r}
# Datos de ejemplo
x4 = ifelse(x3 < 5, x3, rev(x3 / 3))
y5 = ifelse(y3 < 5, y3 ^ 3, rev(y3 + 5))

# Creando el gráfico de puntos conectados
plot(x4, y5, yaxt = "n", xaxt = "n", pch = "",
     xlab = "Popularidad", ylab = "Ventas", xlim = c(-1, 5.5))
arrowsPlot(x4, y5, col = 3, lwd = 3)

# Añadiendo los años a cada punto
text(x4 + 0.3, y5, 1970:1980)
```

## DIAGRAMA DE DISPERSIÓN SUAVIZADO

La función **smoothScatter()** es una función de R base que colorea el diagrama de dispersión según una estimación tipo núcleo de la densidad.

Los siguientes ejemplos muestran cómo usar los argumentos básicos de la función. Hayq eu tener en cuenta que, como otros métodos no paramétricos, se deberá seleccionar una ventana. Aunque la función proporciona una ventana predeterminada, se puede personalizar con el argumento de **bandwidth**.

```{r}
smoothScatter(x, y)
```

```{r}
smoothScatter(x, y, pch = 19,
              transformation = function(x) x ^ 0.5, # Escala
              colramp = colorRampPalette(c("#ECFFE9", "#A1E194")))
# Colores
```

### MAPA DE CALOR CON UN SCATTERPLOT

Con la función **smoothScatter()** también se puede crear un mapa de calor. Para ello, se deberá especificar una paleta de colores de la siguiente manera:

```{r}
smoothScatter(x, y, transformation = function(x) x ^ 0.4,
              colramp = colorRampPalette(c("#000099", "#00FEFF", 
                                           "#45FE4F","#FCFF00",
                                           "#FF9400", "#FF3100")))
```

## LA FUNCIÓN **scatterplot()**

Una alternativa para crear gráficos de dispersión en R es usar la función **scatterplot()** del paquete **car**, que muestra automáticamente las curvas de regresión y permite **agregar boxplots marginales** al diagrama de dispersión.

```{r}
# install.packages("car")
library(car)

scatterplot(y ~ x)
scatterplot(x, y) # Equivalente
```

Por defecto, la función dibuja tres estimaciones (estimación de la media lineal y no maramétrica y la varianza condicional) con gráficos de caja marginales, todo con el mismo color.

Para **personalizar el diagrama de dispersión**, se utilizan los argumentos **col** y **pch** para cambiar el color y el símbolo de los puntos, respectivamente. Ademas, se pueden pasar los argumentos como lista a los argumentos **regLine** y **smooth** para personalizar los parmámetros gráficos de las estimaciones correspondientes.

```{r}
scatterplot(x, y,
           col = 1,   
           # Color de los puntos
           
           pch = 15,  
           # Símbolo
           
           regLine = list(col = "green", 
           # Color de la regresión lineal
                          lwd = 3),      
           
           # Ancho de la línea
           smooth = list(col.smooth = "red",   
           
           # Color de la estimación no paramétrica de la media
                         col.spread = "blue")) 
           # Color de la estimación no paramétrica de la varianza
```

Asimismo, en caso de que se quiera eliminar alguna de las estimaaciones, establece el argumento correspondiente como **FALSE**.

```{r}
scatterplot(x, y,
            smooth = FALSE, # Borra la estimación suavizada
            regLine = FALSE)# Borra la estimación lineal
```

También se puede poner un solo boxplot marginal con el argumento **boxplots**, que por defecto es **"xy"**. Si se configura como **"x"**, solo se mostrará el diagrama de la caja del eje X. Lo mismo para el eje Y, si se establecw el argumento **"y"**. Si no se quiere ningún diagrama de caja, pasa **""** al argumento.

```{r}
scatterplot(x, y,
            boxplots = "y") # Boxplot marginal del eje Y
```

En caso de que se tengan grupos que categorizarse dentro de los datos, se puede crear las estiamciones de regresión para cada grupo:

```{r}
scatterplot(y ~ x | grupo)
```

Hay que tener en cuenta que se puede deshabilitar la leyenda estableciendo **legend = FALSE**.

Además, se puede deshabilitar el grid o agregar una elipse con los argumentos **grid** y **ellipse**, respectivamente.

```{r}
scatterplot(x, y,
            grid = FALSE,   # Eliminar el grid
            ellipse = TRUE) # Dibujar elipses
```

Existen más argumentos que se pueden personalizar, así que se puede escribir **?scatterplot** para obtener detalles adicionales.

## MATRIZ DE DISPERSIÓN EN R

Cuando se trabaja con múltiples variablees, es común dibujar múltiples diagramas de dispersión dentro de una matriz de dispersión, que mostrará cada variable frente a otra para [**visualizar la correlación entre las variables**](https://r-coder.com/grafico-correlacion-r/).

En R se puede crear un diagrama de dispersión con múltiples variables con la función **pairs()**. El nombre de la función viene del inglés (pares), ya que estos gráficos también se conocen como *"diagramas de dispersión por pares"*.

```{r}
# Base de datos de R mtcars
pairs(~disp + wt + mpg + hp, data = mtcars)
```

Adempas, en caso de que el conjunto de datos contenga una variable de tipo factor, se puede especificar la variable en el argumento **col** de la siguiente manera para dibujar los grupos con un color diferente.

```{r}
 pairs(~disp + wt + mpg + hp, 
       col = factor(mtcars$am), pch = 19, data = mtcars)
```

Una alternativa es utilizar la función **scatterplotMatrix()** del paquete **car**, que añade estimaciones de densidad tipo kernel en la diagonal.

```{r}
# install.packages("car")
library(car)

scatterplotMatrix(~ disp + wt + mpg + hp,
                  data = mtcars)
```

Para personalizarlo se pueden usar los argumentos correspondientes:

```{r}
scatterplotMatrix(~ disp + wt + mpg + hp, data = mtcars,
                  diagonal = FALSE,             
                  # Eliminar las estimaciones tipo núcleo
                  regLine = list(col = "green", 
                  # Color de la línea de regresión
                                 lwd = 3),      
                  # Ancho de la línea de regresión
                  smooth = list(col.smooth = "red",   
                  # Color de la media no paramétrica
                                col.spread = "blue")) 
                  # Color de la varianza no paramétrica
```

Otra alternativa es utilizar la función **cpairs()** del paquete **gclus**.

```{r}
# install.packages("gclus")
library(gclus)
data = mtcars[c(1, 3, 5, 6)] # Variables numéricas
# cpairs(data) # Alternativa a pairs()

corr = abs(cor(data)) # Correlación en valor absoluto
corr
colors = dmat.color(corr)
order = order.single(corr)

cpairs(data, order, panel.colors = colors, gap = 0.5,
       main = "Variables ordenadas y coloreadas por correlación")
```

## SCATTER PLOT EN GGPLOT2

La creación de un gráfico de dispersión con la librería **ggplot2** se puede lograr con la función **geom_point()**. Además, se puede dividir los grupos por color pasando la función **aes()** con el grupo como parámetro del argumento **colour**.

```{r}
# install.packages("ggplot2")
library(ggplot2)

mi_df = data.frame(x = x, y = y, grupo = grupo)

ggplot(mi_df, aes(x = x, y = y)) +
  geom_point(aes(colour = grupo)) + # Puntos y colores por grupo
  scale_color_discrete("Grupos") +  # Cambiar el título de la leyena
  xlab("Variable X") +              # Etiqueta del eje X
  ylab("Variable Y")  +             # Etiqueta del eje Y
  theme(axis.line = element_line(colour = "black", 
                                 # Cambia el tema por defecto
                                 size = 0.24))
```

## GRÁFICO DE DISPERSIÓN 3D

Con las librerías **scatterplot3d** y **rgl** se pueden crear **gráficos de dispersión 3D en R**. La función **scatterplot3d()** permite crear un gráfico 3D estático de tres variables. Se puede ver la lista completa de argumentos de la función ejecutando **?scatterplot3d**.

```{r}
# install.packages("scatterplot3d")
library(scatterplot3d)

set.seed(5)
x = rnorm(500)
y = rnorm(500, mean = 20)
z = rnorm(500)

scatterplot3d(x, y, z, pch = 19, color = "cornflowerblue")
```

Una alternativa es utilizar la función **plot3d()** del paquete **rgl** que permite una visualización interactiva. Puede rotar, acercar y alejar el diagrama de dispersión. Esto es muy útil para buscar patrones en datos tridimensionales.

```{r, eval=FALSE}
# install.packages("rgl")
library(rgl)

plot3d(x, y, z,      # Datos
       type = "s",   # Tipo de gráfico
       radius = 0.1, # Radio de las observaciones
       col = "lightblue",   # Color de las observaciones
       xlab ="X axis lab",  # Etiqueta del eje X
       ylab = "Y axis lab", # Etiqueta del eje Y
       zlab = "Z axis lab") # Etiqueta del eje Z
```

![](11plot3d.png)

\newpage

# CAPÍTULO 17

\newpage

## [**GRÁFICO DE BARRAS EN R**](https://r-coder.com/grafico-barras-r/)

![](barplot-r.png)

Cuando una variable llega a tomar pocos valores, es algo común resumir la información con una tabla de frecuencias que se puede representar con un gráfico de barras en R. **Este tipo de gráficos** se suelen utilizar, por ejemplo: para representar precipitaciones y temperaturas (añadiendo una curva por encima de los datos), en lo que se conoce como climogramas. En este capítulo se explicarán los conceptos básicos de la **creación de diagramas de barras en R**.

## LA FUNCIÓN BARPLOT EN R

Para crear un gráfico de barras en R, se puede usar la función de R base **barplot()**. En el ejemplo que se verá a continuación, se va a **crear un diagrama de barras a partir de un data frame**. Concretamente se va a usar el conocido conjunto de datos **mtcars**.

En primer lugar, se van cargar los datos y crear una tabla para la columna **cyl** con la función de **table**.

```{r}
# Cargamos los datos
data("mtcars")
attach(mtcars)
```

Para lograr visualizar el nombre de las columnas del data frame, se usa la función **colnames()**, y aparte la función **View()** para abrir una nueva ventana y visualizar los datos, tal y como se muestra en la siguiente línea de código:

```{r, eval=FALSE}
# Nombre de las variables por columna
colnames(mtcars)
View(mtcars)
```

Se crea la tabla de frecuencia:

```{r}
# Tabla de freuencia
mi_tabla = table(cyl)
mi_tabla
```

Hay que recordar que para crear un diagrama de barras en R se puede usar la función **barplot()** y establecer como parámetro la tabla creada anteriormente para **mostrar la frecuencia absoluta** de los datos.

Sin embargo, si se prefiere un **gráfico de barras con porcentajes** en el eje vertical (en otras palabras, la frecuencia relativa), se puede usar la función **prop.table** y multiplicar el resultado por $100$ de la siguiente manera:

```{r}
# Una fila, dos columnas
par(mfrow = c(1, 2))

# Gráfico de barras de frecuencia absoluta
barplot(mi_tabla, main = "Frecuencia absoluta",
        col = rainbow(4))

# Gráfico de barras de frecuencia relativa
barplot(prop.table(mi_tabla) * 100,
        main = "Frecuencia relativa (%)",
        col = rainbow(4))
```

Hay que tener en cuenta que también se puede crear un **diagrama de barras a partir de un factor** con la función **plot()**.

```{r}
plot(factor(cyl), col = c("DarkRed", "Blue", "Pink"))
```

Además, por una parte, se puede agregar curvas sobre el gráfico de barras para representar otra variable, tal y como sucede con la temperatura en el caso de los climogramas.

En este caso, se va a dibujar una línea sobre el gráfico que se ha creado con nuestra tabla.[^dd]

[^dd]: El asignar un gráfico de barras a una variable almacenará los valores del eje correspondientes al centro de cada barra.

```{r}
# Guarda los valores de X que
# representan el centro de 
# cada barra
barp = barplot(mi_tabla,
               main = "Frecuencia absoluta",
               col = c("#AED6F1", "#3498DB", "#21618C"))

lines(barp, c(5, 4, 12), type = "o", lwd = 2, lty = 2)
```

Por otra parte, también se puede mostrar los números correspondientes a la altura de las barras con la función **text()** de la siguiente manera:

```{r}
barp = barplot(mi_tabla, col = rainbow(5), ylim = c(0, 15))
text(barp, mi_tabla + 0.7, labels = mi_tabla)
```

Por último, puede resultar interesante añadir un grid debajo de las barras del gráfico con la función **grid()**.

```{r}
barp = barplot(mi_tabla, col = rainbow(5), ylim = c(0, 15))
grid(nx = NA, ny = NULL, lwd = 1, lty = 2, col = "gray40")
barplot(mi_tabla, col = rainbow(5), ylim = c(0, 15), add = TRUE)
```

### TÍTULO, ETIQUETAS Y COLORES DEL GRÁFICO DE BARRAS

Al igual que otros gráficos, se puede especificar una amplia variabdad de **parámetros gráficos**, como etiquetas de eje, un título o personalizar los ejes. En el bloque de código anterior, se personalizó los colores del diagrama de barras con el parámetro **col =**. Se pueden establecer los colores que se prefiera con un vector o usar la función **rainbow()** con el número de barras como parámetro como se mostró anteriormente o usar otras paletas de colores. También se puede cambiar el color del borde de las barras con el argumento **border =**.

```{r}
        # Datos
barplot(mi_tabla,
        # Título
        main = "Gráfico de barras",
        # Etiqueta del eje X
        xlab = "Número de cilindros",
        # Etiqueta del eje Y
        ylab = "Frecuencia",
        # Color del borde de las barras
        border ="#4A235A",
        # Color para cada barra
        col = c("#F9E79F", "#F4D03F", "#D4AC0D"))
```

### CAMBIAR LAS ETIQUETAS DE CADA GRUPO

La etiqueta de cada grupo se puede cambiar con el argumento **names.arg =**. En este ejemplo, los grupos están etiquetados con números, pero podemos cambiarlos escribiendo algo comolo siguiente:

```{r}
barplot(mi_tabla, names.arg = c("Cuatro", "Seis", "Ocho"))
```

### ESPACIO Y ANCHO DE LAS BARRAS

También se puede **modificar el espacio entre barras o el ancho de barras** con los argumentos **width =** y **space =**.[^pop]

[^pop]: El vector **space =** **representa el espacio de la barra respecto a la anterior**, por lo que el primer elemento no se tendrá en cuenta.

```{r}
par(mfrow = c(1, 2))

# Ancho de las barras (por defecto: width = 1)
barplot(mi_tabla, main = "Cambiar el ancho de las barras",
        col = c("#F1948A", "#E74C3C", "#943126"),
        width = c(0.3, 0.4, 1))

# Espacio entre las barras
barplot(mi_tabla, main = "Cambiar el espacio entre barras",
        col = c("#F1948A", "#E74C3C", "#943126"),
        space = c(0.6, 1.2, 0.08))
```

### GRÁFICO DE BARRAS A PARTIR DE UNA LISTA O UN DATA FRAME

Además, se puede **crear un diagrama de barras directamente con las variables de un data frame o incluso una matriz**, pero hay que tener en cuenta que **la variable debe de ser el recuento de algún evento o característica**.

El siguiente ejemplo, se cuenta el número de vehículos por color y se dibujará con un gráfico de barras. Usando cada color de los coches para colorear las barras correspondientes.

```{r}
df = data.frame(ColorCoche = c("Rojo", 
                               "Verde",
                               "Blanco",
                               "Azul"),
      num = c(4, 7, 13, 3))

# df = sd.lidt(df) # Equivalente

barplot(height = df$num, names = df$ColorCoche,
        col = c("red", "green", "white", "blue"))
```

### GRÁFICO DE BARRAS DE UNA VARIABLE CONTINUA

En caso de que se esté **trabajando con una variable continua**, se deberá usar la función **cut()** para **clasificar los datos**. De lo contrario, en caso de ausencia de empates, se tendrá tantas barras como la longitud del vector y las alturas de las barras serán iguales a 1.

En el siguiente ejemplo, se dividirán los datos de 0 a 45 en pasos de 5 con el argumento **breaks =**.

```{r}
x = c(2.1, 8.6, 3.9, 4.4, 4.0, 3.7, 7.6, 3.1, 5.0,
      5.5, 20.2, 1.7, 5.2, 33.7, 9.1, 1.6, 3.1, 5.6,
      16.5, 15.8, 5.8, 6.8, 3.3, 40.6)

barplot(table(cut(x, breaks = seq(0, 45, by = 5))))
```

### GRÁFICO DE BARRAS HORIZONTAL EN R

Por defecto, los gráfficos de barras en R se dibujan verticalmente. Sin embargo, es común representar gráficos de barras horizontales. Se piede rotar 90 grados el gráfico y crear un gráfico de barras horizontales estableciendo el argumento **horiz =** como **TRUE**.

```{r}
barplot(mi_tabla, main = "Gráfico de barras horizontal",
        ylab = "Número de cilindros", xlab = "Frecuencia",
        horiz = TRUE) # Gráfico de barras horizontal
```

### LEYENDA DEL GRÁFICO DE BARRAS

Se puede agregar una leyenda a un diagrama de barras en R con el argumento **legend.text =**, donde se uede especificar los nombres que se quieren agregar a la leyenda. Hay que tener en cuenta que **en RStudio la gráfica resultante puede ser ligeramente diferente**, ya que por ejemplo el fondo de la leyenda será blanco en lugar de transparnte.[^ii]

[^ii]: Nótese que, al usar el argumento **legend.text =**, la **leyenda puede superponerse al diagrama de barras**.

```{r}
barplot(mi_tabla, xlab = "Número de cilindros",
        col = rainbow(3),
        legend.text = rownames(mi_tabla)) # Leyenda
```

El método más fácil para resolver este problema en este ejemplo, es mover la leyenda a la izquierda. Esto se puede lograr con el argumento **args.legend =**, donde se puede establecer los parámetros de gráficos dentro de una lista. Se puede estaplecer la posición en *"top"*, *"bottom"*, *"topleft"*, *"toprigth"*, *"bottomleft"* y *"bottomrigth"*.

```{r}
barplot(mi_tabla, xlab = "Número de cilindros",
        col = c("#ABB2B9", "#566573", "#273746"),
        legend.text = rownames(mi_tabla),
        args.legend = list(x = "top"))
```

De manera equivalente, se puede lograr el diagrama anterior con la función **legend()** de la siguiente manera con los argumentos **legend =** y **fill =**.

```{r}
barplot(mi_tabla, xlab = "Número de cilindros",
        col = rainbow(3))
legend("top", legend = rownames(mi_tabla), fill = rainbow(3))
```

Sin embargo, este enfoque **solo funciona bien si la leyenda no se superpone a las barras en esas posiciones**. Un mejor enfoque es **mover la leyenda a la derecha, fuera del gráfico de barras**. Puede hacerse esto configurando el argumento **insert =** dentro de una lista pasada como parámetro al argumento **args.legend =** de la siguiente manera.

```{r}
par(mar = c(5, 5, 4, 10))
barplot(mi_tabla, xlab = "Número de cilindros",
        col = rainbow(3),
        legend.text = rownames(mi_tabla), 
        # Valores de la leyenda
        args.legend = list(x = "topright", 
                           inset = c(-0.20, 0))) 
# Argumentos de la leyenda
```

## GRÁFICO DE BARRAS AGRUPADAS EN R

Una gráfica de barras agrupadas es una **gráfica de barras en R con dos o más variables**. El gráfico mostrará las barras para cada una de las múltiples variables.

```{r}
# Convertimos la variable 'am' en factor
am = factor(am)

# Cambiamos los niveles del factor
levels(am) = c("Automatica", "Manual")

# Tabla cilindros - tipo de transmisión
tabla_variables = table(cyl, am)
# tabla_variables = xtabs(~cyl + am , data = mtcars) # Equivalente

barplot(tabla_variables,
        main = "Gráfico de barras agrupado",
        xlab = "Tipo de transmisión", ylab = "Frecuencia",
        col = c("darkgrey", "darkblue", "red"),
        legend.text = rownames(tabla_variables),
        beside = TRUE) # Barras agrupadas
```

Nótese que si se hubiera especificado **table(am, cyl)** en lugar de **table(cyl, am)** el eje X representaría el número de cilindros, por lo que habría tres grupos con dos barras cada uno.

### ESPACIO ENTRE GRUPOS

Como se revisó anteriormente, se puede cambiar el espacio entre barras. En el caso de varios grupos, se puede establecer un vector de dos elementos donde **el primer elemento es el espacio entre barras de cada grupo** (0.4) y **el segundo espacio entre grupos** (2.5).

```{r}
barplot(tabla_variables,
        main = "Espacio entre grupos",
        xlab = "Tipo de transmisión", ylab = "Frecuencia",
        col = c("darkgrey", "darkblue", "red"),
        legend.text = rownames(tabla_variables),
        beside = TRUE,
        space = c(0.4, 2.5)) # Espacio
```

### VALORES NUMÉRICOS EN GRUPOS

Los gráficos de barras también se pueden usar para **resumir una variable en grupos dados por uno o varios factores**.

Supongamos que se desea mostrar la cantidad de cilindros y el tipo de transmisión en función de la potencia media de los automóviles. Se puede utilizar la función **tapply()** para crear la tabla correspondiente:

```{r}
resumen_datos = tapply(mtcars$hp, 
                       list(cilindros = mtcars$cyl,
                            transmision = am),
                       FUN = mean, na.rm = TRUE)

resumen_datos
```

Ahora se puede crear el diagrama de barras correspondiente en R:

```{r}
par(mar = c(5, 5, 4, 10))

barplot(resumen_datos, xlab = "Tipo de transmisión",
        main = "Media CV",
        col = rainbow(3),
        beside = TRUE,
        legend.text = rownames(resumen_datos),
        args.legend = list(title = "Cilindros", x = "topright",
                           inset = c(-0.20, 0)))
```

## GRÁFICO DE BARRAS EN R CON BARRAS DE ERROR

Por defecto, no se puede crear un **diagrama de barras con barras de error**. Sin embargo, la siguiente función permitirá crear un diagrama de barras totalmente personalizable con barras de error estándar:

```{r}
# Argumentos:
# x: un único factor
# y: un vector numérico
# ...: argumentos adicionales para ser pasados a la función barplot

barplot.error = function(x, y, ...) {
    mod = lm(y ~ x)
    reps = sqrt(length(y)/length(levels(x)))
    sem = sigma(mod)/reps
    means = tapply(y, x, mean)
    upper = max(means) + sem
    lev = levels(x)
    barpl = barplot(means, ...)
    invisible(sapply(1:length(barpl), function(i) arrows(barpl[i], means[i] + sem,
              barpl[i], means[i] - sem, angle = 90, code = 3, length = 0.08)))
}

# Llamamos a la función
barplot.error(factor(mtcars$cyl), mtcars$hp, col = rainbow(3), ylim = c(0, 250))
```

Aunque se puede agregar barras de error a un diagrama de barras en R, cabe destacar que un diagrama de caja por grupo podría ser un mejor enfoque para resumir los datos en este escenario.

## GRÁFICO DE BARRAS APILADAS EN R

Un gráfico de barras apiladas es como un diagrama de barras agrupado, pero la frecuencia de las variables está apilada. Este tipo de diagrama de barras se creará de forma predeterminada al pasar como argumento una tabla con dos o más variables, ya que el argumento **beside =** por defecto es **FALSE**.

```{r}
barplot(tabla_variables,
        main = "Gráfico de barras apilado",
        xlab = "Tipo de transmisión", ylab = "Frecuencia",
        col = c("#571845", "#c70039", "#ffc300"),
        legend.text = rownames(tabla_variables),
        beside = FALSE) # Barras apiladas (opción por defecto)
```

Relacionado con los gráfficos de barras apiladas, existen implementaciones similares, como el diagrama de espinas o **spineplot()** y el gráfico de mosaio o **mosaicplot()**. Este tipo de gráficos se pueden crear con las funciones **spineplot()** y **mosaicplot()** del paquete **graphics**.

El diagrama de tipo mosaico permite visualizar los datos de dos o más variables cuantitativas, donde el área de cada rectángulo representa la proporción de esa variable en cada grupo.

```{r}
# install.packages("graphics")
library(graphics)

mosaicplot(tabla_variables, main = "Mosaico")
```

El diagrama de espina es un caso especial de un diagrama de mosaico y es una generalización del diagrama de barras apilado. En este caso, a diferencia de los gráficos de barras apiladas, cada barra suma uno.

```{r}
spineplot(tabla_variables)
```
Hay que tener en cuenta que, por defecto, los ejes se intercambian con respecto al diagrama de barras apiladas que se creó en la sección anterior. Se puede crear el gráfico equivalente transponiendo la tabla de frecuencia con la función **t()**.

```{r}
spineplot(t(tabla_variables))
```

## GRÁFICO DE BARRAS EN R CON GGPLOT2

El paquete **ggplot2** es una biblioteca gráfica de R muy conocida. Se pueden crear diagramas de barras con esta biblioteca convirtiendo los datos en data frame y ussando las funciones **ggplot()** y **geom_bar()**. En el argumento **aes()** se debe pasar los nombres de las variables del data frame, en **x** la variable categórica y en **y** la numérica.

```{r}
# install.packages("ggplot2")
library(ggplot2)

df = as.data.frame(mi_tabla)

ggplot(data = df, aes(x = cyl, y = Freq)) +
       geom_bar(stat = "identity")
```

### GRÁFICO DE BARRAS HORIZONTAL EN GGPLOT2

En caso que se quiera rotar el diagrama de barras anterior, se puede usar la función **coord_flip()** de la siguiente manera:

```{r}
ggplot(data = df, aes(x = cyl, y = Freq)) +
  geom_bar(stat = "identity") +
  coord_flip()
```

\newpage

# CAPÍTULO 18

\newpage

## [**HISTOGRAMA EN R**](https://r-coder.com/histograma-r/)

![](hist-r.png)

Un histograma en R es el gráfico más habitual para representar datos continuos. Este tipo de gráfico es similar a un **diagrama de barras**, pero que representa las frecuencias en las que aparecen las mediciones agrupadas en ciertos intervalos y cuenta cuántas observaciones caen en cada uno de los intervalos. Además, la altura está determinada por el ratio entre la frecuencia y el ancho del intervalo.

## ¿CÓMO HACER UN HISTOGRAMA EN R? LA FUNCIÓN **hist()**

Para explicar los pasos para crear un **histograma en R**, debemos de utilizar los siguientes datos, que representan la distancia (en yardas) que recorre una pelota de golf después de ser golpeada.

```{r}
distancia = c(241.1, 284.4, 220.2, 272.4, 271.1, 268.3,
               291.6, 241.6, 286.1, 285.9, 259.6, 299.6,
               253.1, 239.6, 277.8, 263.8, 267.2, 272.6,
               283.4, 234.5, 260.4, 264.2, 295.1, 276.4,
               263.1, 251.4, 264.0, 269.2, 281.0, 283.2)
```

Se puede dibujar un histograma en R con la función **hist()**. Por defecto, la función creará un **histograma de frecuencias**.

```{r}
hist(distancia, 
     main = "Histograma de frecuencias", # Frecuencia
     ylab = "Frecuencia")
```

Sin embargo, si se establece el argumento **prob** como **TRUE**, se obtendrá un **histograma de densidad**.

```{r}
hist(distancia, prob = TRUE, 
     main = "Histograma de densidad", # Densidad
     ylab = "Densidad")
```

Además, se puede añadir un grid al histograma con la función **grid()** de la siguiente manera:

```{r}
hist(distancia, prob = TRUE, ylab = "Densidad", main = "Grid")
grid(nx = NA, ny = NULL, lty = 2, col = "gray50", lwd = 1)
hist(distancia, prob = TRUE, add = TRUE, col = "#82E0AA")
```

Hay que tener en cuenta que hay que codificar dos veces el histograma para que el grid salga por debajo de las barras en lugar de por encima.[^jhj]

[^jhj]:Desde **R 4.0.0** los histogramas son grises por defecto, no blancos.

## CAMBIAR EL COLOR DEL HISTOGRAMA

Ahora que ya sabemos como crear un histograma en R, también se puede personalizar. Si se quiere cambiar el color de las barras puede establecer el parámetro **col** al clor que se prefiera. Al igual que sucede con cualquier otro gráfico en R, se puede personalizar muchas características del gráfico, como el título, los ejes, el tamaño de la fuente, la escala de los ejes, entre otros...

```{r}
hist(distancia, main = "Cambiar color", ylab = "Frecuencia",
     col = "#EDBB99")
```

## EL ARGUMENTO **breaks**

Los histogramas son muy útiles para **representar la distribución subyacente de los datos** si el número de barras o clases se selecciona correctamente. Sin embargo, la selección del número de barras (o el ancho de las barras) puede ser complicada:

1. Pocas clases agruparán demasiado las observaciones.
2. Con demasiadas clases habrá pocas observaciones en cada una de ellas aumentando la variabilidad del gráfico obtenido.

Hay **varias reglas para determinar el número de barras**. En R, **el método de Sturges se usa por defecto**. Si se quiere cambiar el número de barras, se pasa el argumento **breaks** el número de clases que se quiera.

```{r}
par(mfrow = c(1, 3))

hist(distancia, breaks = 2, main = "Pocas clases", 
     ylab = "Frecuencia")

hist(distancia, breaks = 50, main = "Demasiadas clases", 
     ylab = "Frecuencia")

hist(distancia, main = "Método de Sturges", 
     ylab = "Frecuencia")

par(mfrow = c(1, 1))
```

También se puede usar el método plug-in (Wand, 1995) implementando en la librería **KernSmooth** para seleccionar el ancho de las barras del histograma:

```{r}
# Método plug-in
# install.packages("KernSmooth")
library(KernSmooth)

ancho_barras = dpih(distancia)

nbarras = seq(min(distancia) - ancho_barras,
               max(distancia) + ancho_barras, by = ancho_barras)

hist(distancia, breaks = nbarras, main = "Plug-in", ylab = "Frecuencia")
```

## HISTOGRAMA EN R CON DOS VARIABLES

Establecer el argumento **add** como **TRUE** permite añadir un histograma sobre otro gráfico. Como ejemplo, se puede crear un **histograma en R por grupo** con el código del siguiente bloque:

```{r}
set.seed(99)

x = rnorm(2000)    # Primer grupo
y = rnorm(2000, 1) # Segundo grupo

hist(x, main = "Dos variables", ylab = "Frecuencia")
hist(y, add = TRUE, col = rgb(1, 1, 0, alpha = 0.3))
```

La función **rgb()** permite establecer colores en canal RGB. El argumento **alpha** determina la transparencia. De hecho, cuando se combinan gráficos es una buena idea añadir colores con transparencia para no ocultar las representaciones entre si.

## HISTOGRAMA CON CURVA NORMAL

Para dibujar una curva normal sobre un histograma, puede usar las funciones **dnorm()** y **lines()** de la siguiente manera:

```{r}
hist(distancia, prob = TRUE,
     main = "Histograma con curva normal", ylab = "Densidad",
     col = "#F9E79F")
x = seq(min(distancia), max(distancia), length = 40)
f = dnorm(x, mean = mean(distancia), sd = sd(distancia))
lines(x, f, col = "#F1C40F", lwd = 2, lty = 1)
```

## AÑADIR CURVA DE DENSIDAD A UN HISTOGRAMA EN R

Para agregar una curva de densidad sobre un histograma, se puede usar la función **lines()** para trazar la curva y la función **density()** para calcular una estimación no paramétrica (tipo núcleo) de la distribución.[^jpas]

[^jpas]: La selección de ventana para ajustar las densidades no paramétricas es un área de intensa investigación. **Ademas, hay que tener en cuenta que por defecto, la función density() usa un núcleo gaussiano**. Para obtener más información, se ejecuta **?density**.

```{r}
hist(distancia, freq = FALSE, main = "Curva densidad",
     ylab = "Densidad", col = "#D2B4DE")
lines(density(distancia), lwd = 2, col = "#8E44AD")
```

Ahora se va a unir los códigos anteriores dentro de una función para **crear automáticamente un histograma con curvas normales y de densidad**.

```{r}
DenNorm = function(x, ...) {
  hist(x, ...) # Histograma
  lines(density(x), col = "#2E86C1", lwd = 2) # Densidad
  x2 = seq(min(x), max(x), length(40))
  f = dnorm(x2, mean(x), sd(x))
  lines(x2, f, col = "#CB4335", lwd = 2) # Normal
  legend("topright", c("Histograma", "Densidad", "Normal"), box.lty = 0,
         lty = 1, col = c("#000000", "#2E86C1", "#CB4335"), 
         lwd = c(1, 2, 2))
}
```

Ahora se puede verificar el comportamiento de la función anterior con datos de muestra.

```{r eval=FALSE}
set.seed(1)

# Datos normales
x = rnorm(n = 5000, mean = 110, sd = 5)

# Datos exponenciales
y = rexp(n = 3000, rate = 1)

# Datos normales
v = rnorm(n = 8000, mean = 100, sd = 7)

# Datos exponenciales
w = rexp(n = 6000, rate = 1)

par(mfcol = c(2, 2))

DenNorm(x, prob = TRUE, main = "Histograma de X", col = "#403891ff", 
        xlab = "")
DenNorm(y, prob = TRUE, main = "Histograma de Y", col = "#a65c85ff",
        xlab = "")
DenNorm(v, prob = TRUE, main = "Histograma de V", col = "#f68f46ff",
        xlab = "")
DenNorm(w, prob = TRUE, main = "Histograma de W", col = "#e8fa5bff",
        xlab = "")
```

```{r echo=FALSE}
set.seed(1)

# Datos normales
x = rnorm(n = 5000, mean = 110, sd = 5)

# Datos exponenciales
y = rexp(n = 3000, rate = 1)

# Datos normales
v = rnorm(n = 8000, mean = 100, sd = 7)

# Datos exponenciales
w = rexp(n = 6000, rate = 1)

par(mfcol = c(1, 2))

DenNorm(x, prob = TRUE, main = "Histograma de X", col = "#403891ff", 
        xlab = "")
DenNorm(y, prob = TRUE, main = "Histograma de Y", col = "#a65c85ff",
        xlab = "")
DenNorm(v, prob = TRUE, main = "Histograma de V", col = "#f68f46ff",
        xlab = "")
DenNorm(w, prob = TRUE, main = "Histograma de W", col = "#e8fa5bff",
        xlab = "")
```

## HISTOGRAMA Y BOXPLOT EN R

Se puede agregar un diagrama de cajas sobre un histograma escribiendo **par(new = TRUE)** entre los códigos de los dos gráficos:[^asdsa00]

[^asdsa00]: También se puede agregar la curva normal o de densidad al gráfico anterior.

```{r}
hist(distancia, probability = TRUE, ylab = "", main = "",
     col = rgb(1, 0, 0, alpha = 0.5), axes = FALSE)
axis(1) # Añade el eje horizontal
par(new = TRUE)
boxplot(distancia, horizontal = TRUE, axes = FALSE,
        lwd = 2, col = rgb(1, 1, 0, alpha = 0.2))
```

## HISTOGRAMA EN R CON LA LIBRERÍA **ggplot2**

Para crear un histograma con el paquete **ggplot2**, se debe usar las funciones **ggplot()** + **geom_histogram()** y pasar los datos como un data frame. En el argumento **aes()** se debe especificar el nombre de la variabel del data frame.[^qmmn]

[^qmmn]: Este gráfico devolverá un mensaje advirtiéndole que el histograma se calculó utilizando 30 clases. Esto se debe a que, de manera predeterminada, **ggplot** ***no utiliza el método de Sturges***.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# install.packages("ggplot2")
library(ggplot2)

ggplot(data.frame(distancia), aes(x = distancia)) + 
       geom_histogram(color = "#273746", fill = "#BDC3C7")
```

Ahora vamos a **calcular el número de barras con el método Sturges** como lo hace la función **hist()** y establecerlo con el argumento **breaks =**. Hay que tener en cuenta que también se puede establecer el argumento **binwidth =** si se prefiere.

```{r}
# Calculando el número de barras como la función hist()
nbreaks = pretty(range(distancia), n = nclass.Sturges(distancia),
                  min.n = 1)

ggplot(data.frame(distancia), aes(x = distancia)) + 
      geom_histogram(breaks = nbreaks, 
                     color = "#000000", fill = "#E59866")
```

Como se observa, el gráfico anterior es similar al primero que se creó como histograma con la base de R.

En **ggplot2** también se puede agregar la curva de densidad con la función **geom_density()**. Además, si se quiere rellenar el área debajo de la curva, se puede indicar en el argumento **fill =** el color que se prefiera y en el argumento **alpha =** el grado de transparencia del color. Hay que tener en cuenta que se necesita establecer un nuevo **aes()** dentro del **geom_histogram** de la siguiente manera:

```{r}
ggplot(data.frame(distancia), aes(x = distancia)) +
       geom_histogram(aes(y = ..density..), breaks = nbreaks,
                      color = "#000000", fill = "#E59866") +
       geom_density(fill = "black", alpha = 0.1)
```

## HISTOGRAMA EN **Plotly**

Una alternativa para crear histogramas es usar el paquete **plotly** (una adaptación de la librería de JavaScript para R), que crea gráficos en formato interactivo. Para un ejemplo se puede ejecutar lo siguiente:

```{r eval=FALSE}
# install.packages("plotly")
library(plotly)

# Histograma de frecuencias
fig = plot_ly(x = distancia, type = "histogram")
fig

# Histograma de densidad
fig = plot_ly(x = distancia, type = "histogram", histnorm = "probability")
fig
```

|**Histograma de Frecuencia**|**Histograma de Densidad**|
|------|------|
|![](histograma de frecuencia.png){width=50%} | ![](histograma de densidad.png){width=50%}|

\newpage

# CAPÍTULO 19

\newpage

## [**GRÁFICO DE DENSIDAD EN R**](https://r-coder.com/grafico-densidad-r/)

![](density-plot-r.png)

La función de densidad de probabilidad de un vector $x$, que se suele denotar como $f(x)$ **describe la probabilidad de que la variable tome un determinado valor**. La funcipon de densidad de probabilidad empírica es una versión suavizada del histograma. Esta suavización también se conoce como estimador de Parzen-Rosenblatt o estimador de kernel. Puedes hacer un gráfico de densidad en R de manera muy sencilla tal y xomo mostraremos en esta parte del manual.

## FUNCIÓN DE DENSIDAD EMPÍRICA EN R

Para **crear un gráfico de densidad en R**, se puede pasar la función **plot()** un objeto creado con la función **density()** de R, que dibujará una curva de densidad en una nueva ventana. Si se prefiere, también se puede superponer la línea de densidad sobre un histograma con la función **lines()**.

```{r}
# Datos de ejemplo
set.seed(9876)

# Se generan los datos
x = rnorm(600)

# Generamos una fila y dos columnas
par(mfrow = c(1, 2))

# Creamos el histograma
hist(x, freq = FALSE, main = "Histograma y densidad",
     ylab = "Densidad")

# Calculamos la densidad
dx = density(x)

# Se añade una línea de densidad
lines(dx, lwd = 2, col = "blue")

# Curva de densidad sin histograma
plot(dx, lwd = 2, col = "blue",
     main = "Densidad")

# Se añaden los datos con ruido en el eje "X"
rug(jitter(x))
```

El resultado es la **densidad de probabilidad empírica suavizada**. Una alternativa para crear una función de densidad en R es la función **epdfPlot()** del paquete **EnvStats**. Con esta función se puede pasar el vector numérico directamente como parámetro.

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
# Alternativo equivalente con el paquete EnvStats
# install.packages("EnvStats")

library(EnvStats)

epdfPlot(x, epdf.col = "blue")
```

## SELECCIÓN DE VENTANA PARA DENSIDADES TIPO NÚCLEO

Cuando se dibuja una función de densidad de probabilidad en R, se dibuja una estimación de **densidad tipo núcleo**. El gráfico de densidad tipo núcleo es un enfoque no paramétrico que **necesita seleccionar una ventana** (bandwidth). Se puede establecer la ventana con el argumento **bw** de la función **density()**.

En generarl, **una ventana grande suavizará la curva** de densidad, y **una pequeña provocará un sobreajuste de la estimación** de densidad tipo núcleo. En el siguiente bloque de código se verá un ejemplo que describe este problema.

```{r}
par(mfrow = c(1, 2))

# Ventana grande
plot(density(x, bw = 20), lwd = 2,
     col = "purple", main = "Ventana demasiado grande",
     panel.first = grid(col = "gray40"))

# Ventana pequeña
plot(density(x, bw = 0.05), lwd = 2,
     col = "purple", main = "Ventana demasiado pequeña",
     panel.first = grid(col = "gray40"))
```

De manera equivalente, se puede pasar argumentoss de la función **density()** a **epdfPlot()** dentro de una lista como parámetro del argumento **density.arg.list**. En este caso, se pasa el argumento **bw** de la función de densidad.

```{r}
# Alternativa equivalente con el paquete EnvStats
epdfPlot(x, epdf.col = "orange", density.arg.list = list(bw = 0.5),
         main = "Ventana demasiado pequeña")
```

La literatura sobre la selección de la ventana para estimar funciones de densidad tipo núcleo es amplia. Sin embargo, **hay tres enfoques principales comunmente utilizados para seleccionar el parámetro**:[^ñpolñpol]

[^ñpolñpol]: La selección del parámetro ventana dependerá de los datos con los que se trabaje o de los objetivos del estudio. **Se elije el método de selección con precaución**.

1. **Por defecto**, la función **density()** utiliza el enfoque que se conoce como la **"regla del pulgar"**.
2. Usando el método **plug-in**, desarrollado por Sheather y Jons (1991).
3. Usando el enfoque de **validación cruzada**.

En el siguiente código se muestra cómo aplicar uno de los enfoques:

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
par(mfrow = c(1, 3))

# Regla del pulgar
plot(density(x), main = "Regla del pulgar",
     cex.lab = 1.5, cex.main = 1.75, lwd = 2)

# Validación cruzada insesgada
plot(density(x, bw = bw.ucv(x)), col = 2, # Igual a: bw = "UCV"
     main = "Validación cruzada", cex.lab = 1.5,
     cex.main = 1.75, lwd = 2)

# Plug-in
plot(density(x, bw = bw.SJ(x)), col = 4, # Igual a: bw = "SJ"
     main = "Método plug-in",
     cex.lab = 1.5, cex.main = 1.75, lwd = 2)
```

También se puede **cambiar la función núcleo** con el argumento **kernel**, que **por defecto sserá gaussiano**. Aunque no se entrará más en detalles, los núcleos disponibles son: *"gaussiano"*, *"epanechnikov"*, *"rectangular"*, *"triangular"*, *"biweight"*, *"cosine"* y *"optcosine"*. La selección dependerá de los datos con los que se encuentre uno trabajando.

## MÚLTIPLES LÍNEAS DE DENSIDAD EN UN GRÁFICO

Con la función **lines()** se puede dibujar múltiples curvas de densidad en R. Solo se necesita crear un gráfico de densidad en R y añadir las nuevas líneas que quieras.

```{r}
par(mfrow = c(1, 1))

plot(dx, lwd = 2, col = "#403891B2",
    main = "Multiples curvas", xlab = "",
    panel.first = grid(col = "#2ECC71"))

# Nuevos datos
set.seed(55)
y = rnorm(900) + 1
dy = density(y)

# Nueva curva
lines(dy, col = "#F68F46B2", lwd = 2)
```

Sin embargo, puede que se haya dado en cuenta que la **curva naranja está cortada en el lado derecho**. Para arreglar esto se puede establecer los argumentos **xlim** e **ylim** entre el mínimo y el máximo para cada eje de todas las densidades que se vaya a dibujar.[^sksksk]

[^sksksk]: Al trazar varias líneas es una buena práctica para establecer los límites de los ejes con los argumentos **xlim** y **ylim** de la función **plot()**, porque los límites **se establecerán de forma predeterminada en los límites de la primera urva que se dibuje**.

```{r}
plot(dx, lwd = 2, col = "#403891B2",
    main = "Multiples curvas con los 
límites de los ejes corregidos", xlab = "",
    xlim = c(min(dx$x, dy$x), c(max(dx$x, dy$x))),  
    # Mínimo y máximo limites eje X
    ylim = c(min(dx$y, dy$y), c(max(dx$y, dy$y))),
    panel.first = grid(col = "#C0392B"))
    # Mínimo y máximo limites eje Y

lines(dy, col = "#F68F46B2", lwd = 2)
```

### GRÁFICOS DE COMPARACIÓN DE DENSIDADES EN R

Hay varias formas de comparar densidades. Un enfoque es utilizar la función **densityPlot** del paquete **car**. Esta función crea estimaciones de densidad no paramétricas condicionadas por un factor si se especifica. Se escribe **?densityPlot** para obtener información adicional sobre la función y el método.

```{r}
# Datos de ejemplo con grupos

# Grupos
set.seed(0)
grupos = factor(sample(c(1, 2), 400, replace = TRUE))

variable = numeric(400)

# Grupo 1: media 5
variable[grupos == 1] = rnorm(length(variable[grupos == 1]), 5)

# Grupo 2: media 0
variable[grupos == 2] = rnorm(length(variable[grupos == 2]))

# Comparando densidades por grupos
# install.packages("car")
library(car)

densityPlot(variable, grupos)
```

Otra alternativa es utilizar la función **sm.density.compare()** del paquete **sm**, que compara las densidades en un constraste de permutaciones.[^qepedo]

[^qepedo]: Hay que tener en cuenta que los gráficos de densidad son diferentes debido a que los métodos para calcular las densidades son diferentes. Consultar la bibliografía de cada método, disponible en la documentación de cada función, para obtener detalles adicionales.

```{r}
# install.packages("sm")                                                      
library(sm)

sm.density.compare(variable, grupos)                
legend("topleft", levels(grupos), col = 2:4, lty = 1:2) 
```

## COLOREAR EL ÁREA BAJO LAS CURVAS DE DENSIDAD

Con R base se puede usar la función **polygon()** para sombrear el área bajo las curvas de densidad. Se usa la función **rgb()** en el argumento **col** en lugar de un color básico, se puede establecer la **transparencia del área del diagrama de densidad** con el argumento **alpha**, que va desde 0, que es transparencia total hasta 1, que dibuja el color opaco.

```{r}
par(mfrow = c(1, 2))

#--------------------------------#
# Sombrear el área bajo la curva #
#--------------------------------#

plot(dx, lwd = 2, main = "", xlab = "",
     col = "#DC143C", xlim = c(-4, 6), ylim = c(0, 0.5))
polygon(dx, col = "#DC143C")
polygon(dx$x, dx$y, col = "#DC143C") # Equivalente

set.seed(200)
y = rnorm(1000) + 2
dy = density(y)

lines(dy, lwd = 2, col = "#FFD700")
polygon(dy, col = "#FFD700")


#--------------------------------------------------#
# Sombrear el área bajo la curva con transparencia #
#--------------------------------------------------#

plot(dx, lwd = 2, main = "", xlab = "",
     col = "#DC143C", xlim = c(-4, 6), ylim = c(0, 0.5))
polygon(dx, col = rgb(1, 0, 0, alpha = 0.5))

lines(dy, lwd = 2, col = "#FFD700")
polygon(dy, col = rgb(0, 0, 1, alpha = 0.5))
```

Si se está utilizando el paquete **EnvStats**, se puede configurar los colores con el argumento **curve.fill.col()** de la función **epdfPlot()**.

```{r}
# Alternativa equivalente con el paquete EnvStats

library(EnvStats)

epdfPlot(x, # Vector con datos
        curve.fill = TRUE, # Colorear el área
        curve.fill.col = rgb(1, 0, 0, alpha = 0.5), 
        # Color del área
        epdf.col = "red") # Color de la curva

epdfPlot(y, curve.fill = TRUE,
        curve.fill.col = rgb(0, 0, 1, alpha = 0.5),
        epdf.col = "blue",
        add = TRUE) # Añadir la densidad sobre el plot anterior
```

También se puede **sombrear solo un área específica debajo de la curva**. En el siguiente ejemplo, se muestran cómo colorear el área de la curva para valores de **x** mayores que 0.

```{r}
par(mfrow = c(1, 1))

plot(dx, lwd = 2, main = "Densidad", col = "red")

polygon(c(dx$x[dx$x >= 0], 0), c(dx$y[dx$x >= 0], 0),
        col = rgb(1, 0, 0, alpha = 0.5), border = "red",
        main = "")
```

## GRÁFICO DE DENSIDAD CON **ggplot2**

Se puede crear una gráfica de densidad con el paquete de R **ggplot2** con las funciones **ggplot2()** y **geom_density()** de la siguiente manera:

```{r}
library(ggplot2)

df = data.frame(x = x)

ggplot(df, aes(x = x)) + 
       geom_density(color = "#9400D3", # Color de la curva
                    fill = "#9400D3",  # Color del área sombreada
                    alpha = 0.5)   # Transparencia del color
```

Si se quiere agregar más de una curva, se puede establecer los límites del eje X con la función **xlim()** y agregar una leyenda con **scale_fill_discrete()** de la siguiente manera:

```{r eval=FALSE}
x = rnorm(600, 1)
y = rnorm(600, 3)

df = data.frame(x = x, y = y)
df = stack(df)

dx = density(x)
dy = density(y)

ggplot(df, aes(x = values, fill = ind)) + 
       geom_density(alpha = 0.5) + 
  # Densidades con transparencia
       xlim(c(min(dx$x, dy$x), # Límites del eje X
            c(max(dx$x, dy$x)))) +
       scale_fill_discrete(name = "Título de la leyenda", 
  # Cambiar el título de la leyenda
                           labels = c("A", "B")) 
  # + # Cambiar las etiquetas de la leyenda
  # theme(legend.position = "none") # Eliminar leyenda


# Equivalente
ggplot(df, aes(x = values)) +
       geom_density(aes(group = ind, fill = ind), alpha = 0.5) + 
       xlim(c(min(dx$x, dy$x), c(max(dx$x, dy$x)))) +
       scale_fill_discrete(name = "Título de la leyenda", 
                           labels = c("A", "B"))```
```

```{r echo=FALSE}
x = rnorm(600, 1)
y = rnorm(600, 3)

df = data.frame(x = x, y = y)
df = stack(df)

dx = density(x)
dy = density(y)

ggplot(df, aes(x = values, fill = ind)) + 
       geom_density(alpha = 0.5) + 
  # Densidades con transparencia
       xlim(c(min(dx$x, dy$x), # Límites del eje X
            c(max(dx$x, dy$x)))) +
       scale_fill_discrete(name = "Título de la leyenda", 
  # Cambiar el título de la leyenda
                           labels = c("A", "B")) 
  # + # Cambiar las etiquetas de la leyenda
  # theme(legend.position = "none") # Eliminar leyenda
```

\newpage

# CAPÍTULO 20

\newpage

## [**BOX PLOT EN R**](https://r-coder.com/boxplot-en-r/)

![](boxplot-r.png)

Los box plots, también conocidos como diagramas de cajas y bigotes, son una representación gráfica que permite resumir las características principales de los datos *(posición, dispersión, asimetría, ...)* e identificar la presencia de valores atípicos.

En otras palabras, un diagrama de caja es un gráfico que representa una variable cuantitativa o cualitativa a través de los cuartiles.

En estadística, es una herramienta útil para representar conjuntos de datos tanto discretos como continuos.

Es importante tener en cuenta que las variables cualitativas o que pretenden representar un orden o una categoría siempre tienen que ir ligadas a un índice numérico mayor que 0 para que puedan aparecer el gráfico y se puedan calcular los estadísticos correspondientes.[^quedopedo]

[^quedopedo]: *Diagrama de caja**Paula Rodó** (2022), *"Diagrama de caja"*, economipedia. Dispoible en: [https://economipedia.com/definiciones/diagrama-de-caja.html](https://economipedia.com/definiciones/diagrama-de-caja.html)

En esta sección del manual se revisará cómo hacer un box plot en base R y en ggplot2.

## ¿CÓMO INTERPRETAR UN DIAGRAMA DE CAJA Y BIGOTES EN R?

La caja de un boxplot comienza en el primer cuartil (25%) y termina en el tercero (75%). Por lo tanto, **la caja representa el 50% de los datos centrales, con una línea dentro que representa la mediana**. A cada lado de la caja se dibuja un segmento con los datos más lejanos sin contar los **valores atípicos** (outliers) del box plot, que en caso de existir, se representará con círculos.[^jhjhjz]

[^jhjhjz]: Un **dato atípico es aquella observación que está muy distante del resto de los datos**. Se dice que un valor atípico si es mayor que $Q_{3}+1.5\cdot{IQR}$ (valor atípico a la derecha), o es menor que $Q_{1}-1.5\cdot{IQR}$ (valor atípico a la izquierda), siendo $Q_{1}$ el rango intercuartil $(Q_{3}-Q_{1})$ que representa el ancho de la caja para diagramas de caja horizontales.

![](boxplot-esquema1.png)

## LA FUNCIÓN BOXPLOT EN R

En R base se puede crear un gráfico caja y bigotes con la función **boxplot()**. Se puede dibujar este tipo de gráficos desde diferentes entradas, como vectores o data frames, comose revisará en las siguientes subsecciones. En caso de dibujar diagramas de caja para múltiples grupos en el mismo gráfico también se puede especificar una fórmula como entrada. Además, es posible personalizar el gráfico de cajas resultante con varios argumentos, como se verá a continuación.

### BOXPLOT DE UN VECTOR

Si se pregunta uno cómo hacer un boxplot en R a partir de un vector, solo se necesita pasar el vector a la función **boxplot()**. Por defecto, el diagrama de caja será vertical, pero se puede cambiar la orientación estableciendo el argumento **horizontal** como **TRUE**.

```{r}
# Datos de muestra
x = c(7, 4, 16, -11, 19, 12, 3, 9, 7, 5,
       -4, 6, 8, 12, -10, 2, 0, -3, 8, 2)

# Boxplot
boxplot(x, horizontal = TRUE)
```

Hay que tener en cuenta que los diagramas de caja ocultan la distribución subyacente de los datos. Para resolver este problema, se puede agregar puntos al diagrama de cajas con la función **stripchart()** (el método de **jitter** evitará dibujar sobre los datos atípicos) de la siguiente manera:[^kolaka]

[^kolaka]: Desde **R 4.0.0** los gráficos de caja son grises por defecto en lugar de blanco.

```{r}
boxplot(x, horizontal = TRUE)
stripchart(x, method = "jitter", pch = 20, add = TRUE, col = "red")
```

### INTERVALO DE CONFIANZA PARA LA MEDIANA DEL BOXPLOT

Se puede representar los intervalos de confianza al 95% para la mediana en un diagrama de caja en R estableciendo el argumento **notch** como **TRUE**.[^huhuhuhu]

[^huhuhuhu]: Nótese que si los intervalos de confianza de dos o más diagramas de caja no se superponen significa que hay una fuerte evidencia estadística de que las medianas son diferentes.

```{r}
boxplot(x, horizontal = TRUE, notch = TRUE, col = "cornflowerblue")
# Agregar líneas al gráfico
grid(nx = NA, ny = NULL,
     lty = 2, col = "gray", lwd = 1)
```

### GRÁFICO DE CAJAS POR GRUPO

Si un conjunto de datos tiene una variable categórica que contiene grupos, se puede crear un diagrama de caja específicando una fórmula (**bariable_continua ~ variable_categórica**). Para este ejemplo, se va a usar el conjunto de datos **chickwts** de R base.
```{r include=FALSE}
head(chickwts)
```

```{r eval=FALSE}
# Base de datos
head(chickwts)
```

```{r eval=FALSE}
Output
   weight    feed
1   179    horsebean
2   160    horsebean
3   136    horsebean
4   227    horsebean
5   217    horsebean
6   168    horsebean
```

Ahora, se puede crear un diagrama de caja que muestre la variable **weigth** (peso) contra el tipo de alimentación (**feed**). Hay que tener en cuenta que al trabajar con datasets se puede llamar directamente a los nombres de las variables si especificamos el nombre del data frame en el argumento **data**.

```{r eval=FALSE}
boxplot(chickwts$weight ~ chickwts$feed, col = "cornflowerblue")
boxplot(weight ~ feed, data = chickwts, col = "cornflowerblue") 
# Equivalente```
```

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
boxplot(chickwts$weight ~ chickwts$feed, col = "cornflowerblue")
```

### MULTIPLES BOXPLOTS

En caso de que todas las variables del conjunto de datos sean variables numéricas, se puede crear directamente un diagrama de caja desde un data frame. Para ilustrarlo se va utilizar un conjunto de datos **trees**.[^aswqcde]

[^aswqcde]: Se puede apilar columnas de un data frame con la función **stack()**.

```{r include=FALSE}
head(trees)
```

```{r eval=FALSE}
# Cargamos la base de datos
head(trees)
```

```{r eval=FALSE}
Output
  Girth Height Volume
1   8.3     70   10.3
2   8.6     65   10.3
3   8.8     63   10.2
4  10.5     72   16.4
5  10.7     81   18.8
6  10.8     83   19.7
```

En caso de que se necesite dibujar un diagrama de caja diferente para cada columna de un data frame, se puede usar la función **lapply()** e iterar sobre cada columna. En este caso, se divide el panel gráfico en una fila y tantas columnas como se tenga el conjunto de datos. Otra alternativa sería dibujar boxplots de forma individual. La función **invisible()** evita mostrar el texto de salida de la función **lapply()**.

```{r}
par(mfrow = c(1, ncol(trees)))
invisible(lapply(1:ncol(trees), function(i) boxplot(trees[, i])))
```

Hay que tener en cuenta que se pueden cambiar los colores del diagrama de caja por grupo con un vector de colores como parámetro del argumento **col =**. Así, cada diagrama de caja tendrá un color diferente.[^kpopidol]

```{r, eval=FALSE}
# Boxplot del conjunto de datos "trees"
boxplot(trees, col = rainbow(ncol(trees)))

# Equivalente a:
boxplot(stacked_df$values ~ stacked_df$ind,
        col = rainbow(ncol(trees)))
```

```{r echo=FALSE}
# Boxplot del conjunto de datos "trees"
boxplot(trees, col = rainbow(ncol(trees)))
grid(nx = NULL, ny = NULL,
     lty = 2, col = "gray", lwd = 1)
```

### REORDENAR BOXPLOT EN R

Por defecto, los diagramas de caja **se dibujarán con el orden de los factores en los datos**. Sin embargo, se puede reordenar u ordenar un diagrama de caja en R reordenando los datos basándose en cualquier medida, como la mediana o la media con la función **reorder()**.

```{r}
par(mfrow = c(1, 2))

# De más bajo a más alto
medianas = reorder(chickwts$feed, chickwts$weight, median)
# medianas = with(chickwts, reorder(feed, weight, median)) 
# Equivalente

boxplot(chickwts$weight ~ medianas, las = 2, xlab = "", ylab = "",
        col = c("#440154FF", "#482677FF","#404788FF",
                "#39568CFF","#2D708EFF", "#238A8DFF"))
grid(nx = NA, ny = NULL,
     lty = 2, col = "gray", lwd = 1)

# De más alto a más bajo
medianas = reorder(chickwts$feed, -chickwts$weight, median)
# medianas = with(chickwts, reorder(feed, -weight, median)) 
# Equivalente

boxplot(chickwts$weight ~ medianas, las = 2, xlab = "", ylab = "",
        col = c("#1F968BFF", "#29AF7FFF","#55C667FF",
                "#73D055FF","#B8DE29FF", "#FDE725FF"))
grid(nx = NA, ny = NULL,
     lty = 2, col = "gray", lwd = 1)
```

### PERSONALIZAR UN BOXPLOT EN R

Un diagrama de cajas se puede persoalizar completamente. En el siguiente bloque de código se mostrará un ejemplo extenso de cómo personalizar un diagrama de cajas en R.[^Tiesto]

[^Tiesto]: Hay que tener en cuenta que hay incluso más argumentos que los del siguiente ejemplo para personalizar el diagrama de  caja, como **boxlty**, **boxlwd**, **medlty**, o **staplelwd**. Hay que revisar la lista completa de parámetros del gráfico de diagrama de cajas en el argumento **pars** de la ayuda de **?bxp** o **help(bxp)**.

```{r}
plot.new()

# Generamos una semilla para el diagrama
set.seed(777)

# Fondo gris claro
rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4],
     col = "#CDCDCD")

# Añadimos un grid blanco
grid(nx = NULL, ny = NULL, col = "white", lty = 1,
     lwd = par("lwd"), equilogs = TRUE)

# Boxplot
par(new = TRUE)
boxplot(rnorm(500), # Datos
        horizontal = FALSE, # Horizontal o vertical
        lwd = 2, # Lines width
        col = rgb(1, 1, 0, alpha = 0.4), # Color
        xlab = "Etiqueta eje X",  # Etiqueta eje X
        ylab = "Etiqueta eje Y",  # Etiqueta eje Y
        main = "Boxplot personalizado en R base", # Título
        notch = TRUE, # Añade intervalos de confianza para la mediana
        border = "black",  # Color del borde del boxplot
        outpch = 25,       # Símbolo para los outliers
        outbg = "orange",   # Color de los datos atípicos
        whiskcol = "red", # Color de los bigotes
        whisklty = 3,      # Tipo de línea para los bigotes
        lty = 1) # Tipo de línea (caja y mediana)

# Agregamos una leyenda
legend("topright", legend = "Boxplot", # Posición y título
    fill = rgb(1, 1, 0, alpha = 0.4),  # Color
    inset = c(0.03, 0.05), # Cambiamos los márgenes
    bg = "white") # Color de fondo de la leyenda
```

## AÑADIR LA MEDIA A UN BOXPLOT EN R

Por defecto, cuando se crea un diagrama de caja, se muestra la **mediana**. Sin embargo, **es posible que también se quiera mostrar la media u otra característica de los datos**. Para ese propósito, se puede usar la función **segments()** si se quiere mostrar una línea como la mediana, o la función **point()** para agregar puntos. Hay que tener en cuenta que **el código es ligeramente diferente si se crea un diagrama de caja vertical o un diagrama de caja horizontal**.

En el siguiente bloque de código se muestra cómo generar puntos y segmentos con la media a ambos tipos de diagramas de caja, cuando se trabaja con un solo diagrama de caja en el gráfico.

```{r}
par(mfrow = c(1, 2))

#------------------#
# Boxplot vertical #
#------------------#

boxplot(x)

# Añadir línea con la media
segments(x0 = 0.8, y0 = mean(x),
         x1 = 1.2, y1 = mean(x),
         col = "blue", lwd = 2)
# abline(h = mean(x), col = 2, lwd = 2) # Línea completa

# Añadir punto con la media
points(mean(x), col = 3, pch = 19)


#--------------------#
# Boxplot horizontal #
#--------------------#

boxplot(x, horizontal = TRUE)

# Añadir línea con la media
segments(x0 = mean(x), y0 = 0.8,
         x1 = mean(x), y1 = 1.2,
         col = "blue", lwd = 2)
# abline(v = mean(x), col = 2, lwd = 2) # Línea completa

# Añadir punto con la media
points(mean(x), 1, col = 3, pch = 19)

par(mfrow = c(1, 1))
```

Nótese que en este caso, la media y la mediana son casi iguales, ya que la distribución es simétrica.[^davidgolo]

[^davidgolo]: Se puede cambiar la función **mean()** del código anterior por otra función para mostrar otra mediana.

También se puede **agregar la media en boxplots por grupo**. En este caso, se puede hacer uso de la función **lapply()** y así evitar bucles. Para calcular la media de cada grupo se puede usar la función **apply()** por columnas o la función **colMeans()**, ya que es más eficiente. Se puede seguir el siguiente código para añadir los puntos y las líneas en boxplots horizontales y verticales.

```{r}
par(mfrow = c(1, 2))

mi_df = trees

#----------------------------#
# Boxplot vertical por grupo #
#----------------------------#

boxplot(mi_df, col = rgb(0, 1, 1, alpha = 0.25))

# Añadir líneas con las medias
invisible(lapply(1:ncol(mi_df),
                function(i) segments(x0 = i - 0.4,
                                     y0 = mean(mi_df[, i]),
                                     x1 = i + 0.4,
                                     y1 = mean(mi_df[, i]),
                                     col = "red", lwd = 2)))

# Añadir puntos con la medias
medias = apply(mi_df, 2, mean)
medias = colMeans(mi_df) # Equivalente (más eficiente)

points(medias, col = "red", pch = 19)


#------------------------------#
# Boxplot horizontal por grupo #
#------------------------------#

boxplot(mi_df, col = rgb(0, 1, 1, alpha = 0.25),
        horizontal = TRUE)

# Añadir líneas con la medias
invisible(lapply(1:ncol(mi_df),
                function(i) segments(x0 = mean(mi_df[, i]),
                                     y0 = i - 0.4,
                                     x1 = mean(mi_df[, i]),
                                     y1 = i + 0.4,
                                     col = "red", lwd = 2)))

# Añadir puntos con la medias
medias = apply(mi_df, 2, mean)
medias = colMeans(mi_df) # Equivalente (más eficiente)

points(medias, 1:ncol(mi_df), col = "red", pch = 19)
```

## DEVOLVER VALORES DE UN BOXPLOT

Si se asigna en el diagrama de caja a una variable, se puede devolver una lista con diferentes componentes. Crearemos un diagrama de cajas con el conjunto de datos **trees** y se almacerará en una variable:

```{r, eval=FALSE}
res = boxplot(trees)
res
```

```{r, eval=FALSE}
# Output
$`stats`
      [, 1] [, 2] [, 3]
[1, ]  8.30   63  10.2
[2, ] 11.05   72  19.4
[3, ] 12.90   76  24.2
[4, ] 15.25   80  37.3
[5, ] 20.60   87  58.3

$n
[1] 31 31 31

$conf
        [, 1]    [, 2]    [, 3]
[1, ] 11.70814 73.72979 19.1204
[2, ] 14.09186 78.27021 29.2796

$out
[1] 77

$group
[1] 3

$names
[1] "Girth" "Height" "Volume"
```

La salida contendrá seis elementos, descritos a continuación:

* **stats**: cada columna representa el bigote inferior, el primer cuartil, la mediana, el tercel cuartil y el bigote superior de cada grupo.
* **n**: número de observaciones de cada grupo.
* **conf**: cada columna representa los extremos inferior y superior del intervalo de confianza de la mediana.
* **out**: número total de valores atípicos.
* **group**: número total de grupos.
* **names**: nombres de cada grupo.


Es interesante destacar que se puede recrear el boxplot de la variable que se ha creado (**red**) con la función **bxp()**.

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
res = boxplot(trees)
res
```

```{r}
bxp(res)
```

## BOXPLOT E HISTOGRAMA EN R

Una limitación de los gráficos de caja y bigotes es que **no están diseñados para detectar multimodalidad**. Para esa razón, es recomendable dibujar diagramas de caja combinados con un histograma o una curva de densidad.[^llqpop]

[^llqpop]: Los **boxplots no están diseñados para detectar multimodalidad** en los datos.

```{r}
par(mfrow = c(1, 1))

# Datos multimodales
n = 45000
ii = rbinom(n, 1, 0.5)
dat = rnorm(n, mean = 150, sd = 11) * ii +
       rnorm(n, mean = 80, sd = 5) * (1 - ii)

# Histograma
hist(dat, probability = TRUE, ylab = "", col = "grey",
     axes = FALSE, main = "")

# Eje
axis(1)

# Densidad
lines(density(dat), col = "darkgreen", lwd = 2, lty = 3)

# Boxplot
par(new = TRUE)
boxplot(dat, horizontal = TRUE, axes = FALSE,
        lwd = 2, col = rgb(1, 1, 0, alpha = 0.20))
```

## BOXPLOT EN **ggplot2**

Los diagramas de caja que se han creado en las secciones anteriores también se pueden realizar con el paquete **ggplot2**.

### BOXPLOT EN GGPLOT2 A PARTIR DE UN VECTOR

El tipo de dato de entrada para usar la función **ggplot(()** tiene que ser un data frame, por lo que se tendrá que convertir un vector en clase de **data.frame()**. Una vez hecho eso, se puede usar la función **geom_boxplot()** para crear y personalizar la caja y la función **stat_bocplot()** para añadir bigotes.

```{r}
# install.packages("ggplot2")
library(ggplot2)

# Transformar x en un data frame
x = data.frame(x)

# Boxplot a partir de un vector
ggplot(data = x, aes(x = "", y = x)) +
      stat_boxplot(geom = "errorbar",      
      # Bigotes
      width = 0.2) +
      geom_boxplot(fill = "#4271AE",       
      # Color de la caja
      outlier.colour = "red", 
      # Color de los valores atípicos
      alpha = 0.9) +          
      # Transparencia del color de la caja
      ggtitle("Boxplot a partir de un vector") + 
      # Título del plot
      xlab("") +   
      # Etiqueta del eje x
      coord_flip() 
      # Boxplot horizontal
```

### BOXPLOT EN **ggplot2** POR GRUPO

Si se quiere crear un diagrama de caja con **ggplot2** por grupos, se deberá especificar las variables en el argumento **aes()** de la siguiente manera:

```{r}
# Boxplot por grupo
ggplot(data = chickwts, aes(x = feed, y = weight)) +
      stat_boxplot(geom = "errorbar", 
      # Bigotes
      width = 0.2) +
      geom_boxplot(fill = "#4271AE", colour = "#1F3552", 
      # Colores
      alpha = 0.9, outlier.colour = "red") +
      scale_y_continuous(name = "Peso") +  
      # Etiqueta de la variable continua
      scale_x_discrete(name = "Alimentación") +        
      # Etiqueta de los grupos
      ggtitle("Boxplot por grupos en ggplot2") +       
      # Título del plot
      theme(axis.line = element_line(colour = "black", 
      # Personalización del tema
      size = 0.25))
```

### BOXPLOT EN **ggplot2** DESDE UN DATA FRAME

Finalmente, para crear un boxplot con **ggplot2** directamente desde un conjunto de datos como el de **trees** se deberá aplicar primero los datos con la función **stack()**:

```{r}
# Boxplot a partir de un data frame
ggplot(data = stack(trees), aes(x = ind, y = values)) +
       stat_boxplot(geom = "errorbar", 
       # Bigotes
       width = 0.2) +
       geom_boxplot(fill = "#4271AE", colour = "#1F3552", 
       # Colores
       alpha = 0.9, outlier.colour = "red") +
       scale_y_continuous(name = "Peso") +  
       # Etiqueta de la variable continua
       scale_x_discrete(name = "Alimentación") +        
       # Etiqueta de los grupos
       ggtitle("Boxplot a partir de un data frame") +   
       # Título del plot
       theme(axis.line = element_line(colour = "black", 
       # Personalización del tema
       size = 0.25))
```

\newpage

# CAPÍTULO 21

\newpage

## [**EXPORTAR GRÁFICOS EN R**](https://r-coder.com/exportar-graficos-r/)

![](save-plot-r.png)

Cuando se desee exportar un gráfico para usarlo en un documento, como una presentación o un artículo científico, se debe guardar el gráfico en un formato de alta calidad, ya que no se querrá que los gráficos se vean borrosos o pixeleados. En este capítulo, se aprenderá a **exportar gráficos en R, en gráficos vectoriales y en formatos de imagen de alta resolución**.

## EXPORTAR GRÁFICOS CON EL MENÚ EN RSTUDIO Y R GUI

Si se está usando RStudio se puede exportar un gráfico desde el menú **Export** del panel de gráficos:

![](export-plot-rstudio.png)

El menú permite seleccionar **tres opciones**: guardar el plot como imagen, como PDF o copiar el gráfico al portapapeles.

### GUARDAR COMO IMAGEN

Si seleccionamos **Save as Image...** se abrirá la siguiente ventana:

![](save-plot-image-rstudio.png)

En la ventana anterior, se puede seleccionar el formato de imagen que se desea guardar el gráfico (PNG, JPEG, TIFF, BMP, Metafile, SVG, o EPS), el ancho y la altura en píxeles, el directorio en el que se guardará y el nombre del archivo.

### GUARDAR COMO PDF

Si se selecciona **Save as PDF...** se puede seleccionar el tamaño del PDF, la orientación, la API de cairo graphics, el directorio para guardar el archivo y el nombre del mismo.

![](export-pdf-rstudio.png)

### COPIAR AL PORTAPAPELES

La última opción que se puede seleccionar es copiar la imagen al portapapeles, como bitmap o metafile. También se puede especificar el ancho y el alto del gráfico en píxeles.

![](copy-plot-cipboard.png)

En R GUI se entrá que ir a **Archivp** → **Guardar como** y seleccionar el tipo de archivo que se prefiera. Si se selecciona **Jpeg**, también se puede especificar la calidad de la imagen resultante. Como última opción se puede copiar la imagen en el Prtapapeles (Copiar para el área de transferencia).

![](r-gui-guardar-plot.png)

En las siguientes secciones se revisará cómo **exportar gráficos en R con código**, lo que permite personalizar completamente la salida. Hay que recordar que los primeros tres (PDF, SVG, y PS) son formatos gráficos vectoriales y por tanto no depende de la resolución, mientras que los otros son formatos de imagen de alta resolución.

## GUARDAR PLOT EN R COMO PDF, SVG, O POSTSCRIPT (PS)

El formato para guardar imágenes es el más útil para crear documentos científicos, ya que son fáciles de agregar a LaTeX y mantienen la resolución incluso si se hace zoom. Sin embargo, si se necesita editar la imagen después de guardar para agregar algo de decoración o realiazr alguna modificación, se deberá usar SVG.

Primero, para **exportar un gráfico como PDF**, se necesitará abrir el dispositivo gráfico con la función **pdf()**, crear el gráfico que se quiera y, finalmente, cerrar el dispositivo abierto con la función **dev.off()**.

```{r, eval=FALSE}
PDF

# Abrimos el dispositivo gráfico
pdf("mi_plot.pdf")

# Creamos un gráfico
plot(rnorm(20))

# Cerramos el dispositivo gráfico
dev.off() 
```

También se puede cambiar el ancho y la altura (en pulgadas) del gráfico de salida, el tamaño del papel y del texto, o modificar el color de fondo, ya que el gráfico PDF tendrá un fondo transparente, o incluso el modo de color, entre otros parámetros gráficos.

```{r, eval=FALSE}
# Personalizamos la salida
pdf("mi_plot.pdf",         
    # Nombre del archivo
    width = 8, height = 7, 
    # Ancho y alto en pulgadas
    bg = "white",          
    # Color de fondo
    colormodel = "cmyk"    
    # Modo de color (cmyk para la mayoría de publicaciones)
    paper = "A4")          
    # Tamaño del papel

# Creamos un gráfico
plot(rnorm(20))

# Cerramos el dispositivo gráfico
dev.off() 
```

Hay que tener en cuenta que se puede convertir pulgadas a centímetros dividiendo por 2.54.[^papaletamordecai]

[^papaletamordecai]: De forma predeterminada, el argumento **paper** de la función **pdf()** está establecido en **"special"**, lo que significa que el tamaño del papel está definido por la altura y ancho especificados.

Recordemos que se puede ejecutar **?pdf** para obtener información adicional de los argumentos de la función.

Segundo, en R se puede exportar un gráfico a SVG (Scalable Vector Graphics) con la función **svg()**. Esta función también permite modificar el alto, ancho y tamaño del texto con los argumentos **height**, **width** y **pointzise**, respectivamente, pero también el anti-alias con el argumento **antialias**.

```{r, eval=FALSE}
SVG

# Dispositivo SVG
svg("mi_plot.svg")

# Código del gráfico
plot(rnorm(20))

# Cerramos el dispositivo
dev.off() 
```

Nótese que se pueden abrir los archivos SVG con Adobe Illustrator, Inkscape u otro software similar para editar el gráfico vectorial como se desee. Escribiendo **help(svg)** para obtener más información sobre los argumentos de la función.

En tercer lugar, para guardar un gráfico como Postscript, se puede utilizar la función **postscript()**.[^regularshow]

[^regularshow]: Estos formatos de imagen son independientes de la resolución. Esto significa que se puede hacer zoom en los gráficos resultantes sin perder calidad.

```{r, eval=FALSE}
postscript

# Dispositivo PS
postscript("mi_plot.ps")

# Código
plot(rnorm(20))

# Cerramos el dispositivo
dev.off() 
```

## EXPORTAR PLOT EN R COMO PNG, JPEG, BMPO TIFF

Las funciones de los dispositivos gráficos de formato PNG, JPEG, BMP y TIFF tiene distintos argumentos en común, descritos en la siguiente tabla.[^qmqmqmqmqmqmqmq]

[^qmqmqmqmqmqmqmq]: Si se configura el dispositivo gráfico en alta resolución (**res = 200**), se deberá modificar el alto y el ancho de la función correspondiente y los márgenes del gráfico con la función **par** para evitar perder el formato y el diseño original.

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Argumento = c("width",
             "height",
             "unit",
             "pointsize",
             "bg",
             "res",
             "type",
             "antialias")
Descripción = c("Ancho (por defecto 480 píxeles)",
                "Alto (por defecto 480 píxeles)",
                "Unidad de medida (“px”, “in”, “cm” y “mm”)",
                "Tamaño de los textos",
                "Color de fondo inicial",
                "Resolución en ppi",
                " 'cairo', 'Xlib', 'quartz' (y 'cairo-png' para PNG)",
                "Tipo de anti alias")
df = data.frame(Argumento, Descripción)

library(kableExtra)
head(df) %>% 
  kable(booktabs = TRUE,format = "latex",
caption = "Argumentos de un Plot en R") %>%
kable_styling(
latex_options = c("striped", "condensed","hold_position"),
position = "center",
full_width = FALSE)
```

Primero, la función **png()** permite guardar una imagen en un archivo PNG (Portable Network Graphics). Este formato de archivo de imagen pesa menos que JPEG con una mejor calidad, admitiendo fondos transparentes.

```{r, eval=FALSE}
PNG

# Dispositivo PNG
png("mi_plot.png")

# Código
plot(rnorm(20))

# Cerramos el dispositivo
dev.off()
```

Segundo, para guardar gráficos en JPEG, se puede usar la función **jpeg()**, que también permite establecer la calidad de la imagen como porcentaje con el argumento **quality** (por defecto 75%).

```{r, eval=FALSE}
JPEG 

# Dispositivo JPEG
jpeg("mi_plot.jpeg", quality = 75)

# Código
plot(rnorm(20))

# Cerramos el dispositivo
dev.off()
```

Tercero, se puede exportar un gráfico como BMP (Windows bitmap) con la funcción **bmp()**.

```{r, eval=FALSE}
bmp()

# Dispositivo BMP
bmp("mi_plot")

# Código
plot(rnorm(20))
# Cerramos el dispositivo
dev.off()
```

Por último, se puede guardar un plot como TIFF (Tagged Image File Format) con la función **tiff()**. Esta función permite establecer el tipo de comprensión, que por defecto es **"none"**, con el argumento **compression**. Otras opciones son **"rle"**, **"lzw"**, **"jpeg"**, **"zip"**, **"lzw+p"** y **"zip+p"**. Este argumento será ignorado si **type = "quartz"**. Se escribe **?tiff** para obtener información.

```{r, eval=FALSE}
TIFF

# Abrimos el dispositivo
tiff("mi_plot", compression = "zip")

# Hacemos un gráfico
plot(rnorm(20))

# Cerramos el dispositivo
dev.off()
```

## EXPORTAR VARIOS GRÁFICOS EN R A LA VEZ

Cabe mencionar que se puede **guardar varios gráficos a la vez en varias páginas**. Para los formatos de archivo PDF y SVG, el argumento **onefile** por defecto es **TRUE**, por lo que todos los gráficos que se creen antes de cerrar el dispositivo gráfico se guardarán en el mismo archivo:

```{r, eval=FALSE}
pdf("varios_plots.pdf")

for(i in 1:3) {
    set.seed(i)
    plot(rnorm(20), pch = 16, col = i)
}

dev.off()
```

Una alternativa es crear varios gráficos dentro de un bucle y nombrar cada uno con un nombre diferente, para que cada archivo se cree en un archivo separado.

```{r, eval=FALSE}
nplots = 2

for(i in 1:nplots) {
    png(paste("Rplot_", i, ".png"))
    set.seed(i)
    plot(rnorm(20), pch = 16, col = i)
    dev.off()
}
```

## LA FUNCIÓN **dev.print()** PARA EXPORTAR GRÁFICOS TAL Y COMO SE VEN

Finalmente, una alternativa para guardar gráficos en R sin la necesidad de usar los dispositivos gráficos es la función **dev.print()**. Esta función permite exportar una imagen en un archivo tal cual se ve, por lo que no se necesita ajustar todos los argumentos de la función correspondiente. Sin embargo, esta no es la mejor práctica para guardar gráficos.

```{r, eval=FALSE}
dev.print(pdf,           # Tipo de archivo para la exportación (svg, jpeg, ...)
          "mi_plot.pdf") # Nombre del archivo
```

\newpage

# CAPÍTULO 22

\newpage

## [**LEER EXCEL EN R**](https://r-coder.com/leer-excel-r/)

![](read-excel-r.png)

Excel es una hoja de cálculo desarrollada por MMicrosoft, que permite administrar los datos de una manera muy simple. Hasta 2007, XLS era la estensión de archivo principal. Sin embargo, en la versión de 2007 se introdujo la extensión XLSX (basada en XML), para convertirse en el formato de libro de Excel predeterminado. En este capítulo **se aorenderá a leer un Excel en R y RStudio** con varios paquetes.

## ¿CÓMO IMPORTAR ARCHIVOS EXCEL EN R?

Para trabajar con datos en Excel en R se deberá usar un paquete desarrollado para tal fin. Hay varias opciones, pero los mejores paquetes para leer archivos de Excel podrían ser **openxlsx** y **readxl**, ya que no dependen de JAVA (a diferencia de los paquetes **xlsx** y **XLConnect**) ni de Perl (como el paquete **gdata**).[^mommyarch]

[^mommyarch]: Hay que tener en cuenta que las **dependencias externas pueden causar errores** al cargar los paquetes, **pero para grandes conjuntos de datos deberían ser más rápidos** que las otras alternativas.

### IMPORTAR DATOS DE EXCEL EN RSTUDIO DESDE EL MENÚ

Si se está usando RStudio se puede ir a **File** → **Import Datase** → **From Excel...**. Luego, seleccionar el archivo de Excel dándole a **Browse...** y personalizar la salida (el nombre de la variable, la hoja, el rango de celdas,...). También se puede ver una vista previa del código que se ejecutará de fondo y de los datos que se cargarán. [^haloinfinitee]

[^haloinfinitee]: Hay que tener en cuenta que para utilizar este procedimiento se necesita tener instalado el paquete **readxl**.

![](import-dataset-excel-r.png)

![](import-excel-rstudio.png)

### LEEX XLSX SIN JAVA EN R: READXL Y OPENXLSX

#### EL PAQUETE READXL

El paquete **readxl** focientífico jefe en RStudio) y su equipo. Este paquete soporta XLS via la librería de C **libxls** y archivos XLSX via el paquete **RapidXML** de C++, sin la necesidad de utilizar dependencias externas.

El paquete proporciona algunos archivos Excel (XLS y XLSX) de muestra almacenados en la carpeta de instalación del paquete, por lo que con el objetivo de ofrecer un ejemplo reproducible, en los siguientes ejemplos vamos a utilizar el archivo **clippy.xlsx**, cuya primera hoja es la siguiente:

![](excel-file-sheet.png)

Para cargar la ruta del archivo Excel de muestra, se puede utilizar la función **readxl_example()**. Una vez cargado, o una vez que se tenga la ruta del propio archivo Excel, se puede usar la función **excel_sheets** para obtener los nombres de las hojas del archivo Excel, en caso de que se necesite.

```{r, eval=FALSE}
# install.packages("readxl")
library(readxl)

# Obtener la ruta de un archivo XLSX de ejemplo del paquete
ruta_archivo = readxl_example("clippy.xlsx")

# Comprobar los nombres de las hojas del archivo
excel_sheets(ruta_archivo) # "list-column" "two-row-header"
```

La función genérica del paquete para **leer archivos de Excel en R** es la función **read_excel()**, que *‘adivina’* el tipo de archivo (XLS o XLSX) según la extensión del archivo y el archivo en sí, en ese orden.

```{r, eval=FALSE}
read_excel(ruta_archivo)
```

```{r, eval=FALSE}
# Output

# A tibble: 4 x 2
  name                 value    
  <chr>                <chr>    
1 Name                 Clippy   
2 Species              paperclip
3 Approx date of death 39083    
4 Weight in grams      0.9
```

El argumento **sheet** permite  **especificar la hoja que se desea cargar**, pasando su nombre o el número correspondiente de la pestaña. Hay que tener en cuenta que, por defecto, la función carga la primera hoja de Excel.

```{r, eval=FALSE}
# Seleccionamos la otra hoja del Excel
read_excel(ruta_archivo, sheet = "two-row-header")
read_excel(ruta_archivo, sheet = 2) # Equivalente
```

```{r, eval=FALSE}
# Output

# A tibble: 2 x 4
  name       species              death                 weight    
  <chr>      <chr>                <chr>                 <chr>     
1 (at birth) (office supply type) (date is approximate) (in grams)
2 Clippy     paperclip            39083                 0.9 
```

También se puede  **saltar filas** con el argumento  **skip** de la función:

```{r, eval=FALSE}
# Saltar la primera fila
read_excel(ruta_archivo, skip = 1)
```

```{r, eval=FALSE}
# Output

# A tibble: 3 x 2
  Name                 Clippy   
  <chr>                <chr>    
1 Species              paperclip
2 Approx date of death 39083    
3 Weight in grams      0.9  
```

Hay que tener en cuenta que se puede  **especificar un rango de celdas** con el argumento **range**. En este caso, el argumento **skip** no se tendrá en cuenta si se especifica.

```{r, eval=FALSE}
read_excel(ruta_archivo, range = "B1:B5")
```

```{r, eval=FALSE}
# Output

# A tibble: 4 x 1
  value    
  <chr>    
1 Clippy   
2 paperclip
3 39083    
4 0.9 
```

Además, si se quiere  **evitar leer los nombres de las columnas**, se puede establecer el argumento **col_names** como **FALSE**:

```{r, eval=FALSE}
read_excel(ruta_archivo, col_names = FALSE)
```

```{r, eval=FALSE}
New names:
* `` -> ...1
* `` -> ...2
                  ...1      ...2
1                 name     value
2                 Name    Clippy
3              Species paperclip
4 Approx date of death     39083
5      Weight in grams       0.9
```

Sin embargo, es posible que se haya notado que **la salida es de clase** **tibble** (un tipo moderno de data frame). Si se quiere que la salida sea de clase **data.frame**, se deberá usar la función **as.data.frame()** de la siguiente manera:

```{r, eval=FALSE}
data = read_excel(ruta_archivo, skip = 1)
as.data.frame(data)
```

```{r, eval=FALSE}
# Output

                  Name    Clippy
1              Species paperclip
2 Approx date of death     39083
3      Weight in grams       0.9
```

Hay que recordar que la función **read_excel()** 'adivina' la extensión de archivo. No obstante, si se conoce la extensión del archivo que se va a leer, se puede usar la función correspondiente de las siguientes para evitar ese proceso de 'adivinación':

```{r, eval=FALSE}
# Si conoces la extensión del archivo
# usa una de estas dos funciones

# Para archivos XLS
read_xls()

# Para archivos XLSX
read_xlsx()
```

#### EL PAQUETE OPENXLSX

El paquete  **openxlsx** usa **Rcpp** y, como no depende de JAVA, es una alternativa interesante al paquete **readxl** para leer un archivo Excel en R. Las diferencias respecto al paquete anterior son que la **salida es de clase** **data.frame** por defecto en lugar de un **tibble** y que su uso principal no es solo la importación de archivos de Excel, ya que **también proporciona una amplia variedad de fuciones para escribir, diseñar y editar archivos de Excel**.

La función para leer archivos XLSX se llama **read.xlsx()**:

```{r, eval=FALSE}
# install.packages("openxlsx")
library(openxlsx)

read.xlsx(ruta_archivo)
```

```{r, eval=FALSE}
# Output
                  name     value
1                 Name    Clippy
2              Species paperclip
3 Approx date of death     39083
4      Weight in grams       0.9
```

Como en la función del paquete anterior, existen varios argumentos que se puede personalizar, como **sheet**, **skip** o **colNames**. Si se quiere seleccionar celdas específicas se pueden usar los argumentos **rows** y **cols**. Hay que recordar escribir **?read.xlsx** o **help(read.xlsx)** para obtener información adicional.

```{r, eval=FALSE}
read.xlsx(ruta_archivo, cols = 1:2, rows = 2:3)
```

```{r, eval=FALSE}
# Output
     Name    Clippy
1 Species paperclip
```

## CONVERTIR ARCHIVOS XLSX A CSV

Por último, también se puede crear y convertir un archivo de Excel a formato CSV en R. Para este propósito, se puede usar la función **convert()** del paquete **rio**. Una alternativa sería guardar directamente el arcihvo de Excel como CSV con el manú de Microsft Excel.

```{r, eval=FALSE}
# install.packages("rio")
library(rio)

convert(ruta_archivo, "file.csv")
```

\newpage

# CAPÍTULO 23

\newpage

## [**LEER CSV EN R**](https://r-coder.com/leer-csv-r/)

![](read-csv-r.png)

Es habitual encontrar conjuntos de datos en formato CSV (valores separados por comas). Este tipo de almacenamiento de datos es una solución ligera para la mayoría de los casos. En este capítulo se aprenderá a leer un CSV en R para trabajar con él.

## ¿CÓMO LEER UN CSV EN R?

Esta sección del capítulo se aprenderá a **importar datos CSV en R o RStudio** con las funciones **read.csv()** y **read.csv2()**. Se puede ver la sintaxis básica de las funciones con los argumentos más comunes en el siguiente bloque de código. **?read.csv2**.

```{r, eval=FALSE}
Sintaxis básica

# Por defecto coma (,) como separador y punto 
# (.) como separador decimal
read.csv(file,                 
         # Nombre del archivo o ruta completa del archivo
         header = TRUE,        
         # Leer el encabezado (TRUE) o no (FALSE)
         sep = ",",            
         # Separador de los valores
         quote = "\"",         
         # Carácter de citaciones
         dec = ".",            
         # Punto decimal
         fill = TRUE,          
         # Rellenar celdas vacías (TRUE) o no (FALSE)
         comment.char = "",    
         # Carácter de los comentarios o cadenas vacías
         encoding = "unknown", 
         # Codificación del archivo
         ...)                  
         # Argumentos adicionales

# Por defecto punto y coma (;) como separador y coma 
# (,) como separador decimal
read.csv2(file, header = TRUE, sep = ";", quote = "\"",
          dec = ",", fill = TRUE, comment.char = "",
          encoding = "unknown", ...)
```

Es posible que se haya notado que la única diferencia entre las funciones es el separador de valores y el separador decimal, debido a que en **algunos países usan comas como separador decimal**.

**En este segundo caso**, para crear archivos CSV **se necesida el punto y coma** y por tanto, para  **importar archivos con decimales**, es necesario cambiar los argumentos por defecto de la función **read.csv()**, o usar directamente la función **read.csv2()**.

La siguiente tabla resume los tras argumentos predeterminados principales:

|**Función**|**Header**|**Sep**|**Dec**|
|-----|-----|-----|-----|
|*read.csv()*|TRUE|","|"."|
|*read.csv2()*|TURE|";"|","|

Para cargar un archivo CSV en R con los argumentos predeterminados se puede pasar el archivo como cadena de carácteres a la función correspondiente. La salida será de clase **data.frame**.

```{r, eval=FALSE}
read.csv("mi_archivo.csv")
```

Si tan solo se ejecuta el código anterior se imprimiráel data frame, pero no se almacenará en memoria, ya que no se estará asignando a ninguna variable. Si se guarda, por ejemplo, en una variable llamada **mi_archivo**, se podrá acceder a las variables o a los datos que se quiera.[^heroeasdavidbowie]

[^heroeasdavidbowie]: El archivo debe estar en el directorio de trabajo. Si no lo está se necesitará especificar la ruta completa del archivo en el argumento **file**.

### ENCABEZADO DEL ARCHIVO CSV

**Por defecto**, las funciones **leen el encabezado** de los archivos. En caso de que se quiera **leer el CSV sin encabezado**, se deberá configurar como **FALSE** el argumento **header**.

```{r, eval=FALSE}
read.csv("mi_archivo.csv", header = FALSE)
```

### CODIFICACIÓN DEL CSV

Un problema común surge con la mala codificación de los archivos. En caso de que se esté leyendo un archivo con carácteres raros, tal vez se necesite especificar el argumento **encoding**. Establecer la codificación en **UTF-8** tiende a resolver la mayoría de estos problemas.[^orejadegg]

[^orejadegg]: Hay que tener en cuenta que este argumento y los siguientes se heredan de la función **read.table()**.

```{r, eval=FALSE}
read.csv("mi_archivo.csv", encoding = "UTF-8")
```

### EL ARGUMENTO **na.strings()**

Algunas veces los archivos contienen algunas **cadenas de carácteres que representan los valores faltantes u omitidas**. Se encontrará más información sobre cómo se manejan los valores faltantes en la fuente de donde se haya obtenido el conjunto de datos. Para resolver este problema, se puede convertir a valores **NA** con el argumento **na.strings()**, especificando la cadena de carácteres que representa el valor faltante.

Si, por ejemplo, en el archivo a utilizar los valores $-9999$ representan valores omitidos o faltantes, se puede escribir:

```{r, eval=FALSE}
read.csv("mi_archivo.csv", na.strings = "-9999") 
```

Además, en caso de que el archivo contenga múltiples **na.strings**, se puede especificar todo dentro de un vector.

```{r, eval=FALSE}
read.csv("mi_archivo.csv", na.strings = c("-9999" , "Na" )) 
```

Sin embargo, si se necesita eliminar los valores **NA** después de abrir el CSV, se deberá usar la función que corresponda según los datos. La función más habitual es **na.omit()**.

### EL ARGUMENTO **stringsAsFactor**

El argumento **stringsAsFactor** transformará las columnas de tipo carácter del conjunto de datos en factores.

```{r, eval=FALSE}
read.csv("mi_archivo.csv", stringsAsFactos = TRUE) 
```

## LEER MÚLTIPLES CSV EN R

Para finalizar, cabe desatacar que es posible importar múltiples archivos CSV al mismo tiempo en lugar de cargarlos en R uno por uno. Para ese propósito, se puede usar la función **list.files()** para buscar todos los archivos CSV y luego leerlos aplicando la función **read.csv()** (o **read.csv2**) con la función **sapply()**.

```{r, eval=FALSE}
archivos =  list.files(pattern = "*.csv")

multiples_csv = sapply(archivos, read.csv)
```

\newpage

# CAPÍTULO 24

\newpage

## [**LEER TXT EN R**](https://r-coder.com/leer-txt-r/)

![](read-txt-r.png)

El lenguaje de programación R permite **cargar archivos TXT**. Si uno se está preguntando **cómo leer archivos TXT en R**, la función más básica para ello es la función **read.table()**. En este capítulo se mostrará cómo leer el archivo txt en R con varios ejemplos y se revisará **cómo descargar o importar archivos TXT desde la web** para trabajar con ellos en R o RStudio.

## ¿CÓMO LEER ARCHIVOS TXT EN R?

Se puede leer un archivo TXT en R con la función **read.table()**. Importar archivos TXT en R rara vez se necesita más argumentos de los especificados a contniuación. Aun así, en las siguientes subsecciones se explicará dos o más (**skip** y **skipNul**) por si resultan de interés, pero en caso de que se quuiera conocer todos los argumentos, se puede encontrar en la [**documentación de la función readtable()**](https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/read.table)[^aslkdjalksjdlaksjd] o llamando a la ayuda de la función **?read.table**. Esta sintaxis básica afecta a casi todos los archivos de datos TXT.

[^aslkdjalksjdlaksjd]: El link directo se encuentra al dar click en las letras en negritas (**documentación de la función readtable()**). O al dar clik en el siguiente link: [https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/read.table](https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/read.table).

```{r, eval=FALSE}
Sintaxis básica

read.table(file,                 
           # Archivo de datos TXT indicado 
           # como string o ruta completa al archivo
           header = FALSE,       
           # Si se muestra el encabezado (TRUE) o no (FALSE)
           sep = "",             
           # Separador de las columnas del archivo
           dec = ".")            
           # Caracter utilizado para separar 
           # decimales de los números en el archivo
```

Consideremos, como ejemplo, que se iene un archivo llamado **mi_archivo.txt** y quee se ha **guardado en un directorio de trabajo**. Se puede leer con el siguiente código, si se quiere mostrar también el encabezado (nombres de las columnas).[^ññlolpu]

[^ññlolpu]: La salida de un archivo TXT leído con la función **read.table()** será de la clase "data frame".

```{r, eval=FALSE}
data = read.table(file = "mi_archivo.txt", header = TRUE)
head(data)
```

En caso de que se tenga que trabajar el archivo en otro directorio que no sea su directorio de trabajo, **se deberá especificar la ruta completa** donde se encuentr el archivo de datos.

```{r, eval=FALSE}
data = read.table(file = "C:\\Mi_ruta\\mi_archivo.txt",
                   header = TRUE)

data = read.table(file = "C:/Mi_ruta/mi_archivo.txt", 
                   header = TRUE) # Equivalente
```

También hay dos funciones (**read.delim()** y **read.delim2()**) para trabajar con archivos delimitados de forma predeterminada. Estas funciones tienen los argumentos predeterminados siguientes:

```{r, eval=FALSE}
Sintaxis

read.delim(file = "mi_archivo.txt" header = TRUE, 
           sep = "\t", dec = ".")

read.delim2(file = "mi_archivo.txt", header = TRUE, 
            sep = "\t", dec = ",")
```

|**Función**|**header**|**sep**|**dec**|
|-----|-----|-----|-----|
|read.table()|FLASE|""|"."|
|read.delim()|TRUE|"\t"|"."|
|read.delim2()|TRUE|"\t"|","|

### SALTAR FILAS CON EL ARGUMENTO **skip**

A veces, los archivos TXT que se está leyendo **contiene algunas líneas de texto antes del conjunto de datos**. Para ese propósito, se puede usar el argumento **skip**, que por defecto está establecido en 0. Como por ejemplo, en caso de que haya 5 líneas de texto antes de los datos, se puede leer el archivo de la siguiente manera:

```{r, eval=FALSE}
read.table(file = "mi_archivo.txt", skip = 5)
```

### ¿CÓMO IDENTIFICAR VALORES **NULL** EN UN TXT?

Si el archivo de datos TXT contiene valores **NULL**, se puede establecer el argumento **skipnul** como **TRUE** para obviarlos.

```{r, eval=FALSE}
read.table(file = "C:\\My_path\\mi_archivo.txt", skipnul = TRUE)
```

\newpage

# IMPORTAR TXT DESDE UNA URL EN R

En caso de que se tenga un archivo TXT alojado en algún sitio web, se puede abrir sin descargarlo. Solo se necesita pasar el URL como cadena al primer argumento de la función.

```{r, eval=FALSE}
url = "http://courses.washington.edu/b517/Datasets/string.txt"
datos = read.table(url, header = TRUE)
```

## DESCARGAR TXT EN R

Ahora que ya sabemos cómo leer un TXT en R, se debe de tener en cuenta que se puede **descargar directamente un archivo TXT** al directorio de trabajo con la función **download.file()**, pasando como primer argumento el enlace y como segundo el nombre que se le quiera poner a los datos de tipo .txt.

```{r, eval=FALSE}
getwd() # Directorio donde se guardará el archivo
url = "http://courses.washington.edu/b517/Datasets/string.txt"
download.file(url, "mi_archivo.txt")
```

Si no se quiere que el archivo se guarde en el directorio de trabajo actual, se puede especificar la ruta donde se quiera descargar el archivo.

```{r, eval=FALSE}
download.file(url, "C:\\carpeta\\mi_archivo.txt")
```

\newpage